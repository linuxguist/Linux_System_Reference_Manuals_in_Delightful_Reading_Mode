<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>Clone - recursively copy Perl datatypes</p>
<h1>SYNOPSIS</h1>
<p>use Clone clone; my $data = { set =&gt; [ 1 .. 50 ], foo =&gt; {
answer =&gt; 42, object =&gt; SomeObject-&gt;new, }, }; my $cloned_data
= clone($data); $cloned_data-&gt;{foo}{answer} = 1; print
$cloned_data-&gt;{foo}{answer}; # 1 print $data-&gt;{foo}{answer}; #
42</p>
<p>You can also add it to your class:</p>
<p>package Foo; use parent Clone; sub new { bless {}, shift } package
main; my $obj = Foo-&gt;new; my $copy = $obj-&gt;clone;</p>
<h1>DESCRIPTION</h1>
<p>This module provides a <code>clone()</code> method which makes
recursive copies of nested hash, array, scalar and reference types,
including tied variables and objects.</p>
<p><code>clone()</code> takes a scalar argument and duplicates it. To
duplicate lists, arrays or hashes, pass them in by reference, e.g.</p>
<p>my $copy = clone (\@array); # or my %copy = %{ clone (\%hash) };</p>
<h1>SEE ALSO</h1>
<p>Storable's <code>dclone()</code> is a flexible solution for cloning
variables, albeit slower for average-sized data structures. Simple and
naive benchmarks show that Clone is faster for data structures with 3 or
fewer levels, while <code>dclone()</code> can be faster for structures 4
or more levels deep.</p>
<h1>COPYRIGHT</h1>
<p>Copyright 2001-2022 Ray Finch. All Rights Reserved.</p>
<p>This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
<h1>AUTHOR</h1>
<p>Ray Finch <code>&lt;rdf@cpan.org&gt;</code></p>
<p>Breno G. de Oliveira <code>&lt;garu@cpan.org&gt;</code>, Nicolas
Rochelemagne <code>&lt;atoomic@cpan.org&gt;</code> and Florian Ragwitz
<code>&lt;rafl@debian.org&gt;</code> perform routine maintenance
releases since 2012.</p>
