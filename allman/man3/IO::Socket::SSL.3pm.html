<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>IO::Socket::SSL - SSL sockets with IO::Socket interface</p>
<h1>SYNOPSIS</h1>
<p>use strict; use IO::Socket::SSL; # simple client my $cl =
IO::Socket::SSL-&gt;new(www.google.com:443); print $cl "GET /
HTTP/1.0\r\n\r\n"; print &lt;$cl&gt;; # simple server my $srv =
IO::Socket::SSL-&gt;new( LocalAddr =&gt; 0.0.0.0:1234, Listen =&gt; 10,
SSL_cert_file =&gt; server-cert.pem, SSL_key_file =&gt; server-key.pem,
); $srv-&gt;accept;</p>
<h1>DESCRIPTION</h1>
<p>IO::Socket::SSL makes using SSL/TLS much easier by wrapping the
necessary functionality into the familiar IO::Socket interface and
providing secure defaults whenever possible. This way, existing
applications can be made SSL-aware without much effort, at least if you
do blocking I/O and don't use select or poll.</p>
<p>But, under the hood, SSL is a complex beast. So there are lots of
methods to make it do what you need if the default behavior is not
adequate. Because it is easy to inadvertently introduce critical
security bugs or just hard to debug problems, I would recommend studying
the following documentation carefully.</p>
<p>The documentation consists of the following parts:</p>
<ul>
<li><p>Essential Information About SSL/TLS</p></li>
<li><p>Basic SSL Client</p></li>
<li><p>Basic SSL Server</p></li>
<li><p>Common Usage Errors</p></li>
<li><p>Common Problems with SSL</p></li>
<li><p>Using Non-Blocking Sockets</p></li>
<li><p>Advanced Usage</p></li>
<li><p>Integration Into Own Modules</p></li>
<li><p>Description Of Methods</p></li>
</ul>
<p>Additional documentation can be found in</p>
<ul>
<li><p>IO::Socket::SSL::Intercept - Doing Man-In-The-Middle with
SSL</p></li>
<li><p>IO::Socket::SSL::Utils - Useful functions for certificates
etc</p></li>
</ul>
<h1>Essential Information About SSL/TLS</h1>
<p>SSL (Secure Socket Layer) or its successor TLS (Transport Layer
Security) are protocols to facilitate end-to-end security. These
protocols are used when accessing web sites (https), delivering or
retrieving email, and in lots of other use cases. In the following
documentation we will refer to both SSL and TLS as simply 'SSL'.</p>
<p>SSL enables end-to-end security by providing two essential
functions:</p>
<dl>
<dt>Encryption</dt>
<dd>
<p>This part encrypts the data for transit between the communicating
parties, so that nobody in between can read them. It also provides
tamper resistance so that nobody in between can manipulate the data.</p>
</dd>
<dt>Identification</dt>
<dd>
<p>This part makes sure that you talk to the right peer. If the
identification is done incorrectly it is easy to mount man-in-the-middle
attacks, e.g. if Alice wants to talk to Bob it would be possible for
Mallory to put itself in the middle, so that Alice talks to Mallory and
Mallory to Bob. All the data would still be encrypted, but not
end-to-end between Alice and Bob, but only between Alice and Mallory and
then between Mallory and Bob. Thus Mallory would be able to read and
modify all traffic between Alice and Bob.</p>
</dd>
</dl>
<p>Identification is the part which is the hardest to understand and the
easiest to get wrong.</p>
<p>With SSL, the Identification is usually done with
<strong>certificates</strong> inside a <strong>PKI</strong> (Public Key
Infrastructure). These Certificates are comparable to an identity card,
which contains information about the owner of the card. The card then is
somehow <strong>signed</strong> by the <strong>issuer</strong> of the
card, the <strong>CA</strong> (Certificate Agency).</p>
<p>To verify the identity of the peer the following must be done inside
SSL:</p>
<ul>
<li><p>Get the certificate from the peer. If the peer does not present a
certificate we cannot verify it.</p></li>
<li><p>Check if we trust the certificate, e.g. make sure it's not a
forgery. We believe that a certificate is not a fake if we either know
the certificate already or if we <strong>trust</strong> the issuer (the
CA) and can verify the issuers signature on the certificate. In reality
there is often a hierarchy of certificate agencies and we only directly
trust the root of this hierarchy. In this case the peer not only sends
his own certificate, but also all <strong>intermediate
certificates</strong>. Verification will be done by building a
<strong>trust path</strong> from the trusted root up to the peers
certificate and checking in each step if the we can verify the issuer's
signature. This step often causes problems because the client does not
know the necessary trusted root certificates. These are usually stored
in a system dependent CA store, but often the browsers have their own CA
store.</p></li>
<li><p>Check if the certificate is still valid. Each certificate has a
lifetime and should not be used after that time because it might be
compromised or the underlying cryptography got broken in the mean
time.</p></li>
<li><p>Check if the subject of the certificate matches the peer. This is
like comparing the picture on the identity card against the person
representing the identity card. When connecting to a server this is
usually done by comparing the hostname used for connecting against the
names represented in the certificate. A certificate might contain
multiple names or wildcards, so that it can be used for multiple hosts
(e.g. *.example.com and *.example.org). Although nobody sane would
accept an identity card where the picture does not match the person we
see, it is a common implementation error with SSL to omit this check or
get it wrong.</p></li>
<li><p>Check if the certificate was revoked by the issuer. This might be
the case if the certificate was compromised somehow and now somebody
else might use it to claim the wrong identity. Such revocations happened
a lot after the heartbleed attack. For SSL there are two ways to verify
a revocation, CRL and OCSP. With CRLs (Certificate Revocation List) the
CA provides a list of serial numbers for revoked certificates. The
client somehow has to download the list (which can be huge) and keep it
up to date. With OCSP (Online Certificate Status Protocol) the client
can check a single certificate directly by asking the issuer. Revocation
is the hardest part of the verification and none of today's browsers get
it fully correct. But, they are still better than most other
implementations which don't implement revocation checks or leave the
hard parts to the developer.</p></li>
</ul>
<p>When accessing a web site with SSL or delivering mail in a secure way
the identity is usually only checked one way, e.g. the client wants to
make sure it talks to the right server, but the server usually does not
care which client it talks to. But, sometimes the server wants to
identify the client too and will request a certificate from the client
which the server must verify in a similar way.</p>
<h1>Basic SSL Client</h1>
<p>A basic SSL client is simple:</p>
<p>my $client = IO::Socket::SSL-&gt;new(www.example.com:443) or die
"error=$!, ssl_error=$SSL_ERROR";</p>
<p>This will take the OpenSSL default CA store as the store for the
trusted CA. This usually works on UNIX systems. If there are no
certificates in the store it will try use Mozilla::CA which provides the
default CAs of Firefox.</p>
<p>In the default settings, IO::Socket::SSL will use a safer cipher set
and SSL version, do a proper hostname check against the certificate, and
use SNI (server name indication) to send the hostname inside the SSL
handshake. This is necessary to work with servers which have different
certificates behind the same IP address. It will also check the
revocation of the certificate with OCSP, but currently only if the
server provides OCSP stapling (for deeper checks see
<code>ocsp_resolver</code> method).</p>
<p>Lots of options can be used to change ciphers, SSL version, location
of CA and much more. See documentation of methods for details.</p>
<p>With protocols like SMTP it is necessary to upgrade an existing
socket to SSL. This can be done like this:</p>
<p>my $client = IO::Socket::INET-&gt;new(mx.example.com:25) or die $!; #
.. read greeting from server # .. send EHLO and read response # .. send
STARTTLS command and read response # .. if response was successful we
can upgrade the socket to SSL now:
IO::Socket::SSL-&gt;start_SSL($client, # explicitly set hostname we
should use for SNI SSL_hostname =&gt; mx.example.com ) or die
$SSL_ERROR;</p>
<p>A more complete example for a simple HTTP client:</p>
<p>my $client = IO::Socket::SSL-&gt;new( # where to connect PeerHost
=&gt; "www.example.com", PeerPort =&gt; "https", # certificate
verification - VERIFY_PEER is default SSL_verify_mode =&gt;
SSL_VERIFY_PEER, # location of CA store # need only be given if default
store should not be used SSL_ca_path =&gt; /etc/ssl/certs, # typical CA
path on Linux SSL_ca_file =&gt; /etc/ssl/cert.pem, # typical CA file on
BSD # or just use default path on system: IO::Socket::SSL::default_ca(),
# either explicitly # or implicitly by not giving SSL_ca_* # easy
hostname verification # It will use PeerHost as default name a
verification # scheme as default, which is safe enough for most
purposes. SSL_verifycn_name =&gt; foo.bar, SSL_verifycn_scheme =&gt;
http, # SNI support - defaults to PeerHost SSL_hostname =&gt; foo.bar, )
or die "failed connect or ssl handshake: $!,$SSL_ERROR"; # send and
receive over SSL connection print $client "GET / HTTP/1.0\r\n\r\n";
print &lt;$client&gt;;</p>
<p>And to do revocation checks with OCSP (only available with OpenSSL
1.0.0 or higher and Net::SSLeay 1.59 or higher):</p>
<p># default will try OCSP stapling and check only leaf certificate my
$client = IO::Socket::SSL-&gt;new($dst); # better yet: require checking
of full chain my $client = IO::Socket::SSL-&gt;new( PeerAddr =&gt; $dst,
SSL_ocsp_mode =&gt; SSL_OCSP_FULL_CHAIN, ); # even better: make OCSP
errors fatal # (this will probably fail with lots of sites because of
bad OCSP setups) # also use common OCSP response cache my $ocsp_cache =
IO::Socket::SSL::OCSP_Cache-&gt;new; my $client =
IO::Socket::SSL-&gt;new( PeerAddr =&gt; $dst, SSL_ocsp_mode =&gt;
SSL_OCSP_FULL_CHAIN|SSL_OCSP_FAIL_HARD, SSL_ocsp_cache =&gt;
$ocsp_cache, ); # disable OCSP stapling in case server has problems with
it my $client = IO::Socket::SSL-&gt;new( PeerAddr =&gt; $dst,
SSL_ocsp_mode =&gt; SSL_OCSP_NO_STAPLE, ); # check any certificates
which are not yet checked by OCSP stapling or # where we have already
cached results. For your own resolving combine # $ocsp-&gt;requests with
$ocsp-&gt;add_response(uri,response). my $ocsp =
$client-&gt;ocsp_resolver(); my $errors = $ocsp-&gt;resolve_blocking();
if ($errors) { warn "OCSP verification failed: $errors"; close($client);
}</p>
<h1>Basic SSL Server</h1>
<p>A basic SSL server looks similar to other IO::Socket servers, only
that it also contains settings for certificate and key:</p>
<p># simple server my $server = IO::Socket::SSL-&gt;new( # where to
listen LocalAddr =&gt; 127.0.0.1, LocalPort =&gt; 8080, Listen =&gt; 10,
# which certificate to offer # with SNI support there can be different
certificates per hostname SSL_cert_file =&gt; cert.pem, SSL_key_file
=&gt; key.pem, ) or die "failed to listen: $!"; # accept client my
$client = $server-&gt;accept or die "failed to accept or ssl handshake:
$!,$SSL_ERROR";</p>
<p>This will automatically use a secure set of ciphers and SSL version
and also supports Forward Secrecy with (Elliptic-Curve) Diffie-Hellmann
Key Exchange.</p>
<p>If you are doing a forking or threading server, we recommend that you
do the SSL handshake inside the new process/thread so that the master is
free for new connections. We recommend this because a client with
improper or slow SSL handshake could make the server block in the
handshake which would be bad to do on the listening socket:</p>
<p># inet server my $server = IO::Socket::INET-&gt;new( # where to
listen LocalAddr =&gt; 127.0.0.1, LocalPort =&gt; 8080, Listen =&gt; 10,
); # accept client my $client = $server-&gt;accept or die; # SSL upgrade
client (in new process/thread) IO::Socket::SSL-&gt;start_SSL($client,
SSL_server =&gt; 1, SSL_cert_file =&gt; cert.pem, SSL_key_file =&gt;
key.pem, ) or die "failed to ssl handshake: $SSL_ERROR";</p>
<p>Like with normal sockets, neither forking nor threading servers scale
well. It is recommended to use non-blocking sockets instead, see Using
Non-Blocking Sockets</p>
<h1>Common Usage Errors</h1>
<p>This is a list of typical errors seen with the use of
IO::Socket::SSL:</p>
<ul>
<li><p>Disabling verification with <code>SSL_verify_mode</code>. As
described in Essential Information About SSL/TLS, a proper
identification of the peer is essential and failing to verify makes
Man-In-The-Middle attacks possible. Nevertheless, lots of scripts and
even public modules or applications disable verification, because it is
probably the easiest way to make the thing work and usually nobody
notices any security problems anyway. If the verification does not
succeed with the default settings, one can do the following:</p>
<ul>
<li><p>Make sure the needed CAs are in the store, maybe use
<code>SSL_ca_file</code> or <code>SSL_ca_path</code> to specify a
different CA store.</p></li>
<li><p>If the validation fails because the certificate is self-signed
and that's what you expect, you can use the <code>SSL_fingerprint</code>
option to accept specific leaf certificates by their certificate or
pubkey fingerprint.</p></li>
<li><p>If the validation failed because the hostname does not match and
you cannot access the host with the name given in the certificate, you
can use <code>SSL_verifycn_name</code> to specify the hostname you
expect in the certificate.</p></li>
</ul>
<p>A common error pattern is also to disable verification if they found
no CA store (different modules look at different default places).
Because IO::Socket::SSL is now able to provide a usable CA store on most
platforms (UNIX, Mac OSX and Windows) it is better to use the defaults
provided by IO::Socket::SSL. If necessary these can be checked with the
<code>default_ca</code> method.</p></li>
<li><p>Polling of SSL sockets (e.g. select, poll and other event loops).
If you sysread one byte on a normal socket it will result in a syscall
to read one byte. Thus, if more than one byte is available on the socket
it will be kept in the network stack of your OS and the next select or
poll call will return the socket as readable. But, with SSL you don't
deliver single bytes. Multiple data bytes are packaged and encrypted
together in an SSL frame. Decryption can only be done on the whole
frame, so a sysread for one byte actually reads the complete SSL frame
from the socket, decrypts it and returns the first decrypted byte.
Further sysreads will return more bytes from the same frame until all
bytes are returned and the next SSL frame will be read from the socket.
Thus, in order to decide if you can read more data (e.g. if sysread will
block) you must check if there are still data in the current SSL frame
by calling <code>pending</code> and if there are no data pending you
might check the underlying socket with select or poll. Another way might
be if you try to sysread at least 16kByte all the time. 16kByte is the
maximum size of an SSL frame and because sysread returns data from only
a single SSL frame you can guarantee that there are no pending data.
Additionally, contrary to plain sockets the data delivered on the socket
are not necessarily application payload. It might be a TLS handshake, it
might just be the beginning of a TLS record or it might be TLS session
tickets which are send after the TLS handshake in TLS 1.3. In such
situations select will return that data are available for read since it
only looks at the plain socket. A sysread on the IO::Socket::SSL socket
will not return any data though since it is an abstraction which only
returns application data. This causes the sysread to hang in case the
socket was blocking or to return an error with EAGAIN on non-blocking
sockets. Applications using select or similar should therefore set the
socket to non-blocking and also expect that the sysread might
temporarily fail with EAGAIN. See also Using Non-Blocking
Sockets.</p></li>
<li><p>Expecting exactly the same behavior as plain sockets.
IO::Socket::SSL tries to emulate the usual socket behavior as good as
possible, but full emulation can not be done. Specifically a read on the
SSL socket might also result in a write on the TCP socket or a write on
the SSL socket might result in a read on the TCP socket. Also
<code>accept</code> and <strong>close</strong> on the SSL socket will
result in writing and reading data to the TCP socket too. Especially the
hidden writes might result in a connection reset if the underlying TCP
socket is already closed by the peer. Unless signal PIPE is explicitly
handled by the application this will usually result in the application
crashing. It is thus recommended to explicitly IGNORE signal PIPE so
that the errors get propagated as EPIPE instead of causing a crash of
the application.</p></li>
<li><p>Set 'SSL_version' or 'SSL_cipher_list' to a better value.
IO::Socket::SSL tries to set these values to reasonable, secure values
which are compatible with the rest of the world. But, there are some
scripts or modules out there which tried to be smart and get more secure
or compatible settings. Unfortunately, they did this years ago and never
updated these values, so they are still forced to do only 'TLSv1'
(instead of also using TLSv12 or TLSv11). Or they set 'HIGH' as the
cipher list and thought they were secure, but did not notice that 'HIGH'
includes anonymous ciphers, e.g. without identification of the peer. So
it is recommended to leave the settings at the secure defaults which
IO::Socket::SSL sets and which get updated from time to time to better
fit the real world.</p></li>
<li><p>Make SSL settings inaccessible by the user, together with bad
builtin settings. Some modules use IO::Socket::SSL, but don't make the
SSL settings available to the user. This is often combined with bad
builtin settings or defaults (like switching verification off). Thus the
user needs to hack around these restrictions by using
<code>set_args_filter_hack</code> or similar.</p></li>
<li><p>Use of constants as strings. Constants like
<code>SSL_VERIFY_PEER</code> or <code>SSL_WANT_READ</code> should be
used as constants and not be put inside quotes, because they represent
numerical values.</p></li>
<li><p>Forking and handling the socket in parent and child. A
<strong>fork</strong> of the process will duplicate the internal user
space SSL state of the socket. If both master and child interact with
the socket by using their own SSL state strange error messages will
happen. Such interaction includes explicit or implicit
<strong>close</strong> of the SSL socket. To avoid this the socket
should be explicitly closed with
<strong>SSL_no_shutdown</strong>.</p></li>
<li><p>Forking and executing a new process. Since the SSL state is
stored in user space it will be duplicated by a <strong>fork</strong>
but it will be lost when doing <strong>exec</strong>. This means it is
not possible to simply redirect stdin and stdout for the new process to
the SSL socket by duplicating the relevant file handles. Instead
explicitly exchanging plain data between child-process and SSL socket
are needed.</p></li>
</ul>
<h1>Common Problems with SSL</h1>
<p>SSL is a complex protocol with multiple implementations and each of
these has their own quirks. While most of these implementations work
together, it often gets problematic with older versions, minimal
versions in load balancers, or plain wrong setups.</p>
<p>Unfortunately these problems are hard to debug. Helpful for debugging
are a knowledge of SSL internals, wireshark and the use of the debug
settings of IO::Socket::SSL and Net::SSLeay, which can both be set with
<code>$IO::Socket::SSL::DEBUG</code>. The following debugs levels are
defined, but used not in any consistent way:</p>
<ul>
<li><p>0 - No debugging (default).</p></li>
<li><p>1 - Print out errors from IO::Socket::SSL and ciphers from
Net::SSLeay.</p></li>
<li><p>2 - Print also information about call flow from IO::Socket::SSL,
progress information from Net::SSLeay and state information from
OpenSSL.</p></li>
<li><p>3 - Print also some data dumps from IO::Socket::SSL and from
Net::SSLeay.</p></li>
</ul>
<p>Also, <code>analyze-ssl.pl</code> from the ssl-tools repository at
&lt;https://github.com/noxxi/p5-ssl-tools&gt; might be a helpful tool
when debugging SSL problems, as do the <code>openssl</code> command line
tool and a check with a different SSL implementation (e.g. a web
browser).</p>
<p>The following problems are not uncommon:</p>
<ul>
<li><p>Bad server setup: missing intermediate certificates. It is a
regular problem that administrators fail to include all necessary
certificates into their server setup, e.g. everything needed to build
the trust chain from the trusted root. If they check the setup with the
browser everything looks ok, because browsers work around these problems
by caching any intermediate certificates and apply them to new
connections if certificates are missing. But, fresh browser profiles
which have never seen these intermediates cannot fill in the missing
certificates and fail to verify; the same is true with
IO::Socket::SSL.</p></li>
<li><p>Old versions of servers or load balancers which do not understand
specific TLS versions or croak on specific data. From time to time one
encounters an SSL peer, which just closes the connection inside the SSL
handshake. This can usually be worked around by downgrading the SSL
version, e.g. by setting <code>SSL_version</code>. Modern Browsers
usually deal with such servers by automatically downgrading the SSL
version and repeat the connection attempt until they succeed. Worse
servers do not close the underlying TCP connection but instead just drop
the relevant packet. This is harder to detect because it looks like a
stalled connection. But downgrading the SSL version often works here
too. A cause of such problems are often load balancers or security
devices, which have hardware acceleration and only a minimal (and less
robust) SSL stack. They can often be detected because they support much
fewer ciphers than other implementations.</p></li>
<li><p>Bad or old OpenSSL versions. IO::Socket::SSL uses OpenSSL with
the help of the Net::SSLeay library. It is recommend to have a recent
version of this library, because it has more features and usually fewer
known bugs.</p></li>
<li><p>Validation of client certificates fail. Make sure that the
purpose of the certificate allows use as ssl client (check with
<code>openssl x509 -purpose</code>, that the necessary root certificate
is in the path specified by <code>SSL_ca*</code> (or the default path)
and that any intermediate certificates needed to build the trust chain
are sent by the client.</p></li>
<li><p>Validation of self-signed certificate fails even if it is given
with <code>SSL_ca*</code> argument. The <code>SSL_ca*</code> arguments
do not give a general trust store for arbitrary certificates but only
specify a store for CA certificates which then can be used to verify
other certificates. This especially means that certificates which are
not a CA get simply ignored, notably self-signed certificates which do
not also have the CA-flag set. This behavior of OpenSSL differs from the
more general trust-store concept which can be found in browsers and
where it is possible to simply added arbitrary certificates (CA or not)
as trusted.</p></li>
</ul>
<h1>Using Non-Blocking Sockets</h1>
<p>If you have a non-blocking socket, the expected behavior on read,
write, accept or connect is to set <code>$!</code> to EWOULDBLOCK if the
operation cannot be completed immediately. Note that EWOULDBLOCK is the
same as EAGAIN on UNIX systems, but is different on Windows.</p>
<p>With SSL, handshakes might occur at any time, even within an
established connection. In these cases it is necessary to finish the
handshake before you can read or write data. This might result in
situations where you want to read but must first finish the write of a
handshake or where you want to write but must first finish a read. In
these cases <code>$!</code> is set to EAGAIN like expected, and
additionally <code>$SSL_ERROR</code> is set to either SSL_WANT_READ or
SSL_WANT_WRITE. Thus if you get EWOULDBLOCK on a SSL socket you must
check <code>$SSL_ERROR</code> for SSL_WANT_* and adapt your event mask
accordingly.</p>
<p>Using readline on non-blocking sockets does not make much sense and I
would advise against using it. And, while the behavior is not documented
for other IO::Socket classes, it will try to emulate the behavior seen
there, e.g. to return the received data instead of blocking, even if the
line is not complete. If an unrecoverable error occurs it will return
nothing, even if it already received some data.</p>
<p>Also, I would advise against using <code>accept</code> with a
non-blocking SSL object because it might block and this is not what most
would expect. The reason for this is that <code>accept</code> on a
non-blocking TCP socket (e.g. IO::Socket::IP, IO::Socket::INET..)
results in a new TCP socket which does not inherit the non-blocking
behavior of the master socket. And thus, the initial SSL handshake on
the new socket inside <code>IO::Socket::SSL::accept</code> will be done
in a blocking way. To work around this you are safer by doing a TCP
accept and later upgrade the TCP socket in a non-blocking way with
<code>start_SSL</code> and <code>accept_SSL</code>.</p>
<p>my $cl = IO::Socket::SSL-&gt;new($dst); $cl-&gt;blocking(0); my $sel
= IO::Select-&gt;new($cl); while (1) { # with SSL a call for reading n
bytes does not result in reading of n # bytes from the socket, but
instead it must read at least one full SSL # frame. If the socket has no
new bytes, but there are unprocessed data # from the SSL frame can_read
will block! # wait for data on socket $sel-&gt;can_read(); # new data on
socket or eof READ: # this does not read only 1 byte from socket, but
reads the complete SSL # frame and then just returns one byte. On
subsequent calls it than # returns more byte of the same SSL frame until
it needs to read the # next frame. my $n = sysread( $cl,my $buf,1); if (
! defined $n ) { die $! if not $!{EWOULDBLOCK}; next if $SSL_ERROR ==
SSL_WANT_READ; if ( $SSL_ERROR == SSL_WANT_WRITE ) { # need to write
data on renegotiation $sel-&gt;can_write; next; } die "something went
wrong: $SSL_ERROR"; } elsif ( ! $n ) { last; # eof } else { # read next
bytes # we might have still data within the current SSL frame # thus
first process these data instead of waiting on the underlying # socket
object goto READ if $cl-&gt;pending; # goto sysread next; # goto
$sel-&gt;can_read } }</p>
<p>Additionally there are differences to plain sockets when using
select, poll, kqueue or similar technologies to get notified if data are
available. Relying only on these calls is not sufficient in all cases
since unread data might be internally buffered in the SSL stack. To
detect such buffering <strong>pending()</strong> need to be used.
Alternatively the buffering can be avoided by using
<strong>sysread</strong> with the maximum size of an SSL frame. See
Common Usage Errors for details.</p>
<h1>Advanced Usage</h1>
<h2>SNI Support</h2>
<p>Newer extensions to SSL can distinguish between multiple hostnames on
the same IP address using Server Name Indication (SNI).</p>
<p>Support for SNI on the client side was added somewhere in the OpenSSL
0.9.8 series, but with 1.0 a bug was fixed when the server could not
decide about its hostname. Therefore client side SNI is only supported
with OpenSSL 1.0 or higher in IO::Socket::SSL. With a supported version,
SNI is used automatically on the client side, if it can determine the
hostname from <code>PeerAddr</code> or <code>PeerHost</code> (which are
synonyms in the underlying IO::Socket:: classes and thus should never be
set both or at least not to different values). On unsupported OpenSSL
versions it will silently not use SNI. The hostname can also be given
explicitly given with <code>SSL_hostname</code>, but in this case it
will throw in error, if SNI is not supported. To check for support you
might call <code>IO::Socket::SSL-&gt;can_client_sni()</code>.</p>
<p>On the server side, earlier versions of OpenSSL are supported, but
only together with Net::SSLeay version &gt;= 1.50. To check for support
you might call <code>IO::Socket::SSL-&gt;can_server_sni()</code>. If
server side SNI is supported, you might specify different certificates
per host with <code>SSL_cert*</code> and <code>SSL_key*</code>, and
check the requested name using <code>get_servername</code>.</p>
<h2>Talk Plain and SSL With The Same Socket</h2>
<p>It is often required to first exchange some plain data and then
upgrade the socket to SSL after some kind of STARTTLS command. Protocols
like FTPS even need a way to downgrade the socket again back to
plain.</p>
<p>The common way to do this would be to create a normal socket and use
<code>start_SSL</code> to upgrade and stop_SSL to downgrade:</p>
<p>my $sock = IO::Socket::INET-&gt;new(...) or die $!; ... exchange
plain data on $sock until starttls command ...
IO::Socket::SSL-&gt;start_SSL($sock,%sslargs) or die $SSL_ERROR; ... now
$sock is an IO::Socket::SSL object ... ... exchange data with SSL on
$sock until stoptls command ... $sock-&gt;stop_SSL or die $SSL_ERROR;
... now $sock is again an IO::Socket::INET object ...</p>
<p>But, lots of modules just derive directly from IO::Socket::INET.
While this base class can be replaced with IO::Socket::SSL, these
modules cannot easily support different base classes for SSL and plain
data and switch between these classes on a starttls command.</p>
<p>To help in this case, IO::Socket::SSL can be reduced to a plain
socket on startup, and connect_SSL/accept_SSL/start_SSL can be used to
enable SSL and <code>stop_SSL</code> to talk plain again:</p>
<p>my $sock = IO::Socket::SSL-&gt;new( PeerAddr =&gt; ...
SSL_startHandshake =&gt; 0, %sslargs ) or die $!; ... exchange plain
data on $sock until starttls command ... $sock-&gt;connect_SSL or die
$SSL_ERROR; ... now $sock is an IO::Socket::SSL object ... ... exchange
data with SSL on $sock until stoptls command ... $sock-&gt;stop_SSL or
die $SSL_ERROR; ... $sock is still an IO::Socket::SSL object ... ... but
data exchanged again in plain ...</p>
<h1>Integration Into Own Modules</h1>
<p>IO::Socket::SSL behaves similarly to other IO::Socket modules and
thus could be integrated in the same way, but you have to take special
care when using non-blocking I/O (like for handling timeouts) or using
select or poll. Please study the documentation on how to deal with these
differences.</p>
<p>Also, it is recommended to not set or touch most of the
<code>SSL_*</code> options, so that they keep their secure defaults. It
is also recommended to let the user override these SSL specific settings
without the need of global settings or hacks like
<code>set_args_filter_hack</code>.</p>
<p>The notable exception is <code>SSL_verifycn_scheme</code>. This
should be set to the hostname verification scheme required by the module
or protocol.</p>
<h1>Description Of Methods</h1>
<p>IO::Socket::SSL inherits from another IO::Socket module. The choice
of the super class depends on the installed modules:</p>
<ul>
<li><p>If IO::Socket::IP with at least version 0.20 is installed it will
use this module as super class, transparently providing IPv6 and IPv4
support.</p></li>
<li><p>If IO::Socket::INET6 is installed it will use this module as
super class, transparently providing IPv6 and IPv4 support.</p></li>
<li><p>Otherwise it will fall back to IO::Socket::INET, which is a perl
core module. With IO::Socket::INET you only get IPv4 support.</p></li>
</ul>
<p>Please be aware that with the IPv6 capable super classes, it will
look first for the IPv6 address of a given hostname. If the resolver
provides an IPv6 address, but the host cannot be reached by IPv6, there
will be no automatic fallback to IPv4. To avoid these problems you can
enforce IPv4 for a specific socket by using the <code>Domain</code> or
<code>Family</code> option with the value AF_INET as described in
IO::Socket::IP. Alternatively you can enforce IPv4 globally by loading
IO::Socket::SSL with the option 'inet4', in which case it will use the
IPv4 only class IO::Socket::INET as the super class.</p>
<p>IO::Socket::SSL will provide all of the methods of its super class,
but sometimes it will override them to match the behavior expected from
SSL or to provide additional arguments.</p>
<p>The new or changed methods are described below, but please also read
the section about SSL specific error handling.</p>
<dl>
<dt>Error Handling</dt>
<dd>
<p>If an SSL specific error occurs, the global variable
<code>$SSL_ERROR</code> will be set. If the error occurred on an
existing SSL socket, the method <code>errstr</code> will give access to
the latest socket specific error. Both <code>$SSL_ERROR</code> and the
<code>errstr</code> method give a dualvar similar to <code>$!</code>,
e.g. providing an error number in numeric context or an error
description in string context.</p>
</dd>
<dt>new(...)</dt>
<dd>
<p>Creates a new IO::Socket::SSL object. You may use all the friendly
options that came bundled with the super class (e.g. IO::Socket::IP,
IO::Socket::INET, ...) plus (optionally) the ones described below. If
you don't specify any SSL related options it will do its best in using
secure defaults, e.g. choosing good ciphers, enabling proper
verification, etc.</p>
<dl>
<dt>SSL_server</dt>
<dd>
<p>Set this option to a true value if the socket should be used as a
server. If this is not explicitly set it is assumed if the
<code>Listen</code> parameter is given when creating the socket.</p>
</dd>
<dt>SSL_hostname</dt>
<dd>
<p>This can be given to specify the hostname used for SNI, which is
needed if you have multiple SSL hostnames on the same IP address. If not
given it will try to determine the hostname from <code>PeerAddr</code>,
which will fail if only an IP was given or if this argument is used
within <code>start_SSL</code>. If you want to disable SNI, set this
argument to ''. Currently only supported for the client side and will be
ignored for the server side. See section SNI Support for details of SNI
the support.</p>
</dd>
<dt>SSL_startHandshake</dt>
<dd>
<p>If this option is set to false (defaults to true) it will not start
the SSL handshake yet. This has to be done later with
<code>accept_SSL</code> or <code>connect_SSL</code>. Before the
handshake is started read/write/etc. can be used to exchange plain
data.</p>
</dd>
<dt>SSL_keepSocketOnError</dt>
<dd>
<p>If this option is set to true (defaults to false) it will not close
the underlying TCP socket on errors. In most cases there is no real use
for this behavior since both sides of the TCP connection will probably
have a different idea of the current state of the connection.</p>
</dd>
<dt>SSL_ca | SSL_ca_file | SSL_ca_path</dt>
<dd>
<p>Usually you want to verify that the peer certificate has been signed
by a trusted certificate authority. In this case you should use this
option to specify the file (<code>SSL_ca_file</code>) or directory
(<code>SSL_ca_path</code>) containing the certificate(s) of the trusted
certificate authorities. <code>SSL_ca_path</code> can also be an array
or a string containing multiple path, where the path are separated by
the platform specific separator. This separator is <code>;</code> on
DOS, Windows, Netware, <code>,</code> on VMS and <code>:</code> for all
the other systems. If multiple path are given at least one of these must
be accessible. You can also give a list of X509* certificate handles
(like you get from Net::SSLeay or IO::Socket::SSL::Utils::PEM_xxx2cert)
with <code>SSL_ca</code>. These will be added to the CA store before
path and file and thus take precedence. If neither SSL_ca, nor
SSL_ca_file or SSL_ca_path are set it will use <code>default_ca()</code>
to determine the user-set or system defaults. If you really don't want
to set a CA set SSL_ca_file or SSL_ca_path to <code>\undef</code> or
SSL_ca to an empty list. (unfortunately is used by some modules using
IO::Socket::SSL when CA is not explicitly given).</p>
</dd>
<dt>SSL_client_ca | SSL_client_ca_file</dt>
<dd>
<p>If verify_mode is VERIFY_PEER on the server side these options can be
used to set the list of acceptable CAs for the client. This way the
client can select they required certificate from a list of certificates.
The value for these options is similar to <code>SSL_ca</code> and
<code>SSL_ca_file</code>.</p>
</dd>
<dt>SSL_fingerprint</dt>
<dd>
<p>Sometimes you have a self-signed certificate or a certificate issued
by an unknown CA and you really want to accept it, but don't want to
disable verification at all. In this case you can specify the
fingerprint of the certificate as <code>algo$hex_fingerprint</code>.
<code>algo</code> is a fingerprint algorithm supported by OpenSSL, e.g.
'sha1','sha256'... and <code>hex_fingerprint</code> is the hexadecimal
representation of the binary fingerprint. Any colons inside the hex
string will be ignored. If you want to use the fingerprint of the pubkey
inside the certificate instead of the certificate use the syntax
<code>algo$pub$hex_fingerprint</code> instead. To get the fingerprint of
an established connection you can use <code>get_fingerprint</code>. It
is also possible to skip <code>algo$</code>, i.e. only specify the
fingerprint. In this case the likely algorithms will be automatically
detected based on the length of the digest string. You can specify a
list of fingerprints in case you have several acceptable certificates.
If a fingerprint matches the topmost (i.e. leaf) certificate no
additional validations can make the verification fail.</p>
</dd>
<dt>SSL_cert_file | SSL_cert | SSL_key_file | SSL_key</dt>
<dd>
<p>If you create a server you usually need to specify a server
certificate which should be verified by the client. Same is true for
client certificates, which should be verified by the server. The
certificate can be given as a file with SSL_cert_file or as an internal
representation of an X509* object (like you get from Net::SSLeay or
IO::Socket::SSL::Utils::PEM_xxx2cert) with SSL_cert. If given as a file
it will automatically detect the format. Supported file formats are PEM,
DER and PKCS#12, where PEM and PKCS#12 can contain the certificate and
the chain to use, while DER can only contain a single certificate. If
given as a list of X509* please note, that the all the chain
certificates (e.g. all except the first) will be consumed by openssl and
will be freed if the SSL context gets destroyed - so you should never
free them yourself. But the servers certificate (e.g. the first) will
not be consumed by openssl and thus must be freed by the application.
For each certificate a key is need, which can either be given as a file
with SSL_key_file or as an internal representation of an EVP_PKEY*
object with SSL_key (like you get from Net::SSLeay or
IO::Socket::SSL::Utils::PEM_xxx2key). If a key was already given within
the PKCS#12 file specified by SSL_cert_file it will ignore any SSL_key
or SSL_key_file. If no SSL_key or SSL_key_file was given it will try to
use the PEM file given with SSL_cert_file again, maybe it contains the
key too. If your SSL server should be able to use different certificates
on the same IP address, depending on the name given by SNI, you can use
a hash reference instead of a file with <code>&lt;hostname =</code>
cert_file&gt;&gt;. If your SSL server should be able to use both RSA and
ECDSA certificates for the same domain/IP a similar hash reference like
with SNI is given. The domain names used to specify the additional
certificates should be <code>hostname%whatever</code>, i.e.
<code>hostname%ecc</code> or similar. This needs at least OpenSSL 1.0.2.
To let the server pick the certificate based on the clients cipher
preference <code>SSL_honor_cipher_order</code> should be set to false.
In case certs and keys are needed but not given it might fall back to
builtin defaults, see Defaults for Cert, Key and CA. Examples:
SSL_cert_file =&gt; mycert.pem, SSL_key_file =&gt; mykey.pem,
SSL_cert_file =&gt; { "foo.example.org" =&gt; foo-cert.pem,
"foo.example.org%ecc" =&gt; foo-ecc-cert.pem, "bar.example.org" =&gt;
bar-cert.pem, # used when nothing matches or client does not support SNI
=&gt; default-cert.pem, %ecc =&gt; default-ecc-cert.pem, }, SSL_key_file
=&gt; { "foo.example.org" =&gt; foo-key.pem, "foo.example.org%ecc" =&gt;
foo-ecc-key.pem, "bar.example.org" =&gt; bar-key.pem, # used when
nothing matches or client does not support SNI =&gt; default-key.pem,
%ecc =&gt; default-ecc-key.pem, }</p>
</dd>
<dt>SSL_passwd_cb</dt>
<dd>
<p>If your private key is encrypted, you might not want the default
password prompt from Net::SSLeay. This option takes a reference to a
subroutine that should return the password required to decrypt your
private key.</p>
</dd>
<dt>SSL_use_cert</dt>
<dd>
<p>If this is true, it forces IO::Socket::SSL to use a certificate and
key, even if you are setting up an SSL client. If this is set to 0 (the
default), then you will only need a certificate and key if you are
setting up a server. SSL_use_cert will implicitly be set if SSL_server
is set. For convenience it is also set if it was not given but a cert
was given for use (SSL_cert_file or similar).</p>
</dd>
<dt>SSL_version</dt>
<dd>
<p>Sets the version of the SSL protocol used to transmit data. 'SSLv23'
uses a handshake compatible with SSL2.0, SSL3.0 and TLS1.x, while
'SSLv2', 'SSLv3', 'TLSv1', 'TLSv1_1', 'TLSv1_2', or 'TLSv1_3' restrict
handshake and protocol to the specified version. All values are
case-insensitive. Instead of 'TLSv1_1', 'TLSv1_2', and 'TLSv1_3' one can
also use 'TLSv11', 'TLSv12', and 'TLSv13'. Support for 'TLSv1_1',
'TLSv1_2', and 'TLSv1_3' requires recent versions of Net::SSLeay and
openssl. Independent from the handshake format you can limit to set of
accepted SSL versions by adding !version separated by ':'. The default
SSL_version is 'SSLv23:!SSLv3:!SSLv2' which means, that the handshake
format is compatible to SSL2.0 and higher, but that the successful
handshake is limited to TLS1.0 and higher, that is no SSL2.0 or SSL3.0
because both of these versions have serious security issues and should
not be used anymore. You can also use !TLSv1_1 and !TLSv1_2 to disable
TLS versions 1.1 and 1.2 while still allowing TLS version 1.0. Setting
the version instead to 'TLSv1' might break interaction with older
clients, which need and SSL2.0 compatible handshake. On the other side
some clients just close the connection when they receive a TLS version
1.1 request. In this case setting the version to
'SSLv23:!SSLv2:!SSLv3:!TLSv1_1:!TLSv1_2' might help.</p>
</dd>
<dt>SSL_cipher_list</dt>
<dd>
<p>If this option is set the cipher list for the connection will be set
to the given value, e.g. something like 'ALL:!LOW:!EXP:!aNULL'. This
will only affect ciphers for TLS 1.2 and lower. See the OpenSSL
documentation
(&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html#CIPHER-STRINGS&gt;)
for more details. Unless you fail to contact your peer because of no
shared ciphers it is recommended to leave this option at the default
setting, which uses the system default but disables some insecure
ciphers which might still be enabled on older systems. In case different
cipher lists are needed for different SNI hosts a hash can be given with
the host as key and the cipher suite as value, similar to
<strong>SSL_cert*</strong>.</p>
</dd>
<dt>SSL_ciphersuites</dt>
<dd>
<p>If this option is set the TLS 1.3 ciphersuites for the connection
will be set to the given value. This is similar to SSL_cipher_list, but
only for TLS 1.3 ciphers. See argument <code>-ciphersuits</code> in the
OpenSSL documentation
(&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html&gt;)
for details. Unless you fail to contact your peer because of no shared
ciphers it is recommended to leave this option at the default setting,
which uses the system default. In case different cipher lists are needed
for different SNI hosts a hash can be given with the host as key and the
cipher suite as value, similar to <strong>SSL_cert*</strong>.</p>
</dd>
<dt>SSL_honor_cipher_order</dt>
<dd>
<p>If this option is true the cipher order the server specified is used
instead of the order proposed by the client. This option defaults to
true to make use of our secure cipher list setting.</p>
</dd>
<dt>SSL_dh_file</dt>
<dd>
<p>To create a server which provides forward secrecy you need to either
give the DH parameters or (better, because faster) the ECDH curve. This
setting cares about DH parameters. To support non-elliptic
Diffie-Hellman key exchange a suitable file needs to be given here or
the SSL_dh should be used with an appropriate value. See dhparam command
in openssl for more information. If neither <code>SSL_dh_file</code> nor
<code>SSL_dh</code> are set a builtin DH parameter with a length of 2048
bit is used to offer DH key exchange by default. If you don't want this
(e.g. disable DH key exchange) explicitly set this or the
<code>SSL_dh</code> parameter to undef.</p>
</dd>
<dt>SSL_dh</dt>
<dd>
<p>Like SSL_dh_file, but instead of giving a file you use a preloaded or
generated DH*.</p>
</dd>
<dt>SSL_ecdh_curve</dt>
<dd>
<p>To create a server which provides forward secrecy you need to either
give the DH parameters or (better, because faster) the ECDH curve. This
setting cares about the ECDH curve(s). To support Elliptic Curve
Diffie-Hellmann key exchange the OID or NID of at least one suitable
curve needs to be provided here. With OpenSSL 1.1.0+ this parameter
defaults to <code>auto</code>, which means that it lets OpenSSL pick the
best settings. If support for CTX_set_ecdh_auto is implemented in
Net::SSLeay (needs at least version 1.86) it will use this to implement
the same default. Otherwise it will default to <code>prime256v1</code>
(builtin of OpenSSL) in order to offer ECDH key exchange by default. If
setting groups or curves is supported by Net::SSLeay (needs at least
version 1.86) then multiple curves can be given here in the order of the
preference, i.e. <code>P-521:P-384:P-256</code>. When used at the client
side this will include the supported curves as extension in the TLS
handshake. If you don't want to have ECDH key exchange this could be set
to undef or set <code>SSL_ciphers</code> to exclude all of these
ciphers. You can check if ECDH support is available by calling
<code>IO::Socket::SSL-&gt;can_ecdh</code>.</p>
</dd>
<dt>SSL_verify_mode</dt>
<dd>
<p>This option sets the verification mode for the peer certificate. You
may combine SSL_VERIFY_PEER (verify_peer),
SSL_VERIFY_FAIL_IF_NO_PEER_CERT (fail verification if no peer
certificate exists; ignored for clients), SSL_VERIFY_CLIENT_ONCE (verify
client once; ignored for clients). See OpenSSL man page for
SSL_CTX_set_verify for more information. The default is SSL_VERIFY_NONE
for server (e.g. no check for client certificate) and SSL_VERIFY_PEER
for client (check server certificate).</p>
</dd>
<dt>SSL_verify_callback</dt>
<dd>
<p>If you want to verify certificates yourself, you can pass a sub
reference along with this parameter to do so. When the callback is
called, it will be passed:</p>
<ol type="1">
<li></li>
</ol>
<ol start="2" type="1">
<li></li>
<li></li>
<li></li>
<li></li>
<li></li>
</ol>
<p>The function should return 1 or 0, depending on whether it thinks the
certificate is valid or invalid. The default is to let OpenSSL do all of
the busy work. The callback will be called for each element in the
certificate chain. See the OpenSSL documentation for SSL_CTX_set_verify
for more information.</p>
</dd>
<dt>SSL_verifycn_scheme</dt>
<dd>
<p>The scheme is used to correctly verify the identity inside the
certificate by using the hostname of the peer. See the information about
the verification schemes in <strong>verify_hostname</strong>. If you
don't specify a scheme it will use 'default', but only complain loudly
if the name verification fails instead of letting the whole certificate
verification fail. THIS WILL CHANGE, e.g. it will let the certificate
verification fail in the future if the hostname does not match the
certificate !!!! To override the name used in verification use
<strong>SSL_verifycn_name</strong>. The scheme 'default' is a superset
of the usual schemes, which will accept the hostname in common name and
subjectAltName and allow wildcards everywhere. While using this scheme
is way more secure than no name verification at all you better should
use the scheme specific to your application protocol, e.g. 'http',
'ftp'... If you are really sure, that you don't want to verify the
identity using the hostname you can use 'none' as a scheme. In this case
you'd better have alternative forms of verification, like a certificate
fingerprint or do a manual verification later by calling
<strong>verify_hostname</strong> yourself.</p>
</dd>
<dt>SSL_verifycn_publicsuffix</dt>
<dd>
<p>This option is used to specify the behavior when checking wildcards
certificates for public suffixes, e.g. no wildcard certificates for
*.com or *.co.uk should be accepted, while *.example.com or
*.example.co.uk is ok. If not specified it will simply use the builtin
default of IO::Socket::SSL::PublicSuffix, you can create another object
with from_string or from_file of this module. To disable verification of
public suffix set this option to .</p>
</dd>
<dt>SSL_verifycn_name</dt>
<dd>
<p>Set the name which is used in verification of hostname. If
SSL_verifycn_scheme is set and no SSL_verifycn_name is given it will try
to use SSL_hostname or PeerHost and PeerAddr settings and fail if no
name can be determined. If SSL_verifycn_scheme is not set it will use a
default scheme and warn if it cannot determine a hostname, but it will
not fail. Using PeerHost or PeerAddr works only if you create the
connection directly with <code>IO::Socket::SSL-&gt;new</code>, if an
IO::Socket::INET object is upgraded with <strong>start_SSL</strong> the
name has to be given in <strong>SSL_verifycn_name</strong> or
<strong>SSL_hostname</strong>.</p>
</dd>
<dt>SSL_check_crl</dt>
<dd>
<p>If you want to verify that the peer certificate has not been revoked
by the signing authority, set this value to true. OpenSSL will search
for the CRL in your SSL_ca_path, or use the file specified by
SSL_crl_file. See the Net::SSLeay documentation for more details. Note
that this functionality appears to be broken with OpenSSL &lt; v0.9.7b,
so its use with lower versions will result in an error.</p>
</dd>
<dt>SSL_crl_file</dt>
<dd>
<p>If you want to specify the CRL file to be used, set this value to the
pathname to be used. This must be used in addition to setting
SSL_check_crl.</p>
</dd>
<dt>SSL_ocsp_mode</dt>
<dd>
<p>Defines how certificate revocation is done using OCSP (Online Status
Revocation Protocol). The default is to send a request for OCSP stapling
to the server and if the server sends an OCSP response back the result
will be used. Any other OCSP checking needs to be done manually with
<code>ocsp_resolver</code>. The following flags can be combined with
<code>|</code>:</p>
<dl>
<dt>SSL_OCSP_NO_STAPLE</dt>
<dd>
<p>Don't ask for OCSP stapling. This is the default if SSL_verify_mode
is VERIFY_NONE.</p>
</dd>
<dt>SSL_OCSP_TRY_STAPLE</dt>
<dd>
<p>Try OCSP stapling, but don't complain if it gets no stapled response
back. This is the default if SSL_verify_mode is VERIFY_PEER (the
default).</p>
</dd>
<dt>SSL_OCSP_MUST_STAPLE</dt>
<dd>
<p>Consider it a hard error, if the server does not send a stapled OCSP
response back. Most servers currently send no stapled OCSP response
back.</p>
</dd>
<dt>SSL_OCSP_FAIL_HARD</dt>
<dd>
<p>Fail hard on response errors, default is to fail soft like the
browsers do. Soft errors mean, that the OCSP response is not usable,
e.g. no response, error response, no valid signature etc. Certificate
revocations inside a verified response are considered hard errors in any
case. Soft errors inside a stapled response are never considered hard,
e.g. it is expected that in this case an OCSP request will be send to
the responsible OCSP responder.</p>
</dd>
<dt>SSL_OCSP_FULL_CHAIN</dt>
<dd>
<p>This will set up the <code>ocsp_resolver</code> so that all
certificates from the peer chain will be checked, otherwise only the
leaf certificate will be checked against revocation.</p>
</dd>
</dl>
</dd>
<dt>SSL_ocsp_staple_callback</dt>
<dd>
<p>If this callback is defined, it will be called with the SSL object
and the OCSP response handle obtained from the peer, e.g.
<code>&lt;$cb-</code>($ssl,$resp)&gt;&gt;. If the peer did not provide a
stapled OCSP response the function will be called with
<code>$resp=undef</code>. Because the OCSP response handle is no longer
valid after leaving this function it should not by copied or freed. If
access to the response is necessary after leaving this function it can
be serialized with <code>Net::SSLeay::i2d_OCSP_RESPONSE</code>. If no
such callback is provided, it will use the default one, which verifies
the response and uses it to check if the certificate(s) of the
connection got revoked.</p>
</dd>
<dt>SSL_ocsp_cache</dt>
<dd>
<p>With this option a cache can be given for caching OCSP responses,
which could be shared between different SSL contexts. If not given a
cache specific to the SSL context only will be used. You can either
create a new cache with
<code>IO::Socket::SSL::OCSP_Cache-&gt;new([size])</code> or implement
your own cache, which needs to have methods
<code>put($key,\%entry)</code> and <code>get($key)</code> (returning
<code>\%entry</code>) where entry is the hash representation of the OCSP
response with fields like <code>nextUpdate</code>. The default
implementation of the cache will consider responses valid as long as
<code>nextUpdate</code> is less then the current time.</p>
</dd>
<dt>SSL_reuse_ctx</dt>
<dd>
<p>If you have already set the above options for a previous instance of
IO::Socket::SSL, then you can reuse the SSL context of that instance by
passing it as the value for the SSL_reuse_ctx parameter. You may also
create a new instance of the IO::Socket::SSL::SSL_Context class, using
any context options that you desire without specifying connection
options, and pass that here instead. If you use this option, all other
context-related options that you pass in the same call to
<strong>new()</strong> will be ignored unless the context supplied was
invalid. Note that, contrary to versions of IO::Socket::SSL below v0.90,
a global SSL context will not be implicitly used unless you use the
<strong>set_default_context()</strong> function.</p>
</dd>
<dt>SSL_create_ctx_callback</dt>
<dd>
<p>With this callback you can make individual settings to the context
after it got created and the default setup was done. The callback will
be called with the CTX object from Net::SSLeay as the single argument.
Example for limiting the server session cache size:
SSL_create_ctx_callback =&gt; sub { my $ctx = shift;
Net::SSLeay::CTX_sess_set_cache_size($ctx,128); }</p>
</dd>
<dt>SSL_session_cache_size</dt>
<dd>
<p>If you make repeated connections to the same host/port and the SSL
renegotiation time is an issue, you can turn on client-side session
caching with this option by specifying a positive cache size. For
successive connections, pass the SSL_reuse_ctx option to the
<strong>new()</strong> calls (or use
<strong>set_default_context()</strong>) to make use of the cached
sessions. The session cache size refers to the number of unique
host/port pairs that can be stored at one time; the oldest sessions in
the cache will be removed if new ones are added. This option does not
effect the session cache a server has for it's clients, e.g. it does not
affect SSL objects with SSL_server set. Note that session caching with
TLS 1.3 needs at least Net::SSLeay 1.86.</p>
</dd>
<dt>SSL_session_cache</dt>
<dd>
<p>Specifies session cache object which should be used instead of
creating a new. Overrules SSL_session_cache_size. This option is useful
if you want to reuse the cache, but not the rest of the context. A
session cache object can be created using
<code>IO::Socket::SSL::Session_Cache-&gt;new( cachesize )</code>. Use
<strong>set_default_session_cache()</strong> to set a global cache
object.</p>
</dd>
<dt>SSL_session_key</dt>
<dd>
<p>Specifies a key to use for lookups and inserts into client-side
session cache. Per default ip:port of destination will be used, but
sometimes you want to share the same session over multiple ports on the
same server (like with FTPS).</p>
</dd>
<dt>SSL_session_id_context</dt>
<dd>
<p>This gives an id for the servers session cache. It's necessary if you
want clients to connect with a client certificate. If not given but
SSL_verify_mode specifies the need for client certificate a context
unique id will be picked.</p>
</dd>
<dt>SSL_error_trap</dt>
<dd>
<p>When using the <strong>accept()</strong> or
<strong>connect()</strong> methods, it may be the case that the actual
socket connection works but the SSL negotiation fails, as in the case of
an HTTP client connecting to an HTTPS server. Passing a subroutine ref
attached to this parameter allows you to gain control of the orphaned
socket instead of having it be closed forcibly. The subroutine, if
called, will be passed two parameters: a reference to the socket on
which the SSL negotiation failed and the full text of the error
message.</p>
</dd>
<dt>SSL_npn_protocols</dt>
<dd>
<p>If used on the server side it specifies list of protocols advertised
by SSL server as an array ref, e.g. ['spdy/2','http1.1']. On the client
side it specifies the protocols offered by the client for NPN as an
array ref. See also method <code>next_proto_negotiated</code>. Next
Protocol Negotiation (NPN) is available with Net::SSLeay 1.46+ and
openssl-1.0.1+. NPN is unavailable in TLSv1.3 protocol. To check support
you might call <code>IO::Socket::SSL-&gt;can_npn()</code>. If you use
this option with an unsupported Net::SSLeay/OpenSSL it will throw an
error.</p>
</dd>
<dt>SSL_alpn_protocols</dt>
<dd>
<p>If used on the server side it specifies list of protocols supported
by the SSL server as an array ref, e.g. ['http/2.0',
'spdy/3.1','http/1.1']. On the client side it specifies the protocols
advertised by the client for ALPN as an array ref. See also method
<code>alpn_selected</code>. Application-Layer Protocol Negotiation
(ALPN) is available with Net::SSLeay 1.56+ and openssl-1.0.2+. More
details about the extension are in RFC7301. To check support you might
call <code>IO::Socket::SSL-&gt;can_alpn()</code>. If you use this option
with an unsupported Net::SSLeay/OpenSSL it will throw an error. Note
that some client implementations may encounter problems if both NPN and
ALPN are specified. Since ALPN is intended as a replacement for NPN, try
providing ALPN protocols then fall back to NPN if that fails.</p>
</dd>
<dt>SSL_ticket_keycb =&gt; [$sub,$data] | $sub</dt>
<dd>
<p>This is a callback used for stateless session reuse (Session Tickets,
RFC 5077). This callback will be called as
<code>$sub-&gt;($data,[$key_name])</code> where <code>$data</code> is
the argument given to SSL_ticket_keycb (or undef) and
<code>$key_name</code> depends on the mode:</p>
<dl>
<dt>encrypt ticket</dt>
<dd>
<p>If a ticket needs to be encrypted the callback will be called without
<code>$key_name</code>. In this case it should return
<code>($current_key,$current_key_name</code>) where
<code>$current_key</code> is the current key (32 byte random data) and
<code>$current_key_name</code> the name associated with this key
(exactly 16 byte). This <code>$current_key_name</code> will be
incorporated into the ticket.</p>
</dd>
<dt>decrypt ticket</dt>
<dd>
<p>If a ticket needs to be decrypted the callback will be called with
<code>$key_name</code> as found in the ticket. It should return
<code>($key,$current_key_name</code>) where <code>$key</code> is the key
associated with the given <code>$key_name</code> and
<code>$current_key_name</code> the name associated with the currently
active key. If <code>$current_key_name</code> is different from the
given <code>$key_name</code> the callback will be called again to
re-encrypt the ticket with the currently active key. If no key can be
found which matches the given <code>$key_name</code> then this function
should return nothing (empty list). This mechanism should be used to
limit the life time for each key encrypting the ticket. Compromise of a
ticket encryption key might lead to decryption of SSL sessions which
used session tickets protected by this key.</p>
</dd>
</dl>
<p>Example: Net::SSLeay::RAND_bytes(my $oldkey,32);
Net::SSLeay::RAND_bytes(my $newkey,32); my $oldkey_name =
pack("a16",oldsecret); my $newkey_name = pack("a16",newsecret); my @keys
= ( [ $newkey_name, $newkey ], # current active key [ $oldkey_name,
$oldkey ], # already expired ); my $keycb = [ sub { my ($mykeys,$name) =
@_; # return (current_key, current_key_name) if no name given return
($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name; # return
(matching_key, current_key_name) if we find a key matching # the given
name for(my $i = 0; $i&lt;@$mykeys; $i++) { next if $name ne
$mykeys-&gt;[$i][0]; return ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]); }
# no matching key found return; },\@keys ]; my $srv =
IO::Socket::SSL-&gt;new(..., SSL_ticket_keycb =&gt; $keycb);</p>
</dd>
<dt>SSL_mode_release_buffers 1|0</dt>
<dd>
<p>This enables or disables the SSL_MODE_RELEASE_BUFFERS option on the
SSL object. With this option the read buffer will be released after each
SSL_read but will need to be reallocated for each new SSL_read. If
memory usage is a concern this might save lots of memory in the mean
time though, about 34k per idle SSL connection according to the
documentation in <strong>SSL_CTX_set_mode</strong>(3ssl).</p>
</dd>
</dl>
</dd>
<dt>accept</dt>
<dd>
<p>This behaves similar to the accept function of the underlying socket
class, but additionally does the initial SSL handshake. But because the
underlying socket class does return a blocking file handle even when
accept is called on a non-blocking socket, the SSL handshake on the new
file object will be done in a blocking way. Please see the section about
non-blocking I/O for details. If you don't like this behavior you should
do accept on the TCP socket and then upgrade it with
<code>start_SSL</code> later.</p>
</dd>
<dt>connect(...)</dt>
<dd>
<p>This behaves similar to the connect function but also does an SSL
handshake. Because you cannot give SSL specific arguments to this
function, you should better either use <code>new</code> to create a
connect SSL socket or <code>start_SSL</code> to upgrade an established
TCP socket to SSL.</p>
</dd>
<dt>close(...)</dt>
<dd>
<p>Contrary to a close for a simple INET socket a close in SSL also
mandates a proper shutdown of the SSL part. This is done by sending a
close notify message by both peers. A naive implementation would thus
wait until it receives the close notify message from the peer - which
conflicts with the commonly expected semantic that a close will not
block. The default behavior is thus to only send a close notify but not
wait for the close notify of the peer. If this is required
<code>SSL_fast_shutdown</code> need to be explicitly set to false. There
are also cases where a SSL shutdown should not be done at all. This is
true for example when forking to let a child deal with the socket and
closing the socket in the parent process. A naive explicit
<code>close</code> or an implicit close when destroying the socket in
the parent would send a close notify to the peer which would make the
SSL socket in the client process unusable. In this case an explicit
<code>close</code> with <code>SSL_no_shutdown</code> set to true should
be done in the parent process. For more details and other arguments see
<code>stop_SSL</code> which gets called from <code>close</code> to
shutdown the SSL state of the socket.</p>
</dd>
<dt>sysread( BUF, LEN, [ OFFSET ] )</dt>
<dd>
<p>This function behaves from the outside the same as
<strong>sysread</strong> in other IO::Socket objects, e.g. it returns at
most LEN bytes of data. But in reality it reads not only LEN bytes from
the underlying socket, but at a single SSL frame. It then returns up to
LEN bytes it decrypted from this SSL frame. If the frame contained more
data than requested it will return only LEN data, buffer the rest and
return it on further read calls. This means, that it might be possible
to read data, even if the underlying socket is not readable, so using
poll or select might not be sufficient. sysread will only return data
from a single SSL frame, e.g. either the pending data from the already
buffered frame or it will read a frame from the underlying socket and
return the decrypted data. It will not return data spanning several SSL
frames in a single call. Also, calls to sysread might fail, because it
must first finish an SSL handshake. To understand these behaviors is
essential, if you write applications which use event loops and/or
non-blocking sockets. Please read the specific sections in this
documentation.</p>
</dd>
<dt>syswrite( BUF, [ LEN, [ OFFSET ]] )</dt>
<dd>
<p>This functions behaves from the outside the same as
<strong>syswrite</strong> in other IO::Socket objects, e.g. it will
write at most LEN bytes to the socket, but there is no guarantee, that
all LEN bytes are written. It will return the number of bytes written.
Because it basically just calls SSL_write from OpenSSL syswrite will
write at most a single SSL frame. This means, that no more than 16.384
bytes, which is the maximum size of an SSL frame, will be written at
once. For non-blocking sockets SSL specific behavior applies. Pease read
the specific section in this documentation.</p>
</dd>
<dt>peek( BUF, LEN, [ OFFSET ])</dt>
<dd>
<p>This function has exactly the same syntax as
<strong>sysread</strong>, and performs nearly the same task but will not
advance the read position so that successive calls to
<strong>peek()</strong> with the same arguments will return the same
results. This function requires OpenSSL 0.9.6a or later to work.</p>
</dd>
<dt>pending()</dt>
<dd>
<p>This function gives you the number of bytes available without reading
from the underlying socket object. This function is essential if you
work with event loops, please see the section about polling SSL
sockets.</p>
</dd>
<dt>get_fingerprint([algo,certificate,pubkey])</dt>
<dd>
<p>This methods returns the fingerprint of the given certificate in the
form <code>algo$digest_hex</code>, where <code>algo</code> is the used
algorithm, default 'sha256'. If no certificate is given the peer
certificate of the connection is used. If <code>pubkey</code> is true it
will not return the fingerprint of the certificate but instead the
fingerprint of the pubkey inside the certificate as
<code>algo$pub$digest_hex</code>.</p>
</dd>
<dt>get_fingerprint_bin([algo,certificate,pubkey])</dt>
<dd>
<p>This methods returns the binary fingerprint of the given certificate
by using the algorithm <code>algo</code>, default 'sha256'. If no
certificate is given the peer certificate of the connection is used. If
<code>pubkey</code> is true it will not return the fingerprint of the
certificate but instead the fingerprint of the pubkey inside the
certificate.</p>
</dd>
<dt>get_cipher()</dt>
<dd>
<p>Returns the string form of the cipher that the IO::Socket::SSL object
is using.</p>
</dd>
<dt>get_sslversion()</dt>
<dd>
<p>Returns the string representation of the SSL version of an
established connection.</p>
</dd>
<dt>get_sslversion_int()</dt>
<dd>
<p>Returns the integer representation of the SSL version of an
established connection.</p>
</dd>
<dt>get_session_reused()</dt>
<dd>
<p>This returns true if the session got reused and false otherwise. Note
that with a reused session no certificates are send within the handshake
and no ciphers are offered and thus functions which rely on this might
not work.</p>
</dd>
<dt>dump_peer_certificate()</dt>
<dd>
<p>Returns a parsable string with select fields from the peer SSL
certificate. This method directly returns the result of the
<strong>dump_peer_certificate()</strong> method of Net::SSLeay.</p>
</dd>
<dt>peer_certificate($field;[$refresh])</dt>
<dd>
<p>If a peer certificate exists, this function can retrieve values from
it. If no field is given the internal representation of certificate from
Net::SSLeay is returned. If refresh is true it will not used a cached
version, but check again in case the certificate of the connection has
changed due to renegotiation. The following fields can be queried:</p>
<dl>
<dt>authority (alias issuer)</dt>
<dd>
<p>The certificate authority which signed the certificate.</p>
</dd>
<dt>owner (alias subject)</dt>
<dd>
<p>The owner of the certificate.</p>
</dd>
<dt>commonName (alias cn) - only for Net::SSLeay version &gt;=1.30</dt>
<dd>
<p>The common name, usually the server name for SSL certificates.</p>
</dd>
<dt>subjectAltNames - only for Net::SSLeay version &gt;=1.33</dt>
<dd>
<p>Alternative names for the subject, usually different names for the
same server, like example.org, example.com, *.example.com. It returns a
list of (typ,value) with typ GEN_DNS, GEN_IPADD etc (these constants are
exported from IO::Socket::SSL). See
Net::SSLeay::X509_get_subjectAltNames.</p>
</dd>
</dl>
</dd>
<dt>sock_certificate($field)</dt>
<dd>
<p>This is similar to <code>peer_certificate</code> but will return the
sites own certificate. The same arguments for
<strong><code>$field</code></strong> can be used. If no
<strong><code>$field</code></strong> is given the certificate handle
from the underlying OpenSSL will be returned. This handle will only be
valid as long as the SSL connection exists and if used afterwards it
might result in strange crashes of the application.</p>
</dd>
<dt>peer_certificates</dt>
<dd>
<p>This returns all the certificates send by the peer, e.g. first the
peers own certificate and then the rest of the chain. You might use
<strong>CERT_asHash</strong> from IO::Socket::SSL::Utils to inspect each
of the certificates. This function depends on a version of Net::SSLeay
&gt;= 1.58 .</p>
</dd>
<dt>get_servername</dt>
<dd>
<p>This gives the name requested by the client if Server Name Indication
(SNI) was used.</p>
</dd>
<dt>verify_hostname($hostname,$scheme,$publicsuffix)</dt>
<dd>
<p>This verifies the given hostname against the peer certificate using
the given scheme. Hostname is usually what you specify within the
PeerAddr. See the <code>SSL_verifycn_publicsuffix</code> parameter for
an explanation of suffix checking and for the possible values.
Verification of hostname against a certificate is different between
various applications and RFCs. Some scheme allow wildcards for
hostnames, some only in subjectAltNames, and even their different
wildcard schemes are possible. RFC 6125 provides a good overview. To
ease the verification the following schemes are predefined (both
protocol name and rfcXXXX name can be used):</p>
<dl>
<dt>rfc2818, xmpp (rfc3920), ftp (rfc4217)</dt>
<dd>
<p>Extended wildcards in subjectAltNames and common name are possible,
e.g. *.example.org or even www*.example.org. The common name will be
only checked if no DNS names are given in subjectAltNames.</p>
</dd>
<dt>http (alias www)</dt>
<dd>
<p>While name checking is defined in rfc2818 the current browsers
usually accept also an IP address (w/o wildcards) within the common name
as long as no subjectAltNames are defined. Thus this is rfc2818 extended
with this feature.</p>
</dd>
<dt>smtp (rfc2595), imap, pop3, acap (rfc4642), netconf (rfc5538),
syslog (rfc5425), snmp (rfc5953)</dt>
<dd>
<p>Simple wildcards in subjectAltNames are possible, e.g. *.example.org
matches www.example.org but not lala.www.example.org. If nothing from
subjectAltNames match it checks against the common name, where wildcards
are also allowed to match the full leftmost label.</p>
</dd>
<dt>ldap (rfc4513)</dt>
<dd>
<p>Simple wildcards are allowed in subjectAltNames, but not in common
name. Common name will be checked even if subjectAltNames exist.</p>
</dd>
<dt>sip (rfc5922)</dt>
<dd>
<p>No wildcards are allowed and common name is checked even if
subjectAltNames exist.</p>
</dd>
<dt>gist (rfc5971)</dt>
<dd>
<p>Simple wildcards are allowed in subjectAltNames and common name, but
common name will only be checked if their are no DNS names in
subjectAltNames.</p>
</dd>
<dt>default</dt>
<dd>
<p>This is a superset of all the rules and is automatically used if no
scheme is given but a hostname (instead of IP) is known. Extended
wildcards are allowed in subjectAltNames and common name and common name
is checked always.</p>
</dd>
<dt>none</dt>
<dd>
<p>No verification will be done. Actually is does not make any sense to
call verify_hostname in this case.</p>
</dd>
</dl>
<p>The scheme can be given either by specifying the name for one of the
above predefined schemes, or by using a hash which can have the
following keys and values:</p>
<dl>
<dt>check_cn: 0|'always'|'when_only'</dt>
<dd>
<p>Determines if the common name gets checked. If 'always' it will
always be checked (like in ldap), if 'when_only' it will only be checked
if no names are given in subjectAltNames (like in http), for any other
values the common name will not be checked.</p>
</dd>
<dt>wildcards_in_alt: 0|'full_label'|'anywhere'</dt>
<dd>
<p>Determines if and where wildcards in subjectAltNames are possible. If
'full_label' only cases like *.example.org will be possible (like in
ldap), for 'anywhere' www*.example.org is possible too (like http),
dangerous things like but www.*.org or even '*' will not be allowed. For
compatibility with older versions 'leftmost' can be given instead of
'full_label'.</p>
</dd>
<dt>wildcards_in_cn: 0|'full_label'|'anywhere'</dt>
<dd>
<p>Similar to wildcards_in_alt, but checks the common name. There is no
predefined scheme which allows wildcards in common names.</p>
</dd>
<dt>ip_in_cn: 0|1|4|6</dt>
<dd>
<p>Determines if an IP address is allowed in the common name (no
wildcards are allowed). If set to 4 or 6 it only allows IPv4 or IPv6
addresses, any other true value allows both.</p>
</dd>
<dt>callback: \&amp;coderef</dt>
<dd>
<p>If you give a subroutine for verification it will be called with the
arguments ($hostname,$commonName,@subjectAltNames), where hostname is
the name given for verification, commonName is the result from
peer_certificate('cn') and subjectAltNames is the result from
peer_certificate('subjectAltNames'). All other arguments for the
verification scheme will be ignored in this case.</p>
</dd>
</dl>
</dd>
<dt>next_proto_negotiated()</dt>
<dd>
<p>This method returns the name of negotiated protocol - e.g.
'http/1.1'. It works for both client and server side of SSL connection.
NPN support is available with Net::SSLeay 1.46+ and openssl-1.0.1+. To
check support you might call
<code>IO::Socket::SSL-&gt;can_npn()</code>.</p>
</dd>
<dt>alpn_selected()</dt>
<dd>
<p>Returns the protocol negotiated via ALPN as a string, e.g.
'http/1.1', 'http/2.0' or 'spdy/3.1'. ALPN support is available with
Net::SSLeay 1.56+ and openssl-1.0.2+. To check support, use
<code>IO::Socket::SSL-&gt;can_alpn()</code>.</p>
</dd>
<dt>errstr()</dt>
<dd>
<p>Returns the last error (in string form) that occurred. If you do not
have a real object to perform this method on, call
<strong>IO::Socket::SSL::errstr()</strong> instead. For read and write
errors on non-blocking sockets, this method may include the string
<code>SSL wants a read first!</code> or
<code>SSL wants a write first!</code> meaning that the other side is
expecting to read from or write to the socket and wants to be satisfied
before you get to do anything. But with version 0.98 you are better
comparing the global exported variable <code>$SSL_ERROR</code> against
the exported symbols SSL_WANT_READ and SSL_WANT_WRITE.</p>
</dd>
<dt>opened()</dt>
<dd>
<p>This returns false if the socket could not be opened, 1 if the socket
could be opened and the SSL handshake was successful done and -1 if the
underlying IO::Handle is open, but the SSL handshake failed.</p>
</dd>
<dt>IO::Socket::SSL-&gt;start_SSL($socket, ... )</dt>
<dd>
<p>This will convert a glob reference or a socket that you provide to an
IO::Socket::SSL object. You may also pass parameters to specify context
or connection options as with a call to <strong>new()</strong>. If you
are using this function on an <strong>accept()</strong>ed socket, you
must set the parameter SSL_server to 1, i.e.
IO::Socket::SSL-&gt;start_SSL($socket, SSL_server =&gt; 1). If you have
a class that inherits from IO::Socket::SSL and you want the
<code>$socket</code> to be blessed into your own class instead, use
MyClass-&gt;start_SSL($socket) to achieve the desired effect. Note that
if <strong>start_SSL()</strong> fails in SSL negotiation,
<code>$socket</code> will remain blessed in its original class. For
non-blocking sockets you better just upgrade the socket to
IO::Socket::SSL and call accept_SSL or connect_SSL and the upgraded
object. To just upgrade the socket set
<strong>SSL_startHandshake</strong> explicitly to 0. If you call
start_SSL w/o this parameter it will revert to blocking behavior for
accept_SSL and connect_SSL. If given the parameter Timeout it will stop
if after the timeout no SSL connection was established. This parameter
is only used for blocking sockets, if it is not given the default
Timeout from the underlying IO::Socket will be used.</p>
</dd>
<dt>stop_SSL(...)</dt>
<dd>
<p>This is the opposite of <strong>start_SSL()</strong>,
<strong>connect_SSL()</strong> and <strong>accept_SSL()</strong>, e.g.
it will shutdown the SSL connection and return to the class before
<strong>start_SSL()</strong>. It gets the same arguments as
<strong>close()</strong>, in fact <strong>close()</strong> calls
<strong>stop_SSL()</strong> (but without downgrading the class). Will
return true if it succeeded and undef if failed. This might be the case
for non-blocking sockets. In this case $! is set to EWOULDBLOCK and the
ssl error to SSL_WANT_READ or SSL_WANT_WRITE. In this case the call
should be retried again with the same arguments once the socket is
ready. For calling from <code>stop_SSL</code>
<code>SSL_fast_shutdown</code> default to false, e.g. it waits for the
close_notify of the peer. This is necessary in case you want to
downgrade the socket and continue to use it as a plain socket. After
stop_SSL the socket can again be used to exchange plain data.</p>
</dd>
<dt>connect_SSL, accept_SSL</dt>
<dd>
<p>These functions should be used to do the relevant handshake, if the
socket got created with <code>new</code> or upgraded with
<code>start_SSL</code> and <code>SSL_startHandshake</code> was set to
false. They will return undef until the handshake succeeded or an error
got thrown. As long as the function returns undef and $! is set to
EWOULDBLOCK one could retry the call after the socket got readable
(SSL_WANT_READ) or writeable (SSL_WANT_WRITE).</p>
</dd>
<dt>set_msg_callback</dt>
<dd>
<p>This will add/remove a user defined callback for each message,
internally using openssl SSL_set_msg_callback API. To make sure that the
callback is active before the handshake starts, combine it with
<code>SSL_startHandshake =&gt; 0</code> in the preceding setup of the
SSL object. To remove callback explicitly call it with an empty callback
function. Example: $sock = IO::Socket::SSL-&gt;new( .... ,
SSL_startHandshake =&gt; 0); # set callback
$sock-&gt;set_msg_callback(\&amp;cb, $cbarg1, $cbarg2);
$sock-&gt;connect_SSL(); sub cb { my ($sock, # see SSL_set_msg_callback
for the following args $direction, $ssl_ver, $content_type, $buf, $len,
$ssl, $cbarg1, $cbarg2) = @_; ... if (no_longer_need_cb) { # disable
callback $sock-&gt;set_msg_callback(undef); } }</p>
</dd>
<dt>ocsp_resolver</dt>
<dd>
<p>This will create an OCSP resolver object, which can be used to create
OCSP requests for the certificates of the SSL connection. Which
certificates are verified depends on the setting of
<code>SSL_ocsp_mode</code>: by default only the leaf certificate will be
checked, but with SSL_OCSP_FULL_CHAIN all chain certificates will be
checked. Because to create an OCSP request the certificate and its
issuer certificate need to be known it is not possible to check
certificates when the trust chain is incomplete or if the certificate is
self-signed. The OCSP resolver gets created by calling
<code>$ssl-&gt;ocsp_resolver</code> and provides the following
methods:</p>
<dl>
<dt>hard_error</dt>
<dd>
<p>This returns the hard error when checking the OCSP response. Hard
errors are certificate revocations. With the <code>SSL_ocsp_mode</code>
of SSL_OCSP_FAIL_HARD any soft error (e.g. failures to get signed
information about the certificates) will be considered a hard error too.
The OCSP resolving will stop on the first hard error. The method will
return undef as long as no hard errors occurred and still requests to be
resolved. If all requests got resolved and no hard errors occurred the
method will return .</p>
</dd>
<dt>soft_error</dt>
<dd>
<p>This returns the soft error(s) which occurred when asking the OCSP
responders.</p>
</dd>
<dt>requests</dt>
<dd>
<p>This will return a hash consisting of
<code>(url,request)</code>-tuples, e.g. which contain the OCSP request
string and the URL where it should be sent too. The usual way to send
such a request is as HTTP POST request with a content-type of
<code>application/ocsp-request</code> or as a GET request with the
base64 and url-encoded request is added to the path of the URL. After
you've handled all these requests and added the response with
<code>add_response</code> you should better call this method again to
make sure, that no more requests are outstanding. IO::Socket::SSL will
combine multiple OCSP requests for the same server inside a single
request, but some server don't give a response to all these requests, so
that one has to ask again with the remaining requests.</p>
</dd>
<dt>add_response($uri,$response)</dt>
<dd>
<p>This method takes the HTTP body of the response which got received
when sending the OCSP request to <code>$uri</code>. If no response was
received or an error occurred one should either retry or consider
<code>$response</code> as empty which will trigger a soft error. The
method returns the current value of <code>hard_error</code>, e.g. a
defined value when no more requests need to be done.</p>
</dd>
<dt>resolve_blocking(%args)</dt>
<dd>
<p>This combines <code>requests</code> and <code>add_response</code>
which HTTP::Tiny to do all necessary requests in a blocking way.
<code>%args</code> will be given to HTTP::Tiny so that you can put proxy
settings etc here. HTTP::Tiny will be called with
<code>verify_SSL</code> of false, because the OCSP responses have their
own signatures so no extra SSL verification is needed. If you don't want
to use blocking requests you need to roll your own user agent with
<code>requests</code> and <code>add_response</code>.</p>
</dd>
</dl>
</dd>
<dt>IO::Socket::SSL-&gt;new_from_fd($fd, [mode], %sslargs)</dt>
<dd>
<p>This will convert a socket identified via a file descriptor into an
SSL socket. Note that the argument list does not include a MODE
argument; if you supply one, it will be thoughtfully ignored (for
compatibility with IO::Socket::INET). Instead, a mode of '+&lt;' is
assumed, and the file descriptor passed must be able to handle such I/O
because the initial SSL handshake requires bidirectional communication.
Internally the given <code>$fd</code> will be upgraded to a socket
object using the <code>new_from_fd</code> method of the super class
(IO::Socket::INET or similar) and then <code>start_SSL</code> will be
called using the given <code>%sslargs</code>. If <code>$fd</code> is
already an IO::Socket object you should better call
<code>start_SSL</code> directly.</p>
</dd>
<dt>IO::Socket::SSL::default_ca([ path|dir| SSL_ca_file = ...,
SSL_ca_path =&gt; ... ])&gt;</dt>
<dd>
<p>Determines or sets the default CA path. If existing path or dir or a
hash is given it will set the default CA path to this value and never
try to detect it automatically. If <code>undef</code> is given it will
forget any stored defaults and continue with detection of system
defaults. If no arguments are given it will start detection of system
defaults, unless it has already stored user-set or previously detected
values. The detection of system defaults works similar to OpenSSL, e.g.
it will check the directory specified in environment variable
SSL_CERT_DIR or the path OPENSSLDIR/certs (SSLCERTS: on VMS) and the
file specified in environment variable SSL_CERT_FILE or the path
OPENSSLDIR/cert.pem (SSLCERTS:cert.pem on VMS). Contrary to OpenSSL it
will check if the SSL_ca_path contains PEM files with the hash as file
name and if the SSL_ca_file looks like PEM. If no usable system default
can be found it will try to load and use Mozilla::CA and if not
available give up detection. The result of the detection will be saved
to speed up future calls. The function returns the saved default CA as
hash with SSL_ca_file and SSL_ca_path.</p>
</dd>
<dt>IO::Socket::SSL::set_default_context(...)</dt>
<dd>
<p>You may use this to make IO::Socket::SSL automatically re-use a given
context (unless specifically overridden in a call to
<strong>new()</strong>). It accepts one argument, which should be either
an IO::Socket::SSL object or an IO::Socket::SSL::SSL_Context object. See
the SSL_reuse_ctx option of <strong>new()</strong> for more details.
Note that this sets the default context globally, so use with caution
(esp. in mod_perl scripts).</p>
</dd>
<dt>IO::Socket::SSL::set_default_session_cache(...)</dt>
<dd>
<p>You may use this to make IO::Socket::SSL automatically re-use a given
session cache (unless specifically overridden in a call to
<strong>new()</strong>). It accepts one argument, which should be an
IO::Socket::SSL::Session_Cache object or similar (e.g. something which
implements get_session, add_session and del_session like
IO::Socket::SSL::Session_Cache does). See the SSL_session_cache option
of <strong>new()</strong> for more details. Note that this sets the
default cache globally, so use with caution.</p>
</dd>
<dt>IO::Socket::SSL::set_defaults(%args)</dt>
<dd>
<p>With this function one can set defaults for all SSL_* parameter used
for creation of the context, like the SSL_verify* parameter. Any SSL_*
parameter can be given or the following short versions:</p>
<dl>
<dt>mode - SSL_verify_mode</dt>
<dd>

</dd>
</dl>
<dl>
<dt>callback - SSL_verify_callback</dt>
<dd>

</dd>
<dt>scheme - SSL_verifycn_scheme</dt>
<dd>

</dd>
<dt>name - SSL_verifycn_name</dt>
<dd>

</dd>
</dl>
</dd>
<dt>IO::Socket::SSL::set_client_defaults(%args)</dt>
<dd>

</dd>
</dl>
<p>Similar to <code>set_defaults</code>, but only sets the defaults for
client mode.</p>
<dl>
<dt>IO::Socket::SSL::set_server_defaults(%args)</dt>
<dd>
<p>Similar to <code>set_defaults</code>, but only sets the defaults for
server mode.</p>
</dd>
<dt>IO::Socket::SSL::set_args_filter_hack(\&amp;code|'use_defaults')</dt>
<dd>
<p>Sometimes one has to use code which uses unwanted or invalid
arguments for SSL, typically disabling SSL verification or setting wrong
ciphers or SSL versions. With this hack it is possible to override these
settings and restore sanity. Example:
IO::Socket::SSL::set_args_filter_hack( sub { my ($is_server,$args) = @_;
if ( ! $is_server ) { # client settings - enable verification with
default CA # and fallback hostname verification etc delete @{$args}{qw(
SSL_verify_mode SSL_ca_file SSL_ca_path SSL_verifycn_scheme SSL_version
)}; # and add some fingerprints for known certs which are signed by #
unknown CAs or are self-signed $args-&gt;{SSL_fingerprint} = ... } });
With the short setting <code>set_args_filter_hack(use_defaults)</code>
it will prefer the default settings in all cases. These default settings
can be modified with <code>set_defaults</code>,
<code>set_client_defaults</code> and
<code>set_server_defaults</code>.</p>
</dd>
</dl>
<p>The following methods are unsupported (not to mention futile!) and
IO::Socket::SSL will emit a large <strong>CROAK()</strong> if you are
silly enough to use them:</p>
<dl>
<dt>truncate</dt>
<dd>

</dd>
</dl>
<dl>
<dt>stat</dt>
<dd>

</dd>
<dt>ungetc</dt>
<dd>

</dd>
<dt>setbuf</dt>
<dd>

</dd>
<dt>setvbuf</dt>
<dd>

</dd>
<dt>fdopen</dt>
<dd>

</dd>
<dt>send/recv</dt>
<dd>

</dd>
</dl>
<p>Note that <strong>send()</strong> and <strong>recv()</strong> cannot
be reliably trapped by a tied filehandle (such as that used by
IO::Socket::SSL) and so may send unencrypted data over the socket.
Object-oriented calls to these functions will fail, telling you to use
the print/printf/syswrite and read/sysread families instead.</p>
<h1>DEPRECATIONS</h1>
<p>The following functions are deprecated and are only retained for
compatibility:</p>
<dl>
<dt>context_init()</dt>
<dd>
<p>use the SSL_reuse_ctx option if you want to re-use a context</p>
</dd>
<dt>socketToSSL() and socket_to_SSL()</dt>
<dd>
<p>use IO::Socket::SSL-&gt;<strong>start_SSL()</strong> instead</p>
</dd>
<dt>kill_socket()</dt>
<dd>
<p>use <strong>close()</strong> instead</p>
</dd>
<dt>get_peer_certificate()</dt>
<dd>
<p>use the <strong>peer_certificate()</strong> function instead. Used to
return X509_Certificate with methods subject_name and issuer_name. Now
simply returns <code>$self</code> which has these methods (although
deprecated).</p>
</dd>
<dt>issuer_name()</dt>
<dd>
<p>use peer_certificate( 'issuer' ) instead</p>
</dd>
<dt>subject_name()</dt>
<dd>
<p>use peer_certificate( 'subject' ) instead</p>
</dd>
</dl>
<h1>EXAMPLES</h1>
<p>See the 'example' directory, the tests in 't' and also the tools in
'util'.</p>
<h1>BUGS</h1>
<p>If you use IO::Socket::SSL together with threads you should load it
(e.g. use or require) inside the main thread before creating any other
threads which use it. This way it is much faster because it will be
initialized only once. Also there are reports that it might crash the
other way.</p>
<p>Creating an IO::Socket::SSL object in one thread and closing it in
another thread will not work.</p>
<p>IO::Socket::SSL does not work together with
Storable::fd_retrieve/fd_store. See BUGS file for more information and
how to work around the problem.</p>
<p>Non-blocking and timeouts (which are based on non-blocking) are not
supported on Win32, because the underlying IO::Socket::INET does not
support non-blocking on this platform.</p>
<p>If you have a server and it looks like you have a memory leak you
might check the size of your session cache. Default for Net::SSLeay
seems to be 20480, see the example for SSL_create_ctx_callback for how
to limit it.</p>
<p>TLS 1.3 support regarding session reuse is incomplete.</p>
<h1>SEE ALSO</h1>
<p>IO::Socket::INET, IO::Socket::INET6, IO::Socket::IP, Net::SSLeay.</p>
<h1>THANKS</h1>
<p>Many thanks to all who added patches or reported bugs or helped
IO::Socket::SSL another way. Please keep reporting bugs and help with
patches, even if they just fix the documentation.</p>
<p>Special thanks to the team of Net::SSLeay for the good
cooperation.</p>
<h1>AUTHORS</h1>
<p>Steffen Ullrich, &lt;sullr at cpan.org&gt; is the current
maintainer.</p>
<p>Peter Behroozi, &lt;behrooz at fas.harvard.edu&gt; (Note the lack of
an i at the end of behrooz)</p>
<p>Marko Asplund, &lt;marko.asplund at kronodoc.fi&gt;, was the original
author of IO::Socket::SSL.</p>
<p>Patches incorporated from various people, see file Changes.</p>
<h1>COPYRIGHT</h1>
<p>The original versions of this module are Copyright (C) 1999-2002
Marko Asplund.</p>
<p>The rewrite of this module is Copyright (C) 2002-2005 Peter
Behroozi.</p>
<p>Versions 0.98 and newer are Copyright (C) 2006-2014 Steffen
Ullrich.</p>
<p>This module is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
