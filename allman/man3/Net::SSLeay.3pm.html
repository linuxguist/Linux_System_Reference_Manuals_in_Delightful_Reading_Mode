<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>Net::SSLeay - Perl bindings for OpenSSL and LibreSSL</p>
<h1>SYNOPSIS</h1>
<p>use Net::SSLeay qw(get_https post_https sslcat make_headers
make_form); ($page) = get_https(www.bacus.pt, 443, /); # Case 1 ($page,
$response, %reply_headers) = get_https(www.bacus.pt, 443, /, # Case 2
make_headers(User-Agent =&gt; Cryptozilla/5.0b1, Referer =&gt;
https://www.bacus.pt )); ($page, $result, %headers) = # Case 2b =
get_https(www.bacus.pt, 443, /protected.html, make_headers(Authorization
=&gt; Basic . MIME::Base64::encode("$user:$pass",)) ); ($page,
$response, %reply_headers) = post_https(www.bacus.pt, 443, /foo.cgi, , #
Case 3 make_form(OK =&gt; 1, name =&gt; Sampo )); $reply = sslcat($host,
$port, $request); # Case 4 ($reply, $err, $server_cert) = sslcat($host,
$port, $request); # Case 5 $Net::SSLeay::trace = 2; # 0=no debugging,
1=ciphers, 2=trace, 3=dump data Net::SSLeay::initialize(); # Initialize
ssl library once</p>
<h1>DESCRIPTION</h1>
<p>This module provides Perl bindings for libssl (an SSL/TLS API) and
libcrypto (a cryptography API).</p>
<h1>COMPATIBILITY</h1>
<p>Net::SSLeay supports the following libssl implementations:</p>
<ul>
<li><p>Any stable release of OpenSSL &lt;https://www.openssl.org&gt; in
the 0.9.8 - 3.0 branches, except for OpenSSL 0.9.8 - 0.9.8b.</p></li>
<li><p>Any stable release of LibreSSL &lt;https://www.libressl.org&gt;
in the 2.0 - 3.4 series, except for LibreSSL 3.2.2 and 3.2.3.</p></li>
</ul>
<p>Net::SSLeay may not function as expected with releases other than the
ones listed above due to libssl API incompatibilities, or, in the case
of LibreSSL, because of deviations from the libssl API.</p>
<p>Net::SSLeay is only as secure as the underlying libssl implementation
you use. Although Net::SSLeay maintains compatibility with old versions
of OpenSSL and LibreSSL, it is <strong>strongly recommended</strong>
that you use a version of OpenSSL or LibreSSL that is supported by the
OpenSSL/LibreSSL developers and/or your operating system vendor. Many
unsupported versions of OpenSSL and LibreSSL are known to contain severe
security vulnerabilities. Refer to the OpenSSL Release Strategy
&lt;https://www.openssl.org/policies/releasestrat.html&gt; and LibreSSL
Support Schedule &lt;https://www.libressl.org/releases.html&gt; for
information on which versions are currently supported.</p>
<p>The libssl API has changed significantly since OpenSSL 0.9.8:
hundreds of functions have been added, deprecated or removed in the
intervening versions. Although this documentation lists all of the
functions and constants that Net::SSLeay may expose, they will not be
available for use if they are missing from the underlying libssl
implementation. Refer to the compatibility notes in this documentation,
as well as the OpenSSL/LibreSSL manual pages, for information on which
OpenSSL/LibreSSL versions support each function or constant. At
run-time, you can check whether a function or constant is exposed before
calling it using the following convention:</p>
<p>if ( defined &amp;Net::SSLeay::libssl_function ) { #
libssl_function() (or SSL_libssl_function()) is available
Net::SSLeay::libssl_function(...); }</p>
<h1>OVERVIEW</h1>
<p>Net::SSLeay module basically comprise of:</p>
<ul>
<li><p>High level functions for accessing web servers (by using
HTTP/HTTPS)</p></li>
<li><p>Low level API (mostly mapped 1:1 to openssl's C
functions)</p></li>
<li><p>Convenience functions (related to low level API but with more
perl friendly interface)</p></li>
</ul>
<p>There is also a related module called Net::SSLeay::Handle included in
this distribution that you might want to use instead. It has its own pod
documentation.</p>
<h2>High level functions for accessing web servers</h2>
<p>This module offers some high level convenience functions for
accessing web pages on SSL servers (for symmetry, the same API is
offered for accessing http servers, too), an <code>sslcat()</code>
function for writing your own clients, and finally access to the SSL api
of the SSLeay/OpenSSL package so you can write servers or clients for
more complicated applications.</p>
<p>For high level functions it is most convenient to import them into
your main namespace as indicated in the synopsis.</p>
<p><em>Basic set of functions</em></p>
<ul>
<li><p>get_https</p></li>
<li><p>post_https</p></li>
<li><p>put_https</p></li>
<li><p>head_https</p></li>
<li><p>do_https</p></li>
<li><p>sslcat</p></li>
<li><p>https_cat</p></li>
<li><p>make_form</p></li>
<li><p>make_headers</p></li>
</ul>
<p><strong>Case 1 (in SYNOPSIS)</strong> demonstrates the typical
invocation of <strong>get_https()</strong> to fetch an HTML page from
secure server. The first argument provides the hostname or IP in dotted
decimal notation of the remote server to contact. The second argument is
the TCP port at the remote end (your own port is picked arbitrarily from
high numbered ports as usual for TCP). The third argument is the URL of
the page without the host name part. If in doubt consult the HTTP
specifications at &lt;http://www.w3c.org&gt;.</p>
<p><strong>Case 2 (in SYNOPSIS)</strong> demonstrates full fledged use
of <code>get_https()</code>. As can be seen, <code>get_https()</code>
parses the response and response headers and returns them as a list,
which can be captured in a hash for later reference. Also a fourth
argument to <code>get_https()</code> is used to insert some additional
headers in the request. <code>make_headers()</code> is a function that
will convert a list or hash to such headers. By default
<code>get_https()</code> supplies <code>Host</code> (to make virtual
hosting easy) and <code>Accept</code> (reportedly needed by IIS)
headers.</p>
<p><strong>Case 2b (in SYNOPSIS)</strong> demonstrates how to get a
password protected page. Refer to the HTTP protocol specifications for
further details (e.g. RFC-2617).</p>
<p><strong>Case 3 (in SYNOPSIS)</strong> invokes
<code>post_https()</code> to submit a HTML/CGI form to a secure server.
The first four arguments are equal to <code>get_https()</code> (note
that the empty string () is passed as header argument). The fifth
argument is the contents of the form formatted according to CGI
specification. Do not post UTF-8 data as content: use utf8::downgrade
first. In this case the helper function <code>make_https()</code> is
used to do the formatting, but you could pass any string.
<code>post_https()</code> automatically adds <code>Content-Type</code>
and <code>Content-Length</code> headers to the request.</p>
<p><strong>Case 4 (in SYNOPSIS)</strong> shows the fundamental
<code>sslcat()</code> function (inspired in spirit by the
<code>netcat</code> utility :-). It's your swiss army knife that allows
you to easily contact servers, send some data, and then get the
response. You are responsible for formatting the data and parsing the
response - <code>sslcat()</code> is just a transport.</p>
<p><strong>Case 5 (in SYNOPSIS)</strong> is a full invocation of
<code>sslcat()</code> which allows the return of errors as well as the
server (peer) certificate.</p>
<p>The <code>$trace</code> global variable can be used to control the
verbosity of the high level functions. Level 0 guarantees silence, level
1 (the default) only emits error messages.</p>
<p><em>Alternate versions of high-level API</em></p>
<ul>
<li><p>get_https3</p></li>
<li><p>post_https3</p></li>
<li><p>put_https3</p></li>
<li><p>get_https4</p></li>
<li><p>post_https4</p></li>
<li><p>put_https4</p></li>
</ul>
<p>The above mentioned functions actually return the response headers as
a list, which only gets converted to hash upon assignment (this
assignment looses information if the same header occurs twice, as may be
the case with cookies). There are also other variants of the functions
that return unprocessed headers and that return a reference to a
hash.</p>
<p>($page, $response, @headers) = get_https(www.bacus.pt, 443, /); for
($i = 0; $i &lt; $#headers; $i+=2) { print "$headers[$i] = " .
$headers[$i+1] . "\n"; } ($page, $response, $headers, $server_cert) =
get_https3(www.bacus.pt, 443, /); print "$headers\n"; ($page, $response,
$headers_ref) = get_https4(www.bacus.pt, 443, /); for $k (sort keys
%{$headers_ref}) { for $v (@{$$headers_ref{$k}}) { print "$k = $v\n"; }
}</p>
<p>All of the above code fragments accomplish the same thing: display
all values of all headers. The API functions ending in 3 return the
headers simply as a scalar string and it is up to the application to
split them up. The functions ending in 4 return a reference to a hash of
arrays (see perlref and perllol if you are not familiar with complex
perl data structures). To access a single value of such a header hash
you would do something like</p>
<p>print $$headers_ref{COOKIE}[0];</p>
<p>Variants 3 and 4 also allow you to discover the server certificate in
case you would like to store or display it, e.g.</p>
<p>($p, $resp, $hdrs, $server_cert) = get_https3(www.bacus.pt, 443, /);
if (!defined($server_cert) || ($server_cert == 0)) { warn "Subject Name:
undefined, Issuer Name: undefined"; } else { warn Subject Name: .
Net::SSLeay::X509_NAME_oneline(
Net::SSLeay::X509_get_subject_name($server_cert)) . Issuer Name: .
Net::SSLeay::X509_NAME_oneline(
Net::SSLeay::X509_get_issuer_name($server_cert)); }</p>
<p>Beware that this method only allows after the fact verification of
the certificate: by the time <code>get_https3()</code> has returned the
https request has already been sent to the server, whether you decide to
trust it or not. To do the verification correctly you must either employ
the OpenSSL certificate verification framework or use the lower level
API to first connect and verify the certificate and only then send the
http data. See the implementation of <code>ds_https3()</code> for
guidance on how to do this.</p>
<p><em>Using client certificates</em></p>
<p>Secure web communications are encrypted using symmetric crypto keys
exchanged using encryption based on the certificate of the server.
Therefore in all SSL connections the server must have a certificate.
This serves both to authenticate the server to the clients and to
perform the key exchange.</p>
<p>Sometimes it is necessary to authenticate the client as well. Two
options are available: HTTP basic authentication and a client side
certificate. The basic authentication over HTTPS is actually quite safe
because HTTPS guarantees that the password will not travel in the clear.
Never-the-less, problems like easily guessable passwords remain. The
client certificate method involves authentication of the client at the
SSL level using a certificate. For this to work, both the client and the
server have certificates (which typically are different) and private
keys.</p>
<p>The API functions outlined above accept additional arguments that
allow one to supply the client side certificate and key files. The
format of these files is the same as used for server certificates and
the caveat about encrypting private keys applies.</p>
<p>($page, $result, %headers) = # 2c = get_https(www.bacus.pt, 443,
/protected.html, make_headers(Authorization =&gt; Basic .
MIME::Base64::encode("$user:$pass",)), , $mime_type6, $path_to_crt7,
$path_to_key8); ($page, $response, %reply_headers) =
post_https(www.bacus.pt, 443, /foo.cgi, # 3b make_headers(Authorization
=&gt; Basic . MIME::Base64::encode("$user:$pass",)), make_form(OK =&gt;
1, name =&gt; Sampo), $mime_type6, $path_to_crt7, $path_to_key8);</p>
<p><strong>Case 2c (in SYNOPSIS)</strong> demonstrates getting a
password protected page that also requires a client certificate, i.e. it
is possible to use both authentication methods simultaneously.</p>
<p><strong>Case 3b (in SYNOPSIS)</strong> is a full blown POST to a
secure server that requires both password authentication and a client
certificate, just like in case 2c.</p>
<p>Note: The client will not send a certificate unless the server
requests one. This is typically achieved by setting the verify mode to
<code>VERIFY_PEER</code> on the server:</p>
<p>Net::SSLeay::set_verify(ssl, Net::SSLeay::VERIFY_PEER, 0);</p>
<p>See <code>perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod</code> for
a full description.</p>
<p><em>Working through a web proxy</em></p>
<ul>
<li><p>set_proxy</p></li>
</ul>
<p><code>Net::SSLeay</code> can use a web proxy to make its connections.
You need to first set the proxy host and port using
<code>set_proxy()</code> and then just use the normal API functions,
e.g:</p>
<p>Net::SSLeay::set_proxy(gateway.myorg.com, 8080); ($page) =
get_https(www.bacus.pt, 443, /);</p>
<p>If your proxy requires authentication, you can supply a username and
password as well</p>
<p>Net::SSLeay::set_proxy(gateway.myorg.com, 8080, joe, salainen);
($page, $result, %headers) = = get_https(www.bacus.pt, 443,
/protected.html, make_headers(Authorization =&gt; Basic .
MIME::Base64::encode("susie:pass",)) );</p>
<p>This example demonstrates the case where we authenticate to the proxy
as <code>"joe"</code> and to the final web server as
<code>"susie"</code>. Proxy authentication requires the
<code>MIME::Base64</code> module to work.</p>
<p><em>HTTP (without S) API</em></p>
<ul>
<li><p>get_http</p></li>
<li><p>post_http</p></li>
<li><p>tcpcat</p></li>
<li><p>get_httpx</p></li>
<li><p>post_httpx</p></li>
<li><p>tcpxcat</p></li>
</ul>
<p>Over the years it has become clear that it would be convenient to use
the light-weight flavour API of <code>Net::SSLeay</code> for normal HTTP
as well (see <code>LWP</code> for the heavy-weight object-oriented
approach). In fact it would be nice to be able to flip https on and off
on the fly. Thus regular HTTP support was evolved.</p>
<p>use Net::SSLeay qw(get_http post_http tcpcat get_httpx post_httpx
tcpxcat make_headers make_form); ($page, $result, %headers) =
get_http(www.bacus.pt, 443, /protected.html, make_headers(Authorization
=&gt; Basic . MIME::Base64::encode("$user:$pass",)) ); ($page,
$response, %reply_headers) = post_http(www.bacus.pt, 443, /foo.cgi, ,
make_form(OK =&gt; 1, name =&gt; Sampo )); ($reply, $err) =
tcpcat($host, $port, $request); ($page, $result, %headers) =
get_httpx($usessl, www.bacus.pt, 443, /protected.html,
make_headers(Authorization =&gt; Basic .
MIME::Base64::encode("$user:$pass",)) ); ($page, $response,
%reply_headers) = post_httpx($usessl, www.bacus.pt, 443, /foo.cgi, ,
make_form(OK =&gt; 1, name =&gt; Sampo )); ($reply, $err, $server_cert)
= tcpxcat($usessl, $host, $port, $request);</p>
<p>As can be seen, the <code>"x"</code> family of APIs takes as the
first argument a flag which indicates whether SSL is used or not.</p>
<h2>Certificate verification and Certificate Revocation Lists
(CRLs)</h2>
<p>OpenSSL supports the ability to verify peer certificates. It can also
optionally check the peer certificate against a Certificate Revocation
List (CRL) from the certificates issuer. A CRL is a file, created by the
certificate issuer that lists all the certificates that it previously
signed, but which it now revokes. CRLs are in PEM format.</p>
<p>You can enable <code>Net::SSLeay CRL</code> checking like this:</p>
<p>&amp;Net::SSLeay::X509_STORE_set_flags
(&amp;Net::SSLeay::CTX_get_cert_store($ssl),
&amp;Net::SSLeay::X509_V_FLAG_CRL_CHECK);</p>
<p>After setting this flag, if OpenSSL checks a peer's certificate, then
it will attempt to find a CRL for the issuer. It does this by looking
for a specially named file in the search directory specified by
CTX_load_verify_locations. CRL files are named with the hash of the
issuer's subject name, followed by <code>.r0</code>, <code>.r1</code>
etc. For example <code>ab1331b2.r0</code>, <code>ab1331b2.r1</code>. It
will read all the .r files for the issuer, and then check for a
revocation of the peer certificate in all of them. (You can also force
it to look in a specific named CRL file., see below). You can find out
the hash of the issuer subject name in a CRL with</p>
<p>openssl crl -in crl.pem -hash -noout</p>
<p>If the peer certificate does not pass the revocation list, or if no
CRL is found, then the handshaking fails with an error.</p>
<p>You can also force OpenSSL to look for CRLs in one or more
arbitrarily named files.</p>
<p>my $bio = Net::SSLeay::BIO_new_file($crlfilename, r); my $crl =
Net::SSLeay::PEM_read_bio_X509_CRL($bio); if ($crl) {
Net::SSLeay::X509_STORE_add_crl( Net::SSLeay::CTX_get_cert_store($ssl,
$crl) ); } else { error reading CRL.... }</p>
<p>Usually the URLs where you can download the CRLs is contained in the
certificate itself and you can extract them with</p>
<p>my @url = Net::SSLeay::P_X509_get_crl_distribution_points($cert)</p>
<p>But there is no automatic downloading of the CRLs and often these
CRLs are too huge to just download them to verify a single certificate.
Also, these CRLs are often in DER format which you need to convert to
PEM before you can use it:</p>
<p>openssl crl -in crl.der -inform der -out crl.pem</p>
<p>So as an alternative for faster and timely revocation checks you
better use the Online Status Revocation Protocol (OCSP).</p>
<h2>Certificate verification and Online Status Revocation Protocol
(OCSP)</h2>
<p>While checking for revoked certificates is possible and fast with
Certificate Revocation Lists, you need to download the complete and
often huge list before you can verify a single certificate.</p>
<p>A faster way is to ask the CA to check the revocation of just a
single or a few certificates using OCSP. Basically you generate for each
certificate an OCSP_CERTID based on the certificate itself and its
issuer, put the ids togetether into an OCSP_REQUEST and send the request
to the URL given in the certificate.</p>
<p>As a result you get back an OCSP_RESPONSE and need to check the
status of the response, check that it is valid (e.g. signed by the CA)
and finally extract the information about each OCSP_CERTID to find out
if the certificate is still valid or got revoked.</p>
<p>With Net::SSLeay this can be done like this:</p>
<p># get id(s) for given certs, like from get_peer_certificate # or
get_peer_cert_chain. This will croak if # - one tries to make an
OCSP_CERTID for a self-signed certificate # - the issuer of the
certificate cannot be found in the SSL objects # store, nor in the
current certificate chain my $cert =
Net::SSLeay::get_peer_certificate($ssl); my $id = eval {
Net::SSLeay::OCSP_cert2ids($ssl,$cert) }; die "failed to make
OCSP_CERTID: $@" if $@; # create OCSP_REQUEST from id(s) # Multiple can
be put into the same request, if the same OCSP responder # is
responsible for them. my $req = Net::SSLeay::OCSP_ids2req($id); #
determine URI of OCSP responder my $uri =
Net::SSLeay::P_X509_get_ocsp_uri($cert); # Send stringified OCSP_REQUEST
with POST to $uri. # We can ignore certificate verification for https,
because the OCSP # response itself is signed. my $ua =
HTTP::Tiny-&gt;new(verify_SSL =&gt; 0); my $res = $ua-&gt;request(
POST,$uri, { headers =&gt; { Content-type =&gt; application/ocsp-request
}, content =&gt; Net::SSLeay::i2d_OCSP_REQUEST($req) }); my $content =
$res &amp;&amp; $res-&gt;{success} &amp;&amp; $res-&gt;{content} or die
"query failed"; # Extract OCSP_RESPONSE. # this will croak if the string
is not an OCSP_RESPONSE my $resp = eval {
Net::SSLeay::d2i_OCSP_RESPONSE($content) }; # Check status of response.
my $status = Net::SSLeay::OCSP_response_status($resp); if ($status !=
Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) die "OCSP response
failed: ". Net::SSLeay::OCSP_response_status_str($status); } # Verify
signature of response and if nonce matches request. # This will croak if
there is a nonce in the response, but it does not match # the request.
It will return false if the signature could not be verified, # in which
case details can be retrieved with Net::SSLeay::ERR_get_error. # It will
not complain if the response does not contain a nonce, which is #
usually the case with pre-signed responses. if ( ! eval {
Net::SSLeay::OCSP_response_verify($ssl,$resp,$req) }) { die "OCSP
response verification failed"; } # Extract information from
OCSP_RESPONSE for each of the ids. # If called in scalar context it will
return the time (as time_t), when the # next update is due (minimum of
all successful responses inside $resp). It # will croak on the following
problems: # - response is expired or not yet valid # - no response for
given OCSP_CERTID # - certificate status is not good (e.g. revoked or
unknown) if ( my $nextupd = eval {
Net::SSLeay::OCSP_response_results($resp,$id) }) { warn "certificate is
valid, next update in ". ($nextupd-time())." seconds\n"; } else { die
"certificate is not valid: $@"; } # But in array context it will return
detailed information about each given # OCSP_CERTID instead croaking on
errors: # if no @ids are given it will return information about all
single responses # in the OCSP_RESPONSE my @results =
Net::SSLeay::OCSP_response_results($resp,@ids); for my $r (@results) {
print Dumper($r); # @results are in the same order as the @ids and
contain: # $r-&gt;[0] - OCSP_CERTID # $r-&gt;[1] - undef if no error
(certificate good) OR error message as string # $r-&gt;[2] - hash with
details: # thisUpdate - time_t of this single response # nextUpdate -
time_t when update is expected # statusType - integer: #
V_OCSP_CERTSTATUS_GOOD(0) # V_OCSP_CERTSTATUS_REVOKED(1) #
V_OCSP_CERTSTATUS_UNKNOWN(2) # revocationTime - time_t (only if revoked)
# revocationReason - integer (only if revoked) # revocationReason_str -
reason as string (only if revoked) }</p>
<p>To further speed up certificate revocation checking one can use a TLS
extension to instruct the server to staple the OCSP response:</p>
<p># set TLS extension before doing SSL_connect
Net::SSLeay::set_tlsext_status_type($ssl,
Net::SSLeay::TLSEXT_STATUSTYPE_ocsp()); # setup callback to verify OCSP
response my $cert_valid = undef;
Net::SSLeay::CTX_set_tlsext_status_cb($context,sub { my ($ssl,$resp) =
@_; if (!$resp) { # Lots of servers dont return an OCSP response. # In
this case we must check the OCSP status outside the SSL # handshake.
warn "server did not return stapled OCSP response\n"; return 1; } #
verify status my $status = Net::SSLeay::OCSP_response_status($resp); if
($status != Net::SSLeay::OCSP_RESPONSE_STATUS_SUCCESSFUL()) { warn "OCSP
response failure: $status\n"; return 1; } # verify signature - we have
no OCSP_REQUEST here to check nonce if (!eval {
Net::SSLeay::OCSP_response_verify($ssl,$resp) }) { warn "OCSP response
verify failed\n"; return 1; } # check if the certificate is valid # we
should check here against the peer_certificate my $cert =
Net::SSLeay::get_peer_certificate(); my $certid = eval {
Net::SSLeay::OCSP_cert2ids($ssl,$cert) } or do { warn "cannot get certid
from cert: $@"; $cert_valid = -1; return 1; }; if ( $nextupd = eval {
Net::SSLeay::OCSP_response_results($resp,$certid) }) { warn "certificate
not revoked\n"; $cert_valid = 1; } else { warn "certificate not valid:
$@"; $cert_valid = 0; } }); # do SSL handshake here .... # check if
certificate revocation was checked already if ( ! defined $cert_valid) {
# check revocation outside of SSL handshake by asking OCSP responder ...
} elsif ( ! $cert_valid ) { die "certificate not valid - closing SSL
connection"; } elsif ( $cert_valid&lt;0 ) { die "cannot verify
certificate revocation - self-signed ?"; } else { # everything fine ...
}</p>
<h2>Using Net::SSLeay in multi-threaded applications</h2>
<p><strong>IMPORTANT: versions 1.42 or earlier are not
thread-safe!</strong></p>
<p>Net::SSLeay module implements all necessary stuff to be ready for
multi-threaded environment - it requires openssl-0.9.7 or newer. The
implementation fully follows thread safety related requirements of
openssl library(see
&lt;http://www.openssl.org/docs/crypto/threads.html&gt;).</p>
<p>If you are about to use Net::SSLeay (or any other module based on
Net::SSLeay) in multi-threaded perl application it is recommended to
follow this best-practice:</p>
<p><em>Initialization</em></p>
<p>Load and initialize Net::SSLeay module in the main thread:</p>
<p>use threads; use Net::SSLeay; Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize(); sub
do_master_job { #... call whatever from Net::SSLeay } sub do_worker_job
{ #... call whatever from Net::SSLeay } #start threads my $master =
threads-&gt;new(\&amp;do_master_job, param1, param2); my @workers =
threads-&gt;new(\&amp;do_worker_job, arg1, arg2) for (1..10); #waiting
for all threads to finish $_-&gt;join() for (threads-&gt;list);</p>
<p>NOTE: Openssl's <code>int SSL_library_init(void)</code> function
(which is also aliased as <code>SSLeay_add_ssl_algorithms</code>,
<code>OpenSSL_add_ssl_algorithms</code> and
<code>add_ssl_algorithms</code>) is not re-entrant and multiple calls
can cause a crash in threaded application. Net::SSLeay implements flags
preventing repeated calls to this function, therefore even multiple
initialization via
<strong>Net::SSLeay::SSLeay_add_ssl_algorithms()</strong> should work
without trouble.</p>
<p><em>Using callbacks</em></p>
<p>Do not use callbacks across threads (the module blocks cross-thread
callback operations and throws a warning). Always do the callback setup,
callback use and callback destruction within the same thread.</p>
<p><em>Using openssl elements</em></p>
<p>All openssl elements (X509, SSL_CTX, ...) can be directly passed
between threads.</p>
<p>use threads; use Net::SSLeay; Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize(); sub
do_job { my $context = shift;
Net::SSLeay::CTX_set_default_passwd_cb($context, sub { "secret" }); #...
} my $c = Net::SSLeay::CTX_new(); threads-&gt;create(\&amp;do_job,
$c);</p>
<p>Or:</p>
<p>use threads; use Net::SSLeay; my $context; #does not need to be
shared Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize(); sub
do_job { Net::SSLeay::CTX_set_default_passwd_cb($context, sub { "secret"
}); #... } $context = Net::SSLeay::CTX_new();
threads-&gt;create(\&amp;do_job);</p>
<p><em>Using other perl modules based on Net::SSLeay</em></p>
<p>It should be fine to use any other module based on Net::SSLeay (like
IO::Socket::SSL) in multi-threaded applications. It is generally
recommended to do any global initialization of such a module in the main
thread before calling <code>threads-&gt;new(..)</code> or
<code>threads-&gt;create(..)</code> but it might differ module by
module.</p>
<p>To be safe you can load and init Net::SSLeay explicitly in the main
thread:</p>
<p>use Net::SSLeay; use Other::SSLeay::Based::Module;
Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();</p>
<p>Or even safer:</p>
<p>use Net::SSLeay; use Other::SSLeay::Based::Module; BEGIN {
Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();
}</p>
<p><em>Combining Net::SSLeay with other modules linked with
openssl</em></p>
<p><strong>BEWARE: This might be a big trouble! This is not guaranteed
be thread-safe!</strong></p>
<p>There are many other (XS) modules linked directly to openssl library
(like Crypt::SSLeay).</p>
<p>As it is expected that also another module will call
<code>SSLeay_add_ssl_algorithms</code> at some point we have again a
trouble with multiple openssl initialization by Net::SSLeay and another
module.</p>
<p>As you can expect Net::SSLeay is not able to avoid multiple
initialization of openssl library called by another module, thus you
have to handle this on your own (in some cases it might not be possible
at all to avoid this).</p>
<p><em>Threading with get_https and friends</em></p>
<p>The convenience functions get_https, post_https etc all initialize
the SSL library by calling Net::SSLeay::initialize which does the
conventional library initialization:</p>
<p>Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();</p>
<p>Net::SSLeay::initialize initializes the SSL library at most once. You
can override the Net::SSLeay::initialize function if you desire some
other type of initialization behaviour by get_https and friends. You can
call Net::SSLeay::initialize from your own code if you desire this
conventional library initialization.</p>
<h2>Convenience routines</h2>
<p>To be used with Low level API</p>
<p>Net::SSLeay::randomize($rn_seed_file,$additional_seed);
Net::SSLeay::set_cert_and_key($ctx, $cert_path, $key_path); $cert =
Net::SSLeay::dump_peer_certificate($ssl);
Net::SSLeay::ssl_write_all($ssl, $message) or die "ssl write failure";
$got = Net::SSLeay::ssl_read_all($ssl) or die "ssl read failure"; $got =
Net::SSLeay::ssl_read_CRLF($ssl [, $max_length]); $got =
Net::SSLeay::ssl_read_until($ssl [, $delimit [, $max_length]]);
Net::SSLeay::ssl_write_CRLF($ssl, $message);</p>
<ul>
<li><p>randomize seeds the openssl PRNG with <code>/dev/urandom</code>
(see the top of <code>SSLeay.pm</code> for how to change or configure
this) and optionally with user provided data. It is very important to
properly seed your random numbers, so do not forget to call this. The
high level API functions automatically call <code>randomize()</code> so
it is not needed with them. See also caveats.</p></li>
<li><p>set_cert_and_key takes two file names as arguments and sets the
certificate and private key to those. This can be used to set either
server certificates or client certificates.</p></li>
<li><p>dump_peer_certificate allows you to get a plaintext description
of the certificate the peer (usually the server) presented to
us.</p></li>
<li><p>ssl_read_all see ssl_write_all (below)</p></li>
<li><p>ssl_write_all <code>ssl_read_all()</code> and
<code>ssl_write_all()</code> provide true blocking semantics for these
operations (see limitation, below, for explanation). These are much
preferred to the low level API equivalents (which implement BSD blocking
semantics). The message argument to <code>ssl_write_all()</code> can be
a reference. This is helpful to avoid unnecessary copying when writing
something big, e.g: $data = A x 1000000000;
Net::SSLeay::ssl_write_all($ssl, \$data) or die "ssl write
failed";</p></li>
<li><p>ssl_read_CRLF uses <code>ssl_read_all()</code> to read in a line
terminated with a carriage return followed by a linefeed (CRLF). The
CRLF is included in the returned scalar.</p></li>
<li><p>ssl_read_until uses <code>ssl_read_all()</code> to read from the
SSL input stream until it encounters a programmer specified delimiter.
If the delimiter is undefined, <code>$/</code> is used. If
<code>$/</code> is undefined, <code>\n</code> is used. One can
optionally set a maximum length of bytes to read from the SSL input
stream.</p></li>
<li><p>ssl_write_CRLF writes <code>$message</code> and appends CRLF to
the SSL output stream.</p></li>
</ul>
<h2>Initialization</h2>
<p>In order to use the low level API you should start your programs with
the following incantation:</p>
<p>use Net::SSLeay qw(die_now die_if_ssl_error);
Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); # Important!
Net::SSLeay::ENGINE_load_builtin_engines(); # If you want built-in
engines Net::SSLeay::ENGINE_register_all_complete(); # If you want
built-in engines Net::SSLeay::randomize();</p>
<h2>Error handling functions</h2>
<p>I can not emphasize the need to check for error enough. Use these
functions even in the most simple programs, they will reduce debugging
time greatly. Do not ask questions on the mailing list without having
first sprinkled these in your code.</p>
<ul>
<li><p>die_now</p></li>
<li><p>die_if_ssl_error <code>die_now()</code> and
<code>die_if_ssl_error()</code> are used to conveniently print the
SSLeay error stack when something goes wrong: Net::SSLeay::connect($ssl)
or die_now("Failed SSL connect ($!)"); Net::SSLeay::write($ssl, "foo")
or die_if_ssl_error("SSL write ($!)");</p></li>
<li><p>print_errs You can also use
<code>Net::SSLeay::print_errs()</code> to dump the error stack without
exiting the program. As can be seen, your code becomes much more
readable if you import the error reporting functions into your main name
space.</p></li>
</ul>
<h2>Sockets</h2>
<p>Perl uses file handles for all I/O. While SSLeay has a quite flexible
BIO mechanism and perl has an evolved PerlIO mechanism, this module
still sticks to using file descriptors. Thus to attach SSLeay to a
socket you should use <code>fileno()</code> to extract the underlying
file descriptor:</p>
<p>Net::SSLeay::set_fd($ssl, fileno(S)); # Must use fileno</p>
<p>You should also set <code>$|</code> to 1 to eliminate STDIO buffering
so you do not get confused if you use perl I/O functions to manipulate
your socket handle.</p>
<p>If you need to <code>select(2)</code> on the socket, go right ahead,
but be warned that OpenSSL does some internal buffering so SSL_read does
not always return data even if the socket selected for reading (just
keep on selecting and trying to read). <code>Net::SSLeay</code> is no
different from the C language OpenSSL in this respect.</p>
<h2>Callbacks</h2>
<p>You can establish a per-context verify callback function something
like this:</p>
<p>sub verify { my ($ok, $x509_store_ctx) = @_; print "Verifying
certificate...\n"; ... return $ok; }</p>
<p>It is used like this:</p>
<p>Net::SSLeay::set_verify ($ssl, Net::SSLeay::VERIFY_PEER,
\&amp;verify);</p>
<p>Per-context callbacks for decrypting private keys are
implemented.</p>
<p>Net::SSLeay::CTX_set_default_passwd_cb($ctx, sub { "top-secret" });
Net::SSLeay::CTX_use_PrivateKey_file($ctx, "key.pem",
Net::SSLeay::FILETYPE_PEM) or die "Error reading private key";
Net::SSLeay::CTX_set_default_passwd_cb($ctx, undef);</p>
<p>If Hello Extensions are supported by your OpenSSL, a session secret
callback can be set up to be called when a session secret is set by
openssl.</p>
<p>Establish it like this:</p>
<p>Net::SSLeay::set_session_secret_cb($ssl, \&amp;session_secret_cb,
$somedata);</p>
<p>It will be called like this:</p>
<p>sub session_secret_cb { my ($secret, \@cipherlist, \$preferredcipher,
$somedata) = @_; }</p>
<p>No other callbacks are implemented. You do not need to use any
callback for simple (i.e. normal) cases where the SSLeay built-in verify
mechanism satisfies your needs.</p>
<p>It is required to reset these callbacks to undef immediately after
use to prevent memory leaks, thread safety problems and crashes on exit
that can occur if different threads set different callbacks.</p>
<p>If you want to use callback stuff, see examples/callback.pl! It's the
only one I am able to make work reliably.</p>
<h2>Low level API</h2>
<p>In addition to the high level functions outlined above, this module
contains straight-forward access to CRYPTO and SSL parts of OpenSSL C
API.</p>
<p>See the <code>*.h</code> headers from OpenSSL C distribution for a
list of low level SSLeay functions to call (check SSLeay.xs to see if
some function has been implemented). The module strips the initial
<code>"SSL_"</code> off of the SSLeay names. Generally you should use
<code>Net::SSLeay::</code> in its place.</p>
<p>Note that some functions are prefixed with <code>"P_"</code> - these
are very close to the original API however contain some kind of a
wrapper making its interface more perl friendly.</p>
<p>For example:</p>
<p>In C:</p>
<p>#include &lt;ssl.h&gt; err = SSL_set_verify (ssl,
SSL_VERIFY_CLIENT_ONCE, &amp;your_call_back_here);</p>
<p>In Perl:</p>
<p>use Net::SSLeay; $err = Net::SSLeay::set_verify ($ssl,
Net::SSLeay::VERIFY_CLIENT_ONCE, \&amp;your_call_back_here);</p>
<p>If the function does not start with <code>SSL_</code> you should use
the full function name, e.g.:</p>
<p>$err = Net::SSLeay::ERR_get_error;</p>
<p>The following new functions behave in perlish way:</p>
<p>$got = Net::SSLeay::read($ssl); # Performs SSL_read, but returns $got
# resized according to data received. # Returns undef on failure.
Net::SSLeay::write($ssl, $foo) || die; # Performs SSL_write, but
automatically # figures out the size of $foo</p>
<p><em>Low level API: Version and library information related
functions</em></p>
<ul>
<li><p>OpenSSL_version_num and SSLeay <strong>COMPATIBILITY:</strong>
<strong>SSLeay()</strong> is not available in Net-SSLeay-1.42 and
before. <strong>SSLeay()</strong> was made an alias of
<strong>OpenSSL_version_num()</strong> in OpenSSL 1.1.0 and LibreSSL
2.7.0. <strong>COMPATIBILITY:</strong>
<strong>OpenSSL_version_num()</strong> requires at least Net-SSLeay-1.82
with OpenSSL 1.1.0, or Net-SSLeay-1.88 with LibreSSL 2.7.0. Both
functions return OPENSSL_VERSION_NUMBER constant (numeric) as defined by
the underlying OpenSSL or LibreSSL library. my $ver_number =
Net::SSLeay::SSLeay(); or my $ver_number =
Net::SSLeay::OpenSSL_version_num(); # returns: OPENSSL_VERSION_NUMBER
constant OpenSSL version numbering is: # 0x00903100 =&gt; openssl-0.9.3
# 0x00904100 =&gt; openssl-0.9.4 # 0x00905100 =&gt; openssl-0.9.5 #
0x0090600f =&gt; openssl-0.9.6 # 0x0090601f =&gt; openssl-0.9.6a # ... #
0x009060df =&gt; openssl-0.9.6m # 0x0090700f =&gt; openssl-0.9.7 #
0x0090701f =&gt; openssl-0.9.7a # ... # 0x009070df =&gt; openssl-0.9.7m
# 0x0090800f =&gt; openssl-0.9.8 # 0x0090801f =&gt; openssl-0.9.8a # ...
# 0x0090821f =&gt; openssl-0.9.8zh # 0x1000000f =&gt; openssl-1.0.0 #
... # 0x1000014f =&gt; openssl-1.0.0t # 0x1000100f =&gt; openssl-1.0.1 #
... # 0x1000115f =&gt; openssl-1.0.1u # 0x1000200f =&gt; openssl-1.0.2 #
... # 0x1000215f =&gt; openssl-1.0.2u # 0x1010000f =&gt; openssl-1.1.0 #
... # 0x101000cf =&gt; openssl-1.1.0l # 0x1010100f =&gt; openssl-1.1.1 #
... # 0x101010df =&gt; openssl-1.1.1m # 0x30000000 =&gt; openssl-3.0.0 #
0x30000010 =&gt; openssl-3.0.1 Note that OpenSSL 3.0.0 and later do not
set the status nibble in the least significant octet to f. LibreSSL
returns 0x20000000 always: # 0x20000000 =&gt; libressl-2.2.1 # ... #
0x20000000 =&gt; libressl-3.4.2 You can use the version number like this
when you know that the underlying library is OpenSSL: if
(Net::SSLeay::SSLeay() &lt; 0x0090800f) { die "You need OpenSSL 0.9.8 or
higher"; } LibresSSL 2.2.2 and later define constant
LIBRESSL_VERSION_NUMBER that gives the LibreSSL version number. The
format is the same that OpenSSL uses with OPENSSL_VERSION_NUMBER. You
can do this if you need to check that the underlying library is LibreSSL
and it's recent enough: if (Net::SSLeay::SSLeay() != 0x20000000 ||
Net::SSLeay::LIBRESSL_VERSION_NUMBER() &lt; 0x3040200f) { die "You need
LibreSSL. Version 3.4.2 or higher"; } Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OpenSSL_version_num.html&gt;
See OpenSSL 1.1.1 and earlier documentation for the details of status
nibble and the format interpretation.</p></li>
<li><p>SSLeay_version <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before Returns different strings depending on
<code>$type</code>. my $ver_string = Net::SSLeay::SSLeay_version($type);
# $type # SSLEAY_VERSION - e.g. OpenSSL 1.0.0d 8 Feb 2011 #
SSLEAY_CFLAGS - e.g. compiler: gcc -D_WINDLL -DOPENSSL_USE_APPLINK .....
# SSLEAY_BUILT_ON - e.g. built on: Fri May 6 00:00:46 GMT 2011 #
SSLEAY_PLATFORM - e.g. platform: mingw # SSLEAY_DIR - e.g. OPENSSLDIR:
"z:/...." # # returns: string Net::SSLeay::SSLeay_version(); #is
equivalent to Net::SSLeay::SSLeay_version(SSLEAY_VERSION); OpenSSL 1.1.0
changed <strong>SSLeay_version()</strong> to an alias of
<strong>OpenSSL_version()</strong>. To ensure correct functionality with
LibreSSL, use SSLEAY_* constants with <strong>SSLeay_version()</strong>
and OPENSSL_* constants with <strong>OpenSSL_version()</strong>. Check
openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html&gt;
OpenSSL website no longer has a manual page for
<strong>SSLeay_version()</strong>.</p></li>
<li><p>OpenSSL_version <strong>COMPATIBILITY:</strong> requires at least
Net-SSLeay-1.82 with OpenSSL 1.1.0, or Net-SSLeay-1.88 with LibreSSL
2.7.0. Returns different strings depending on <code>$t</code>. Available
<code>$t</code> constants depend on the library version. my $ver_string
= Net::SSLeay::OpenSSL_version($t); # $t # OPENSSL_VERSION - e.g.
OpenSSL 1.1.0g 2 Nov 2017 # OPENSSL_CFLAGS - e.g. compiler: cc
-DDSO_DLFCN -DHAVE_DLFCN_H ..... # OPENSSL_BUILT_ON - e.g. built on:
reproducible build, date unspecified # OPENSSL_PLATFORM - e.g. platform:
darwin64-x86_64-cc # OPENSSL_DIR - e.g. OPENSSLDIR:
"/opt/openssl-1.1.0g" # OPENSSL_ENGINES_DIR - e.g. ENGINESDIR:
"/opt/openssl-1.1.0g/lib/engines-1.1" # # returns: string
Net::SSLeay::OpenSSL_version(); #is equivalent to
Net::SSLeay::OpenSSL_version(OPENSSL_VERSION); Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OpenSSL_version.html&gt;</p></li>
<li><p>OPENSSL_info <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1
Returns different strings depending on <code>$t</code>. Available
<code>$t</code> constants depend on the library version. my $info_string
= Net::SSLeay::OPENSSL_info($t); # $t # OPENSSL_INFO_CONFIG_DIR - e.g.
/opt/openssl-3.0.1 # OPENSSL_INFO_... # # returns: string Check openssl
doc
&lt;https://www.openssl.org/docs/manmaster/man3/OPENSSL_info.html&gt;</p></li>
<li><p>OPENSSL_version_major, OPENSSL_version_minor and
OPENSSL_version_patch <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.90 and before; requires at least OpenSSL 3.0.0-alpha1, not
in LibreSSL Return constants OPENSSL_VERSION_MAJOR,
OPENSSL_VERSION_MINOR and OPENSSL_VERSION_PATCH, respectively. my $major
= Net::SSLeay::OPENSSL_version_major(); my $minor =
Net::SSLeay::OPENSSL_version_minor(); my $patch =
Net::SSLeay::OPENSSL_version_patch(); # # return: integer For example
with OpenSSL 3.0.1, <code>$major</code> is 3, <code>$minor</code> is 0
and <code>$patch</code> is 1. Note: the constants record Net::SSLeay
compile time values whereas the three functions return values from the
library. Typically these are the same, but they can be different if the
library version is updated but Net::SSLeay is not re-compiled. See the
OpenSSL and LibreSSL API/ABI compatibility statements for more
information. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_major.html&gt;</p></li>
<li><p>OPENSSL_version_pre_release <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.90 and before; requires at least OpenSSL
3.0.0-alpha1, not in LibreSSL Return constant string defined by C macro
OPENSSL_VERSION_PRE_RELEASE. my $pre_release =
Net::SSLeay::OPENSSL_version_pre_release(); # # returns: string For
example: "-alpha3" or "" for a release version. When the macro is not
defined, an empty string is returned instead. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_pre_release.html&gt;</p></li>
<li><p><strong>OPENSSL_version_build_metadata()</strong>
<strong>COMPATIBILITY:</strong> not available in Net-SSLeay-1.90 and
before; requires at least OpenSSL 3.0.0-alpha1, not in LibreSSL Return
constant string defined by C macro OPENSSL_VERSION_BUILD_METADATA. my
$metadata = Net::SSLeay::OPENSSL_version_build_metadata(); # # returns:
string For example: "+fips" or "". When the macro is not defined, an
empty string is returned instead. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OPENSSL_version_build_metadata.html&gt;</p></li>
</ul>
<p><em>Low level API: Initialization related functions</em></p>
<ul>
<li><p>library_init Initialize SSL library by registering algorithms. my
$rv = Net::SSLeay::library_init(); Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_library_init.html&gt; While the
original function from OpenSSL always returns 1, Net::SSLeay adds a
wrapper around it to make sure that the OpenSSL function is only called
once. Thus the function will return 1 if initialization was done and 0
if not, i.e. if initialization was done already before.</p></li>
<li><p>add_ssl_algorithms The alias for library_init
Net::SSLeay::add_ssl_algorithms();</p></li>
<li><p>OpenSSL_add_ssl_algorithms The alias for library_init
Net::SSLeay::OpenSSL_add_ssl_algorithms();</p></li>
<li><p>SSLeay_add_ssl_algorithms The alias for library_init
Net::SSLeay::SSLeay_add_ssl_algorithms();</p></li>
<li><p>load_error_strings Registers the error strings for all libcrypto
+ libssl related functions. Net::SSLeay::load_error_strings(); # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_load_crypto_strings.html&gt;</p></li>
<li><p>ERR_load_crypto_strings Registers the error strings for all
libcrypto functions. No need to call this function if you have already
called load_error_strings. Net::SSLeay::ERR_load_crypto_strings(); # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_load_crypto_strings.html&gt;</p></li>
<li><p>ERR_load_RAND_strings Registers the error strings for RAND
related functions. No need to call this function if you have already
called load_error_strings. Net::SSLeay::ERR_load_RAND_strings(); # #
returns: no return value</p></li>
<li><p>ERR_load_SSL_strings Registers the error strings for SSL related
functions. No need to call this function if you have already called
load_error_strings. Net::SSLeay::ERR_load_SSL_strings(); # # returns: no
return value</p></li>
<li><p>OpenSSL_add_all_algorithms <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Add algorithms to internal
table. Net::SSLeay::OpenSSL_add_all_algorithms(); # # returns: no return
value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OpenSSL_add_all_algorithms.html&gt;</p></li>
<li><p>OPENSSL_add_all_algorithms_conf <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.45 and before Similar to
OpenSSL_add_all_algorithms - will ALWAYS load the config file
Net::SSLeay::OPENSSL_add_all_algorithms_conf(); # # returns: no return
value</p></li>
<li><p>OPENSSL_add_all_algorithms_noconf <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.45 and before Similar to
OpenSSL_add_all_algorithms - will NEVER load the config file
Net::SSLeay::OPENSSL_add_all_algorithms_noconf(); # # returns: no return
value</p></li>
</ul>
<p><em>Low level API: ERR_* and SSL_alert_* related functions</em></p>
<p><strong>NOTE:</strong> Please note that SSL_alert_* function have
SSL_ part stripped from their names.</p>
<ul>
<li><p>ERR_clear_error Clear the error queue.
Net::SSLeay::ERR_clear_error(); # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_clear_error.html&gt;</p></li>
<li><p>ERR_error_string Generates a human-readable string representing
the error code <code>$error</code>. my $rv =
Net::SSLeay::ERR_error_string($error); # $error - (unsigned integer)
error code # # returns: string Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_error_string.html&gt;</p></li>
<li><p>ERR_get_error Returns the earliest error code from the thread's
error queue and removes the entry. This function can be called
repeatedly until there are no more error codes to return. my $rv =
Net::SSLeay::ERR_get_error(); # # returns: (unsigned integer) error code
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_get_error.html&gt;</p></li>
<li><p>ERR_peek_error Returns the earliest error code from the thread's
error queue without modifying it. my $rv =
Net::SSLeay::ERR_peek_error(); # # returns: (unsigned integer) error
code Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_get_error.html&gt;</p></li>
<li><p>ERR_put_error Adds an error code to the thread's error queue. It
signals that the error of <code>$reason</code> code reason occurred in
function <code>$func</code> of library <code>$lib</code>, in line number
<code>$line</code> of <code>$file</code>.
Net::SSLeay::ERR_put_error($lib, $func, $reason, $file, $line); # $lib -
(integer) library id (check openssl/err.h for constants e.g.
ERR_LIB_SSL) # $func - (integer) function id (check openssl/ssl.h for
constants e.g. SSL_F_SSL23_READ) # $reason - (integer) reason id (check
openssl/ssl.h for constants e.g. SSL_R_SSL_HANDSHAKE_FAILURE) # $file -
(string) file name # $line - (integer) line number in $file # # returns:
no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/ERR_put_error.html&gt; and
&lt;http://www.openssl.org/docs/crypto/err.html&gt;</p></li>
<li><p>alert_desc_string Returns a two letter string as a short form
describing the reason of the alert specified by value. my $rv =
Net::SSLeay::alert_desc_string($value); # $value - (integer) allert id
(check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants) # # returns:
description string (2 letters) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p></li>
<li><p>alert_desc_string_long Returns a string describing the reason of
the alert specified by value. my $rv =
Net::SSLeay::alert_desc_string_long($value); # $value - (integer) allert
id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants) # #
returns: description string Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p></li>
<li><p>alert_type_string Returns a one letter string indicating the type
of the alert specified by value. my $rv =
Net::SSLeay::alert_type_string($value); # $value - (integer) allert id
(check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants) # # returns:
string (1 letter) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p></li>
<li><p>alert_type_string_long Returns a string indicating the type of
the alert specified by value. my $rv =
Net::SSLeay::alert_type_string_long($value); # $value - (integer) allert
id (check openssl/ssl.h for SSL3_AD_* and TLS1_AD_* constants) # #
returns: string Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_alert_type_string.html&gt;</p></li>
</ul>
<p><em>Low level API: SSL_METHOD_* related functions</em></p>
<ul>
<li><p>SSLv23_method, SSLv23_server_method and SSLv23_client_method
<strong>COMPATIBILITY:</strong> not available in Net-SSLeay-1.82 and
before. Returns SSL_METHOD structure corresponding to general-purpose
version-flexible TLS method, the return value can be later used as a
param of CTX_new_with_method. <strong>NOTE:</strong> Consider using
TLS_method, TLS_server_method or TLS_client_method with new code. my $rv
= Net::SSLeay::SSLv2_method(); # # returns: value corresponding to
openssls SSL_METHOD structure (0 on failure)</p></li>
<li><p>SSLv2_method Returns SSL_METHOD structure corresponding to SSLv2
method, the return value can be later used as a param of
CTX_new_with_method. Only available where supported by the underlying
openssl. my $rv = Net::SSLeay::SSLv2_method(); # # returns: value
corresponding to openssls SSL_METHOD structure (0 on failure)</p></li>
<li><p>SSLv3_method Returns SSL_METHOD structure corresponding to SSLv3
method, the return value can be later used as a param of
CTX_new_with_method. my $rv = Net::SSLeay::SSLv3_method(); # # returns:
value corresponding to openssls SSL_METHOD structure (0 on failure)
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
<li><p>TLSv1_method, TLSv1_server_method and TLSv1_client_method
<strong>COMPATIBILITY:</strong> Server and client methods not available
in Net-SSLeay-1.82 and before. Returns SSL_METHOD structure
corresponding to TLSv1 method, the return value can be later used as a
param of CTX_new_with_method. my $rv = Net::SSLeay::TLSv1_method(); # #
returns: value corresponding to openssls SSL_METHOD structure (0 on
failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
<li><p>TLSv1_1_method, TLSv1_1_server_method and TLSv1_1_client_method
<strong>COMPATIBILITY:</strong> Server and client methods not available
in Net-SSLeay-1.82 and before. Returns SSL_METHOD structure
corresponding to TLSv1_1 method, the return value can be later used as a
param of CTX_new_with_method. Only available where supported by the
underlying openssl. my $rv = Net::SSLeay::TLSv1_1_method(); # # returns:
value corresponding to openssls SSL_METHOD structure (0 on failure)
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
<li><p>TLSv1_2_method, TLSv1_2_server_method and TLSv1_2_client_method
<strong>COMPATIBILITY:</strong> Server and client methods not available
in Net-SSLeay-1.82 and before. Returns SSL_METHOD structure
corresponding to TLSv1_2 method, the return value can be later used as a
param of CTX_new_with_method. Only available where supported by the
underlying openssl. my $rv = Net::SSLeay::TLSv1_2_method(); # # returns:
value corresponding to openssls SSL_METHOD structure (0 on failure)
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
<li><p>TLS_method, TLS_server_method and TLS_client_method
<strong>COMPATIBILITY:</strong> Not available in Net-SSLeay-1.82 and
before. Returns SSL_METHOD structure corresponding to general-purpose
version-flexible TLS method, the return value can be later used as a
param of CTX_new_with_method. Only available where supported by the
underlying openssl. my $rv = Net::SSLeay::TLS_method(); # # returns:
value corresponding to openssls SSL_METHOD structure (0 on failure)
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
</ul>
<p><em>Low level API: ENGINE_* related functions</em></p>
<ul>
<li><p>ENGINE_load_builtin_engines <strong>COMPATIBILITY:</strong>
Requires an OpenSSL build with dynamic engine loading support. Load all
bundled ENGINEs into memory and make them visible.
Net::SSLeay::ENGINE_load_builtin_engines(); # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p></li>
<li><p>ENGINE_register_all_complete <strong>COMPATIBILITY:</strong>
Requires an OpenSSL build with dynamic engine loading support. Register
all loaded ENGINEs for every algorithm they collectively implement.
Net::SSLeay::ENGINE_register_all_complete(); # # returns: no return
value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p></li>
<li><p>ENGINE_set_default <strong>COMPATIBILITY:</strong> Requires an
OpenSSL build with dynamic engine loading support. Set default engine to
<code>$e</code> + set its flags to <code>$flags</code>. my $rv =
Net::SSLeay::ENGINE_set_default($e, $flags); # $e - value corresponding
to openssls ENGINE structure # $flags - (integer) engine flags # flags
value can be made by bitwise "OR"ing: # 0x0001 - ENGINE_METHOD_RSA #
0x0002 - ENGINE_METHOD_DSA # 0x0004 - ENGINE_METHOD_DH # 0x0008 -
ENGINE_METHOD_RAND # 0x0010 - ENGINE_METHOD_ECDH # 0x0020 -
ENGINE_METHOD_ECDSA # 0x0040 - ENGINE_METHOD_CIPHERS # 0x0080 -
ENGINE_METHOD_DIGESTS # 0x0100 - ENGINE_METHOD_STORE # 0x0200 -
ENGINE_METHOD_PKEY_METHS # 0x0400 - ENGINE_METHOD_PKEY_ASN1_METHS #
Obvious all-or-nothing cases: # 0xFFFF - ENGINE_METHOD_ALL # 0x0000 -
ENGINE_METHOD_NONE # # returns: 1 on success, 0 on failure Check openssl
doc &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p></li>
<li><p>ENGINE_by_id Get ENGINE by its identification <code>$id</code>.
<strong>COMPATIBILITY:</strong> Requires an OpenSSL build with dynamic
engine loading support. my $rv = Net::SSLeay::ENGINE_by_id($id); # $id -
(string) engine identification e.g. "dynamic" # # returns: value
corresponding to openssls ENGINE structure (0 on failure) Check openssl
doc &lt;http://www.openssl.org/docs/crypto/engine.html&gt;</p></li>
</ul>
<p><em>Low level API: EVP_PKEY_* related functions</em></p>
<ul>
<li><p>EVP_PKEY_copy_parameters Copies the parameters from key
<code>$from</code> to key <code>$to</code>. my $rv =
Net::SSLeay::EVP_PKEY_copy_parameters($to, $from); # $to - value
corresponding to openssls EVP_PKEY structure # $from - value
corresponding to openssls EVP_PKEY structure # # returns: 1 on success,
0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_PKEY_cmp.html&gt;</p></li>
<li><p>EVP_PKEY_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Creates a new EVP_PKEY structure. my $rv =
Net::SSLeay::EVP_PKEY_new(); # # returns: value corresponding to
openssls EVP_PKEY structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_PKEY_new.html&gt;</p></li>
<li><p>EVP_PKEY_free <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Free an allocated EVP_PKEY structure.
Net::SSLeay::EVP_PKEY_free($pkey); # $pkey - value corresponding to
openssls EVP_PKEY structure # # returns: no return value Check openssl
doc
&lt;http://www.openssl.org/docs/crypto/EVP_PKEY_new.html&gt;</p></li>
<li><p>EVP_PKEY_assign_RSA <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Set the key referenced by
<code>$pkey</code> to <code>$key</code> <strong>NOTE:</strong> No
reference counter will be increased, i.e. <code>$key</code> will be
freed if <code>$pkey</code> is freed. my $rv =
Net::SSLeay::EVP_PKEY_assign_RSA($pkey, $key); # $pkey - value
corresponding to openssls EVP_PKEY structure # $key - value
corresponding to openssls RSA structure # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_PKEY_assign_RSA.html&gt;</p></li>
<li><p>EVP_PKEY_assign_EC_KEY <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.74 and before Set the key referenced by
<code>$pkey</code> to <code>$key</code> <strong>NOTE:</strong> No
reference counter will be increased, i.e. <code>$key</code> will be
freed if <code>$pkey</code> is freed. my $rv =
Net::SSLeay::EVP_PKEY_assign_EC_KEY($pkey, $key); # $pkey - value
corresponding to openssls EVP_PKEY structure # $key - value
corresponding to openssls EC_KEY structure # # returns: 1 on success, 0
on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_PKEY_assign_EC_KEY.html&gt;</p></li>
<li><p>EVP_PKEY_bits <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns the size of the key
<code>$pkey</code> in bits. my $rv = Net::SSLeay::EVP_PKEY_bits($pkey);
# $pkey - value corresponding to openssls EVP_PKEY structure # #
returns: size in bits</p></li>
<li><p>EVP_PKEY_size <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns the maximum size of a signature in
bytes. The actual signature may be smaller. my $rv =
Net::SSLeay::EVP_PKEY_size($pkey); # $pkey - value corresponding to
openssls EVP_PKEY structure # # returns: the maximum size in bytes Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_SignInit.html&gt;</p></li>
<li><p>EVP_PKEY_id <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before; requires at least openssl-1.0.0 Returns
<code>$pkey</code> type (integer value of corresponding NID). my $rv =
Net::SSLeay::EVP_PKEY_id($pkey); # $pkey - value corresponding to
openssls EVP_PKEY structure # # returns: (integer) key type Example: my
$pubkey = Net::SSLeay::X509_get_pubkey($x509); my $type =
Net::SSLeay::EVP_PKEY_id($pubkey); print Net::SSLeay::OBJ_nid2sn($type);
#prints e.g. rsaEncryption</p></li>
</ul>
<p><em>Low level API: PEM_* related functions</em></p>
<p>Check openssl doc
&lt;http://www.openssl.org/docs/crypto/pem.html&gt;</p>
<ul>
<li><p>PEM_read_bio_X509 <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Loads PEM formatted X509 certificate via
given BIO structure. my $rv = Net::SSLeay::PEM_read_bio_X509($bio); #
$bio - value corresponding to openssls BIO structure # # returns: value
corresponding to openssls X509 structure (0 on failure) Example: my $bio
= Net::SSLeay::BIO_new_file($filename, r); my $x509 =
Net::SSLeay::PEM_read_bio_X509($bio);
Net::SSLeay::BIO_free($bio);</p></li>
<li><p>PEM_read_bio_X509_REQ <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Loads PEM formatted X509_REQ
object via given BIO structure. my $rv =
Net::SSLeay::PEM_read_bio_X509_REQ($bio, $x=NULL, $cb=NULL, $u=NULL); #
$bio - value corresponding to openssls BIO structure # # returns: value
corresponding to openssls X509_REQ structure (0 on failure) Example: my
$bio = Net::SSLeay::BIO_new_file($filename, r); my $x509_req =
Net::SSLeay::PEM_read_bio_X509_REQ($bio);
Net::SSLeay::BIO_free($bio);</p></li>
<li><p>PEM_read_bio_DHparams Reads DH structure from BIO. my $rv =
Net::SSLeay::PEM_read_bio_DHparams($bio); # $bio - value corresponding
to openssls BIO structure # # returns: value corresponding to openssls
DH structure (0 on failure)</p></li>
<li><p>PEM_read_bio_X509_CRL Reads X509_CRL structure from BIO. my $rv =
Net::SSLeay::PEM_read_bio_X509_CRL($bio); # $bio - value corresponding
to openssls BIO structure # # returns: value corresponding to openssls
X509_CRL structure (0 on failure)</p></li>
<li><p>PEM_read_bio_PrivateKey <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Loads PEM formatted private key
via given BIO structure. my $rv =
Net::SSLeay::PEM_read_bio_PrivateKey($bio, $cb, $data); # $bio - value
corresponding to openssls BIO structure # $cb - reference to perl
callback function # $data - data that will be passed to callback
function (see examples below) # # returns: value corresponding to
openssls EVP_PKEY structure (0 on failure) Example: my $bio =
Net::SSLeay::BIO_new_file($filename, r); my $privkey =
Net::SSLeay::PEM_read_bio_PrivateKey($bio); #ask for password if needed
Net::SSLeay::BIO_free($bio); To use password you have the following
options: $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio,
\&amp;callback_func); # use callback func for getting password $privkey
= Net::SSLeay::PEM_read_bio_PrivateKey($bio, \&amp;callback_func,
$data); # use callback_func + pass $data to callback_func $privkey =
Net::SSLeay::PEM_read_bio_PrivateKey($bio, undef, "secret"); # use
password "secret" $privkey = Net::SSLeay::PEM_read_bio_PrivateKey($bio,
undef, ""); # use empty password Callback function signature: sub
callback_func { my ($max_passwd_size, $rwflag, $data) = @_; #
$max_passwd_size - maximum size of returned password (longer values will
be discarded) # $rwflag - indicates whether we are loading (0) or
storing (1) - for PEM_read_bio_PrivateKey always 0 # $data - the data
passed to PEM_read_bio_PrivateKey as 3rd parameter return "secret";
}</p></li>
<li><p>PEM_X509_INFO_read_bio Reads a BIO containing a PEM formatted
file into a STACK_OF(X509_INFO) structure. my $rv =
Net::SSLeay::PEM_X509_INFO_read_bio($bio); # $bio - value corresponding
to openssls BIO structure # # returns: value corresponding to openssls
STACK_OF(X509_INFO) structure. Example: my $bio =
Net::SSLeay::BIO_new_file($filename, r); my $sk_x509_info =
Net::SSLeay::PEM_X509_INFO_read_bio($bio);
Net::SSLeay::BIO_free($bio);</p></li>
<li><p>PEM_get_string_X509 <strong>NOTE:</strong> Does not exactly
correspond to any low level API function Converts/exports X509
certificate to string (PEM format).
Net::SSLeay::PEM_get_string_X509($x509); # $x509 - value corresponding
to openssls X509 structure # # returns: string with $x509 in PEM
format</p></li>
<li><p>PEM_get_string_PrivateKey <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Converts public key
<code>$pk</code> into PEM formatted string (optionally protected with
password). my $rv = Net::SSLeay::PEM_get_string_PrivateKey($pk, $passwd,
$enc_alg); # $pk - value corresponding to openssls EVP_PKEY structure #
$passwd - [optional] (string) password to use for key encryption #
$enc_alg - [optional] algorithm to use for key encryption (default:
DES_CBC) - value corresponding to openssls EVP_CIPHER structure # #
returns: PEM formatted string Examples: $pem_privkey =
Net::SSLeay::PEM_get_string_PrivateKey($pk); $pem_privkey =
Net::SSLeay::PEM_get_string_PrivateKey($pk, "secret"); $pem_privkey =
Net::SSLeay::PEM_get_string_PrivateKey($pk, "secret",
Net::SSLeay::EVP_get_cipherbyname("DES-EDE3-CBC"));</p></li>
<li><p>PEM_get_string_X509_CRL <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Converts X509_CRL object
<code>$x509_crl</code> into PEM formatted string.
Net::SSLeay::PEM_get_string_X509_CRL($x509_crl); # $x509_crl - value
corresponding to openssls X509_CRL structure # # returns: no return
value</p></li>
<li><p>PEM_get_string_X509_REQ <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Converts X509_REQ object
<code>$x509_crl</code> into PEM formatted string.
Net::SSLeay::PEM_get_string_X509_REQ($x509_req); # $x509_req - value
corresponding to openssls X509_REQ structure # # returns: no return
value</p></li>
</ul>
<p><em>Low level API: d2i_* (DER format) related functions</em></p>
<ul>
<li><p>d2i_X509_bio <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Loads DER formatted X509 certificate via
given BIO structure. my $rv = Net::SSLeay::d2i_X509_bio($bp); # $bp -
value corresponding to openssls BIO structure # # returns: value
corresponding to openssls X509 structure (0 on failure) Example: my $bio
= Net::SSLeay::BIO_new_file($filename, rb); my $x509 =
Net::SSLeay::d2i_X509_bio($bio); Net::SSLeay::BIO_free($bio); Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/d2i_X509.html&gt;</p></li>
<li><p>d2i_X509_CRL_bio <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Loads DER formatted X509_CRL object via given
BIO structure. my $rv = Net::SSLeay::d2i_X509_CRL_bio($bp); # $bp -
value corresponding to openssls BIO structure # # returns: value
corresponding to openssls X509_CRL structure (0 on failure) Example: my
$bio = Net::SSLeay::BIO_new_file($filename, rb); my $x509_crl =
Net::SSLeay::d2i_X509_CRL_bio($bio);
Net::SSLeay::BIO_free($bio);</p></li>
<li><p>d2i_X509_REQ_bio <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Loads DER formatted X509_REQ object via given
BIO structure. my $rv = Net::SSLeay::d2i_X509_REQ_bio($bp); # $bp -
value corresponding to openssls BIO structure # # returns: value
corresponding to openssls X509_REQ structure (0 on failure) Example: my
$bio = Net::SSLeay::BIO_new_file($filename, rb); my $x509_req =
Net::SSLeay::d2i_X509_REQ_bio($bio);
Net::SSLeay::BIO_free($bio);</p></li>
</ul>
<p><em>Low level API: PKCS12 related functions</em></p>
<ul>
<li><p>P_PKCS12_load_file <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Loads X509 certificate + private key +
certificates of CA chain (if present in PKCS12 file). my ($privkey,
$cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename,
$load_chain, $password); # $filename - name of PKCS12 file # $load_chain
- [optional] whether load (1) or not(0) CA chain (default: 0) #
$password - [optional] password for private key # # returns: triplet
($privkey, $cert, @cachain) # $privkey - value corresponding to openssls
EVP_PKEY structure # $cert - value corresponding to openssls X509
structure # @cachain - array of values corresponding to openssls X509
structure (empty if no CA chain in PKCS12) <strong>IMPORTANT
NOTE:</strong> after you do the job you need to call
<strong>X509_free()</strong> on <code>$privkey</code> + all members of
<code>@cachain</code> and <strong>EVP_PKEY_free()</strong> on
<code>$privkey</code>. Examples: my ($privkey, $cert) =
Net::SSLeay::P_PKCS12_load_file($filename); #or my ($privkey, $cert) =
Net::SSLeay::P_PKCS12_load_file($filename, 0, $password); #or my
($privkey, $cert, @cachain) = Net::SSLeay::P_PKCS12_load_file($filename,
1); #or my ($privkey, $cert, @cachain) =
Net::SSLeay::P_PKCS12_load_file($filename, 1, $password); #BEWARE: THIS
IS WRONG - MEMORY LEAKS! (you cannot free @cachain items) my ($privkey,
$cert) = Net::SSLeay::P_PKCS12_load_file($filename, 1, $password);
<strong>NOTE</strong> With some combinations of Windows, perl, compiler
and compiler options, you may see a runtime error no OPENSSL_Applink,
when calling Net::SSLeay::P_PKCS12_load_file. See README.Win32 for more
details.</p></li>
</ul>
<p><em>Low level API: SESSION_* related functions</em></p>
<ul>
<li><p>d2i_SSL_SESSION <strong>COMPATIBILITY:</strong> does not work in
Net-SSLeay-1.85 and before Transforms the binary ASN1 representation
string of an SSL/TLS session into an SSL_SESSION object. my $ses =
Net::SSLeay::d2i_SSL_SESSION($data); # $data - the session as ASN1
representation string # # returns: $ses - the new SSL_SESSION Check
openssl doc
&lt;https://www.openssl.org/docs/ssl/i2d_SSL_SESSION.html&gt;</p></li>
<li><p>i2d_SSL_SESSION <strong>COMPATIBILITY:</strong> does not work in
Net-SSLeay-1.85 and before Transforms the SSL_SESSION object in into the
ASN1 representation and returns it as string. my $data =
Net::SSLeay::i2d_SSL_SESSION($ses); # $ses - value corresponding to
openssls SSL_SESSION structure # # returns: $data - session as string
Check openssl doc
&lt;https://www.openssl.org/docs/ssl/d2i_SSL_SESSION.html&gt;</p></li>
<li><p>SESSION_new Creates a new SSL_SESSION structure. my $rv =
Net::SSLeay::SESSION_new(); # # returns: value corresponding to openssls
SSL_SESSION structure (0 on failure)</p></li>
<li><p>SESSION_free Free an allocated SSL_SESSION structure.
Net::SSLeay::SESSION_free($ses); # $ses - value corresponding to
openssls SSL_SESSION structure # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_free.html&gt;</p></li>
<li><p>SESSION_up_ref <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0-pre4 or
LibreSSL 2.7.0 Increases the reference counter on a SSL_SESSION
structure. Net::SSLeay::SESSION_up_ref($ses); # $ses - value
corresponding to openssls SSL_SESSION structure # # returns: 1 on
success else 0 Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_SESSION_up_ref.html&gt;</p></li>
<li><p>SESSION_dup <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Duplicates a SSL_SESSION structure.
Net::SSLeay::SESSION_dup($ses); # $ses - value corresponding to openssls
SSL_SESSION structure # # returns: the duplicated session Check openssl
doc
&lt;https://www.openssl.org/docs/ssl/SSL_SESSION_dup.html&gt;</p></li>
<li><p>SESSION_is_resumable <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.1, not in LibreSSL Determine whether an SSL_SESSION object can be
used for resumption. Net::SSLeay::SESSION_is_resumable($ses); # $ses -
value corresponding to openssls SSL_SESSION structure # # returns:
(integer) 1 if it can or 0 if not Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_SESSION_is_resumable.html&gt;</p></li>
<li><p>SESSION_cmp Compare two SSL_SESSION structures. my $rv =
Net::SSLeay::SESSION_cmp($sesa, $sesb); # $sesa - value corresponding to
openssls SSL_SESSION structure # $sesb - value corresponding to openssls
SSL_SESSION structure # # returns: 0 if the two structures are the same
<strong>NOTE:</strong> Not available in openssl 1.0 or later</p></li>
<li><p>SESSION_get_app_data Can be used to get application defined
value/data. my $rv = Net::SSLeay::SESSION_get_app_data($ses); # $ses -
value corresponding to openssls SSL_SESSION structure # # returns:
string/buffer/pointer ???</p></li>
<li><p>SESSION_set_app_data Can be used to set some application defined
value/data. my $rv = Net::SSLeay::SESSION_set_app_data($s, $a); # $s -
value corresponding to openssls SSL_SESSION structure # $a -
(string/buffer/pointer ???) data # # returns: ???</p></li>
<li><p>SESSION_get_ex_data Is used to retrieve the information for
<code>$idx</code> from session <code>$ses</code>. my $rv =
Net::SSLeay::SESSION_get_ex_data($ses, $idx); # $ses - value
corresponding to openssls SSL_SESSION structure # $idx - (integer) index
for application specific data # # returns: pointer to ??? Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p></li>
<li><p>SESSION_set_ex_data Is used to store application data at arg for
idx into the session object. my $rv =
Net::SSLeay::SESSION_set_ex_data($ss, $idx, $data); # $ss - value
corresponding to openssls SSL_SESSION structure # $idx - (integer) ??? #
$data - (pointer) ??? # # returns: 1 on success, 0 on failure Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p></li>
<li><p>SESSION_get_ex_new_index Is used to register a new index for
application specific data. my $rv =
Net::SSLeay::SESSION_get_ex_new_index($argl, $argp, $new_func,
$dup_func, $free_func); # $argl - (long) ??? # $argp - (pointer) ??? #
$new_func - function pointer ??? (CRYPTO_EX_new *) # $dup_func -
function pointer ??? (CRYPTO_EX_dup *) # $free_func - function pointer
??? (CRYPTO_EX_free *) # # returns: (integer) ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_ex_new_index.html&gt;</p></li>
<li><p>SESSION_get_master_key <strong>NOTE:</strong> Does not exactly
correspond to any low level API function Returns 'master_key' value from
SSL_SESSION structure <code>$s</code>
Net::SSLeay::SESSION_get_master_key($s); # $s - value corresponding to
openssls SSL_SESSION structure # # returns: master key (binary
data)</p></li>
<li><p>SESSION_set_master_key Sets 'master_key' value for SSL_SESSION
structure <code>$s</code> Net::SSLeay::SESSION_set_master_key($s, $key);
# $s - value corresponding to openssls SSL_SESSION structure # $key -
master key (binary data) # # returns: no return value Not available with
OpenSSL 1.1 and later. Code that previously used SESSION_set_master_key
must now set <code>$secret</code> in the session_secret callback set
with SSL_set_session_secret_cb.</p></li>
<li><p>SESSION_get_time Returns the time at which the session s was
established. The time is given in seconds since 1.1.1970. my $rv =
Net::SSLeay::SESSION_get_time($s); # $s - value corresponding to
openssls SSL_SESSION structure # # returns: timestamp (seconds since
1.1.1970) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p></li>
<li><p>get_time Technically the same functionality as SESSION_get_time.
my $rv = Net::SSLeay::get_time($s);</p></li>
<li><p>SESSION_get_timeout Returns the timeout value set for session
<code>$s</code> in seconds. my $rv =
Net::SSLeay::SESSION_get_timeout($s); # $s - value corresponding to
openssls SSL_SESSION structure # # returns: timeout (in seconds) Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p></li>
<li><p>get_timeout Technically the same functionality as
SESSION_get_timeout. my $rv = Net::SSLeay::get_timeout($s);</p></li>
<li><p>SESSION_print <strong>NOTE:</strong> Does not exactly correspond
to any low level API function Prints session details (e.g. protocol
version, cipher, session-id ...) to BIO. my $rv =
Net::SSLeay::SESSION_print($fp, $ses); # $fp - value corresponding to
openssls BIO structure # $ses - value corresponding to openssls
SSL_SESSION structure # # returns: 1 on success, 0 on failure You have
to use necessary BIO functions like this: # let us have $ssl
corresponding to openssls SSL structure my $ses =
Net::SSLeay::get_session($ssl); my $bio =
Net::SSLeay::BIO_new(&amp;Net::SSLeay::BIO_s_mem);
Net::SSLeay::SESSION_print($bio, $ses); print
Net::SSLeay::BIO_read($bio);</p></li>
<li><p>SESSION_print_fp Prints session details (e.g. protocol version,
cipher, session-id ...) to file handle. my $rv =
Net::SSLeay::SESSION_print_fp($fp, $ses); # $fp - perl file handle #
$ses - value corresponding to openssls SSL_SESSION structure # #
returns: 1 on success, 0 on failure Example: # let us have $ssl
corresponding to openssls SSL structure my $ses =
Net::SSLeay::get_session($ssl); open my $fh, "&gt;", "output.txt";
Net::SSLeay::SESSION_print_fp($fh,$ses);</p></li>
<li><p>SESSION_set_time Replaces the creation time of the session s with
the chosen value <code>$t</code> (seconds since 1.1.1970). my $rv =
Net::SSLeay::SESSION_set_time($ses, $t); # $ses - value corresponding to
openssls SSL_SESSION structure # $t - time value # # returns: 1 on
success Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p></li>
<li><p>set_time Technically the same functionality as SESSION_set_time.
my $rv = Net::SSLeay::set_time($ses, $t);</p></li>
<li><p>SESSION_set_timeout Sets the timeout value for session s in
seconds to <code>$t</code>. my $rv =
Net::SSLeay::SESSION_set_timeout($s, $t); # $s - value corresponding to
openssls SSL_SESSION structure # $t - timeout (in seconds) # # returns:
1 on success Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_SESSION_get_time.html&gt;</p></li>
<li><p>set_timeout Technically the same functionality as
SESSION_set_timeout. my $rv = Net::SSLeay::set_timeout($ses,
$t);</p></li>
</ul>
<p><em>Low level API: SSL_CTX_* related functions</em></p>
<p><strong>NOTE:</strong> Please note that the function described in
this chapter have SSL_ part stripped from their original openssl
names.</p>
<ul>
<li><p>CTX_add_client_CA Adds the CA name extracted from
<code>$cacert</code> to the list of CAs sent to the client when
requesting a client certificate for <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_add_client_CA($ctx, $cacert); # $ctx - value
corresponding to openssls SSL_CTX structure # $cacert - value
corresponding to openssls X509 structure # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p></li>
<li><p>CTX_add_extra_chain_cert Adds the certificate <code>$x509</code>
to the certificate chain presented together with the certificate.
Several certificates can be added one after the other. my $rv =
Net::SSLeay::CTX_add_extra_chain_cert($ctx, $x509); # $ctx - value
corresponding to openssls SSL_CTX structure # $x509 - value
corresponding to openssls X509 structure # # returns: 1 on success,
check out the error stack to find out the reason for failure otherwise
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_extra_chain_cert.html&gt;</p></li>
<li><p>CTX_add_session Adds the session <code>$ses</code> to the context
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_add_session($ctx, $ses); #
$ctx - value corresponding to openssls SSL_CTX structure # $ses - value
corresponding to openssls SSL_SESSION structure # # returns: 1 on
success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_session.html&gt;</p></li>
<li><p>CTX_callback_ctrl ??? (more info needed) my $rv =
Net::SSLeay::CTX_callback_ctrl($ctx, $cmd, $fp); # $ctx - value
corresponding to openssls SSL_CTX structure # $cmd - (integer) command
id # $fp - (function pointer) ??? # # returns: ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p></li>
<li><p>CTX_check_private_key Checks the consistency of a private key
with the corresponding certificate loaded into <code>$ctx</code>. my $rv
= Net::SSLeay::CTX_check_private_key($ctx); # $ctx - value corresponding
to openssls SSL_CTX structure # # returns: 1 on success, otherwise check
out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_ctrl Internal handling function for SSL_CTX objects.
<strong>BEWARE:</strong> openssl doc says: This function should never be
called directly! my $rv = Net::SSLeay::CTX_ctrl($ctx, $cmd, $larg,
$parg); # $ctx - value corresponding to openssls SSL_CTX structure #
$cmd - (integer) command id # $larg - (integer) long ??? # $parg -
(string/pointer) ??? # # returns: (long) result of given command ???
#valid $cmd values 1 - SSL_CTRL_NEED_TMP_RSA 2 - SSL_CTRL_SET_TMP_RSA 3
- SSL_CTRL_SET_TMP_DH 4 - SSL_CTRL_SET_TMP_ECDH 5 -
SSL_CTRL_SET_TMP_RSA_CB 6 - SSL_CTRL_SET_TMP_DH_CB 7 -
SSL_CTRL_SET_TMP_ECDH_CB 8 - SSL_CTRL_GET_SESSION_REUSED 9 -
SSL_CTRL_GET_CLIENT_CERT_REQUEST 10 - SSL_CTRL_GET_NUM_RENEGOTIATIONS 11
- SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS 12 -
SSL_CTRL_GET_TOTAL_RENEGOTIATIONS 13 - SSL_CTRL_GET_FLAGS 14 -
SSL_CTRL_EXTRA_CHAIN_CERT 15 - SSL_CTRL_SET_MSG_CALLBACK 16 -
SSL_CTRL_SET_MSG_CALLBACK_ARG 17 - SSL_CTRL_SET_MTU 20 -
SSL_CTRL_SESS_NUMBER 21 - SSL_CTRL_SESS_CONNECT 22 -
SSL_CTRL_SESS_CONNECT_GOOD 23 - SSL_CTRL_SESS_CONNECT_RENEGOTIATE 24 -
SSL_CTRL_SESS_ACCEPT 25 - SSL_CTRL_SESS_ACCEPT_GOOD 26 -
SSL_CTRL_SESS_ACCEPT_RENEGOTIATE 27 - SSL_CTRL_SESS_HIT 28 -
SSL_CTRL_SESS_CB_HIT 29 - SSL_CTRL_SESS_MISSES 30 -
SSL_CTRL_SESS_TIMEOUTS 31 - SSL_CTRL_SESS_CACHE_FULL 32 -
SSL_CTRL_OPTIONS 33 - SSL_CTRL_MODE 40 - SSL_CTRL_GET_READ_AHEAD 41 -
SSL_CTRL_SET_READ_AHEAD 42 - SSL_CTRL_SET_SESS_CACHE_SIZE 43 -
SSL_CTRL_GET_SESS_CACHE_SIZE 44 - SSL_CTRL_SET_SESS_CACHE_MODE 45 -
SSL_CTRL_GET_SESS_CACHE_MODE 50 - SSL_CTRL_GET_MAX_CERT_LIST 51 -
SSL_CTRL_SET_MAX_CERT_LIST 52 - SSL_CTRL_SET_MAX_SEND_FRAGMENT 53 -
SSL_CTRL_SET_TLSEXT_SERVERNAME_CB 54 -
SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG 55 - SSL_CTRL_SET_TLSEXT_HOSTNAME 56
- SSL_CTRL_SET_TLSEXT_DEBUG_CB 57 - SSL_CTRL_SET_TLSEXT_DEBUG_ARG 58 -
SSL_CTRL_GET_TLSEXT_TICKET_KEYS 59 - SSL_CTRL_SET_TLSEXT_TICKET_KEYS 60
- SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT 61 -
SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB 62 -
SSL_CTRL_SET_TLSEXT_OPAQUE_PRF_INPUT_CB_ARG 63 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB 64 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_CB_ARG 65 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_TYPE 66 -
SSL_CTRL_GET_TLSEXT_STATUS_REQ_EXTS 67 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_EXTS 68 -
SSL_CTRL_GET_TLSEXT_STATUS_REQ_IDS 69 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_IDS 70 -
SSL_CTRL_GET_TLSEXT_STATUS_REQ_OCSP_RESP 71 -
SSL_CTRL_SET_TLSEXT_STATUS_REQ_OCSP_RESP 72 -
SSL_CTRL_SET_TLSEXT_TICKET_KEY_CB 73 - DTLS_CTRL_GET_TIMEOUT 74 -
DTLS_CTRL_HANDLE_TIMEOUT 75 - DTLS_CTRL_LISTEN 76 -
SSL_CTRL_GET_RI_SUPPORT 77 - SSL_CTRL_CLEAR_OPTIONS 78 -
SSL_CTRL_CLEAR_MODE 82 - SSL_CTRL_GET_EXTRA_CHAIN_CERTS 83 -
SSL_CTRL_CLEAR_EXTRA_CHAIN_CERTS 88 - SSL_CTRL_CHAIN 89 -
SSL_CTRL_CHAIN_CERT 90 - SSL_CTRL_GET_CURVES 91 - SSL_CTRL_SET_CURVES 92
- SSL_CTRL_SET_CURVES_LIST 93 - SSL_CTRL_GET_SHARED_CURVE 94 -
SSL_CTRL_SET_ECDH_AUTO 97 - SSL_CTRL_SET_SIGALGS 98 -
SSL_CTRL_SET_SIGALGS_LIST 99 - SSL_CTRL_CERT_FLAGS 100 -
SSL_CTRL_CLEAR_CERT_FLAGS 101 - SSL_CTRL_SET_CLIENT_SIGALGS 102 -
SSL_CTRL_SET_CLIENT_SIGALGS_LIST 103 - SSL_CTRL_GET_CLIENT_CERT_TYPES
104 - SSL_CTRL_SET_CLIENT_CERT_TYPES 105 - SSL_CTRL_BUILD_CERT_CHAIN 106
- SSL_CTRL_SET_VERIFY_CERT_STORE 107 - SSL_CTRL_SET_CHAIN_CERT_STORE 108
- SSL_CTRL_GET_PEER_SIGNATURE_NID 109 - SSL_CTRL_GET_SERVER_TMP_KEY 110
- SSL_CTRL_GET_RAW_CIPHERLIST 111 - SSL_CTRL_GET_EC_POINT_FORMATS 112 -
SSL_CTRL_GET_TLSA_RECORD 113 - SSL_CTRL_SET_TLSA_RECORD 114 -
SSL_CTRL_PULL_TLSA_RECORD Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p></li>
<li><p>CTX_flush_sessions Causes a run through the session cache of
<code>$ctx</code> to remove sessions expired at time <code>$tm</code>.
Net::SSLeay::CTX_flush_sessions($ctx, $tm); # $ctx - value corresponding
to openssls SSL_CTX structure # $tm - specifies the time which should be
used for the expiration test (seconds since 1.1.1970) # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_flush_sessions.html&gt;</p></li>
<li><p>CTX_free Free an allocated SSL_CTX object.
Net::SSLeay::CTX_free($ctx); # $ctx - value corresponding to openssls
SSL_CTX structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_free.html&gt;</p></li>
<li><p>CTX_get_app_data Can be used to get application defined
value/data. my $rv = Net::SSLeay::CTX_get_app_data($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns:
string/buffer/pointer ???</p></li>
<li><p>CTX_set_app_data Can be used to set some application defined
value/data. my $rv = Net::SSLeay::CTX_set_app_data($ctx, $arg); # $ctx -
value corresponding to openssls SSL_CTX structure # $arg -
(string/buffer/pointer ???) data # # returns: ???</p></li>
<li><p>CTX_get0_param <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or
LibreSSL 2.7.0 Returns the current verification parameters. my $vpm =
Net::SSLeay::CTX_get0_param($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: value corresponding to openssls
X509_VERIFY_PARAM structure Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p></li>
<li><p>CTX_get_cert_store Returns the current certificate verification
storage. my $rv = Net::SSLeay::CTX_get_cert_store($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: value
corresponding to openssls X509_STORE structure (0 on failure) Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_store.html&gt;</p></li>
<li><p>CTX_get_client_CA_list Returns the list of client CAs explicitly
set for <code>$ctx</code> using CTX_set_client_CA_list. my $rv =
Net::SSLeay::CTX_get_client_CA_list($ctx); # $ctx - value corresponding
to openssls SSL_CTX structure # # returns: value corresponding to
openssls X509_NAME_STACK structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_client_CA_list.html&gt;</p></li>
<li><p>CTX_get_ex_data Is used to retrieve the information for index
<code>$idx</code> from <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_get_ex_data($ssl, $idx); # $ssl - value corresponding
to openssls SSL_CTX structure # $idx - (integer) index for application
specific data # # returns: pointer to ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p></li>
<li><p>CTX_get_ex_new_index Is used to register a new index for
application specific data. my $rv =
Net::SSLeay::CTX_get_ex_new_index($argl, $argp, $new_func, $dup_func,
$free_func); # $argl - (long) ??? # $argp - (pointer) ??? # $new_func -
function pointer ??? (CRYPTO_EX_new *) # $dup_func - function pointer
??? (CRYPTO_EX_dup *) # $free_func - function pointer ???
(CRYPTO_EX_free *) # # returns: (integer) ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p></li>
<li><p>CTX_get_mode Returns the mode set for ctx. my $rv =
Net::SSLeay::CTX_get_mode($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: mode (bitmask) #to decode the
return value (bitmask) use: 0x00000001 corresponds to
SSL_MODE_ENABLE_PARTIAL_WRITE 0x00000002 corresponds to
SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER 0x00000004 corresponds to
SSL_MODE_AUTO_RETRY 0x00000008 corresponds to SSL_MODE_NO_AUTO_CHAIN
0x00000010 corresponds to SSL_MODE_RELEASE_BUFFERS (note: some of the
bits might not be supported by older openssl versions) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p></li>
<li><p>CTX_set_mode Adds the mode set via bitmask in <code>$mode</code>
to <code>$ctx</code>. Options already set before are not cleared. my $rv
= Net::SSLeay::CTX_set_mode($ctx, $mode); # $ctx - value corresponding
to openssls SSL_CTX structure # $mode - mode bitmask # # returns: the
new mode bitmask after adding $mode For bitmask details see CTX_get_mode
(above). Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p></li>
<li><p>CTX_get_options Returns the options (bitmask) set for
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_get_options($ctx); # $ctx -
value corresponding to openssls SSL_CTX structure # # returns: options
(bitmask) <strong>BEWARE:</strong> The available constants and their
values in bitmask depend on the TLS library. For example,
SSL_OP_NO_TLSv1_3 became available much later than SSL_OP_NO_COMPRESS
which is already deprecated by some libraries. Also, some previously
used option values have been recycled and are now used for newer
options. See the list of constants in this document for options
Net::SSLeay currently supports. You are strongly encouraged to
<strong>check your TLS library</strong> if you need to use numeric
values directly. The following is a sample of historic values. It may
not be correct anymore. #to decode the return value (bitmask) use:
0x00000004 corresponds to SSL_OP_LEGACY_SERVER_CONNECT 0x00000800
corresponds to SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS 0x00004000 corresponds
to SSL_OP_NO_TICKET 0x00010000 corresponds to
SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION 0x00400000 corresponds to
SSL_OP_CIPHER_SERVER_PREFERENCE 0x04000000 corresponds to
SSL_OP_NO_TLSv1 Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_options.html&gt;</p></li>
<li><p>CTX_set_options Adds the options set via bitmask in
<code>$options</code> to ctx. Options already set before are not
cleared. Net::SSLeay::CTX_set_options($ctx, $options); # $ctx - value
corresponding to openssls SSL_CTX structure # $options - options bitmask
# # returns: the new options bitmask after adding $options For bitmask
details see CTX_get_options (above). Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_options.html&gt;</p></li>
<li><p>CTX_get_quiet_shutdown Returns the 'quiet shutdown' setting of
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_get_quiet_shutdown($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
(integer) the current setting Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p></li>
<li><p>CTX_get_read_ahead my $rv =
Net::SSLeay::CTX_get_read_ahead($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: (integer) read_ahead
value</p></li>
<li><p>CTX_get_session_cache_mode Returns the currently used cache mode
(bitmask). my $rv = Net::SSLeay::CTX_get_session_cache_mode($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
mode (bitmask) <strong>BEWARE:</strong> SESS_CACHE_OFF and other
constants are not available in Net-SSLeay-1.82 and before. If the
constants are not available, the following values have historically been
correct. You are strongly encouraged to <strong>check your TLS
library</strong> for the current values. #to decode the return value
(bitmask) use: 0x0000 corresponds to SSL_SESS_CACHE_OFF 0x0001
corresponds to SSL_SESS_CACHE_CLIENT 0x0002 corresponds to
SSL_SESS_CACHE_SERVER 0x0080 corresponds to SSL_SESS_CACHE_NO_AUTO_CLEAR
0x0100 corresponds to SSL_SESS_CACHE_NO_INTERNAL_LOOKUP 0x0200
corresponds to SSL_SESS_CACHE_NO_INTERNAL_STORE (note: some of the bits
might not be supported by older openssl versions) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_cache_mode.html&gt;</p></li>
<li><p>CTX_set_session_cache_mode Enables/disables session caching by
setting the operational mode for <code>$ctx</code> to
<code>$mode</code>. my $rv =
Net::SSLeay::CTX_set_session_cache_mode($ctx, $mode); # $ctx - value
corresponding to openssls SSL_CTX structure # $mode - mode (bitmask) # #
returns: previously set cache mode For bitmask details see
CTX_get_session_cache_mode (above). Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_cache_mode.html&gt;</p></li>
<li><p>CTX_get_timeout Returns the currently set timeout value for
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_get_timeout($ctx); # $ctx -
value corresponding to openssls SSL_CTX structure # # returns: timeout
in seconds Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html&gt;</p></li>
<li><p>CTX_get_verify_depth Returns the verification depth limit
currently set in <code>$ctx</code>. If no limit has been explicitly set,
-1 is returned and the default value will be used. my $rv =
Net::SSLeay::CTX_get_verify_depth($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: depth limit currently set in
$ctx, -1 if no limit has been explicitly set Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p></li>
<li><p>CTX_get_verify_mode Returns the verification mode (bitmask)
currently set in <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_get_verify_mode($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: mode (bitmask) For bitmask
details see CTX_set_verify. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_verify_mode.html&gt;</p></li>
<li><p>CTX_set_verify Sets the verification flags for <code>$ctx</code>
to be <code>$mode</code> and specifies the verify_callback function to
be used. Net::SSLeay::CTX_set_verify($ctx, $mode, $callback); # $ctx -
value corresponding to openssls SSL_CTX structure # $mode - mode
(bitmask), see OpenSSL manual # $callback - [optional] reference to perl
callback function # # returns: no return value Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_verify.html&gt;</p></li>
<li><p>CTX_set_post_handshake_auth <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.1, not in LibreSSL Enable the Post-Handshake Authentication
extension to be added to the ClientHello such that post-handshake
authentication can be requested by the server.
Net::SSLeay::CTX_set_posthandshake_auth($ctx, $val); # $ctx - value
corresponding to openssls SSL_CTX structure # $val - 0 then the
extension is not sent, otherwise it is # # returns: no return value
Check openssl doc
https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_post_handshake_auth.html&gt;</p></li>
<li><p>CTX_load_verify_locations Specifies the locations for
<code>$ctx</code>, at which CA certificates for verification purposes
are located. The certificates available via <code>$CAfile</code> and
<code>$CApath</code> are trusted. my $rv =
Net::SSLeay::CTX_load_verify_locations($ctx, $CAfile, $CApath); # $ctx -
value corresponding to openssls SSL_CTX structure # $CAfile - (string)
file of CA certificates in PEM format, the file can contain several CA
certificates (or ) # $CApath - (string) directory containing CA
certificates in PEM format (or ) # # returns: 1 on success, 0 on failure
(check the error stack to find out the reason) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_load_verify_locations.html&gt;</p></li>
<li><p>CTX_need_tmp_RSA Return the result of
<code>SSL_CTX_ctrl(ctx,SSL_CTRL_NEED_TMP_RSA,0,NULL)</code> my $rv =
Net::SSLeay::CTX_need_tmp_RSA($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: result of SSL_CTRL_NEED_TMP_RSA
command Not available with OpenSSL 1.1 and later.</p></li>
<li><p>CTX_new The same as CTX_v23_new my $rv = Net::SSLeay::CTX_new();
# # returns: value corresponding to openssls SSL_CTX structure (0 on
failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt; Not available
with OpenSSL 1.1 and later.</p></li>
<li><p>CTX_v2_new Creates a new SSL_CTX object - based on
<strong>SSLv2_method()</strong> - as framework to establish TLS/SSL
enabled connections. my $rv = Net::SSLeay::CTX_v2_new(); # # returns:
value corresponding to openssls SSL_CTX structure (0 on
failure)</p></li>
<li><p>CTX_v23_new Creates a new SSL_CTX object - based on
<strong>SSLv23_method()</strong> - as framework to establish TLS/SSL
enabled connections. my $rv = Net::SSLeay::CTX_v23_new(); # # returns:
value corresponding to openssls SSL_CTX structure (0 on
failure)</p></li>
<li><p>CTX_v3_new Creates a new SSL_CTX object - based on
<strong>SSLv3_method()</strong> - as framework to establish TLS/SSL
enabled connections. my $rv = Net::SSLeay::CTX_v3_new(); # # returns:
value corresponding to openssls SSL_CTX structure (0 on
failure)</p></li>
<li><p>CTX_tlsv1_new Creates a new SSL_CTX object - based on
<strong>TLSv1_method()</strong> - as framework to establish TLS/SSL
enabled connections. my $rv = Net::SSLeay::CTX_tlsv1_new(); # # returns:
value corresponding to openssls SSL_CTX structure (0 on
failure)</p></li>
<li><p>CTX_tlsv1_1_new Creates a new SSL_CTX object - based on
<strong>TLSv1_1_method()</strong> - as framework to establish TLS/SSL
enabled connections. Only available where supported by the underlying
openssl. my $rv = Net::SSLeay::CTX_tlsv1_1_new(); # # returns: value
corresponding to openssls SSL_CTX structure (0 on failure)</p></li>
<li><p>CTX_tlsv1_2_new Creates a new SSL_CTX object - based on
<strong>TLSv1_2_method()</strong> - as framework to establish TLS/SSL
enabled connections. Only available where supported by the underlying
openssl. my $rv = Net::SSLeay::CTX_tlsv1_2_new(); # # returns: value
corresponding to openssls SSL_CTX structure (0 on failure)</p></li>
<li><p>CTX_new_with_method Creates a new SSL_CTX object based on
<code>$meth</code> method my $rv =
Net::SSLeay::CTX_new_with_method($meth); # $meth - value corresponding
to openssls SSL_METHOD structure # # returns: value corresponding to
openssls SSL_CTX structure (0 on failure) #example my $ctx =
Net::SSLeay::CTX_new_with_method(&amp;Net::SSLeay::TLSv1_method); Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_new.html&gt;</p></li>
<li><p>CTX_set_min_proto_version, CTX_set_max_proto_version,
set_min_proto_version and set_max_proto_version,
<strong>COMPATIBILITY:</strong> not available in Net-SSLeay-1.82 and
before; requires at least OpenSSL 1.1.0-pre2 or LibreSSL 2.6.0 Set the
minimum and maximum supported protocol for <code>$ctx</code> or
<code>$ssl</code>. my $rv = Net::SSLeay::CTX_set_min_proto_version($ctx,
$version) # $ctx - value corresponding to openssls SSL_CTX structure #
$version - (integer) constat version value or 0 for automatic lowest or
highest value # # returns: 1 on success, 0 on failure #example: allow
only TLS 1.2 for a SSL_CTX my $rv_min =
Net::SSLeay::CTX_set_min_proto_version($ctx,
Net::SSLeay::TLS1_2_VERSION()); my $rv_max =
Net::SSLeay::CTX_set_max_proto_version($ctx,
Net::SSLeay::TLS1_2_VERSION()); #example: allow only TLS 1.1 for a SSL
my $rv_min = Net::SSLeay::set_min_proto_version($ssl,
Net::SSLeay::TLS1_1_VERSION()); my $rv_max =
Net::SSLeay::set_max_proto_version($ssl, Net::SSLeay::TLS1_1_VERSION());
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html&gt;</p></li>
<li><p>CTX_get_min_proto_version, CTX_get_max_proto_version,
get_min_proto_version and get_max_proto_version,
<strong>COMPATIBILITY:</strong> not available in Net-SSLeay-1.82 and
before; requires at least OpenSSL 1.1.0g Get the minimum and maximum
supported protocol for <code>$ctx</code> or <code>$ssl</code>. my
$version = Net::SSLeay::CTX_get_min_proto_version($ctx) # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: 0 automatic
lowest or highest value, configured value otherwise Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_min_proto_version.html&gt;</p></li>
<li><p>CTX_remove_session Removes the session <code>$ses</code> from the
context <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_remove_session($ctx, $ses); # $ctx - value
corresponding to openssls SSL_CTX structure # $ses - value corresponding
to openssls SSL_SESSION structure # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_add_session.html&gt;</p></li>
<li><p>CTX_sess_accept my $rv = Net::SSLeay::CTX_sess_accept($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
number of started SSL/TLS handshakes in server mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_accept_good my $rv =
Net::SSLeay::CTX_sess_accept_good($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: number of successfully
established SSL/TLS sessions in server mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_accept_renegotiate my $rv =
Net::SSLeay::CTX_sess_accept_renegotiate($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: number of start
renegotiations in server mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_cache_full my $rv =
Net::SSLeay::CTX_sess_cache_full($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: number of sessions that were
removed because the maximum session cache size was exceeded Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_cb_hits my $rv = Net::SSLeay::CTX_sess_cb_hits($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
number of successfully retrieved sessions from the external session
cache in server mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_connect my $rv = Net::SSLeay::CTX_sess_connect($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
number of started SSL/TLS handshakes in client mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_connect_good my $rv =
Net::SSLeay::CTX_sess_connect_good($ctx); # $ctx - value corresponding
to openssls SSL_CTX structure # # returns: number of successfully
established SSL/TLS sessions in client mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_connect_renegotiate my $rv =
Net::SSLeay::CTX_sess_connect_renegotiate($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: number of start
renegotiations in client mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_get_cache_size Returns the currently valid session cache
size. my $rv = Net::SSLeay::CTX_sess_get_cache_size($ctx); # $ctx -
value corresponding to openssls SSL_CTX structure # # returns: current
size Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_set_cache_size.html&gt;</p></li>
<li><p>CTX_sess_hits my $rv = Net::SSLeay::CTX_sess_hits($ctx); # $ctx -
value corresponding to openssls SSL_CTX structure # # returns: number of
successfully reused sessions Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_misses my $rv = Net::SSLeay::CTX_sess_misses($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
number of sessions proposed by clients that were not found in the
internal session cache in server mode Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_number my $rv = Net::SSLeay::CTX_sess_number($ctx); #
$ctx - value corresponding to openssls SSL_CTX structure # # returns:
current number of sessions in the internal session cache Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_set_cache_size Sets the size of the internal session
cache of context <code>$ctx</code> to <code>$size</code>.
Net::SSLeay::CTX_sess_set_cache_size($ctx, $size); # $ctx - value
corresponding to openssls SSL_CTX structure # $size - cache size (0 =
unlimited) # # returns: previously valid size Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_set_cache_size.html&gt;</p></li>
<li><p>CTX_sess_timeouts Returns the number of sessions proposed by
clients and either found in the internal or external session cache in
server mode, but that were invalid due to timeout. These sessions are
not included in the SSL_CTX_sess_hits count. my $rv =
Net::SSLeay::CTX_sess_timeouts($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: number of sessions Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sess_number.html&gt;</p></li>
<li><p>CTX_sess_set_new_cb <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.85 and before Sets the callback function, which is
automatically called whenever a new session was negotiated.
Net::SSLeay::CTX_sess_set_new_cb($ctx, $func); # $ctx - value
corresponding to openssls SSL_CTX structure # $func - perl reference to
callback function # # returns: no return value Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_new_cb.html&gt;</p></li>
<li><p>CTX_sess_set_remove_cb <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before Sets the callback function,
which is automatically called whenever a session is removed by the SSL
engine. Net::SSLeay::CTX_sess_set_remove_cb($ctx, $func); # $ctx - value
corresponding to openssls SSL_CTX structure # $func - perl reference to
callback function # # returns: no return value Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_sess_set_remove_cb.html&gt;</p></li>
<li><p>CTX_sessions Returns a pointer to the lhash databases containing
the internal session cache for ctx. my $rv =
Net::SSLeay::CTX_sessions($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: value corresponding to openssls
LHASH structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_sessions.html&gt;</p></li>
<li><p>CTX_set1_param <strong>COMPATIBILITY:</strong> requires at least
OpenSSL 1.0.0-beta3 Applies X509 verification parameters
<code>$vpm</code> on <code>$ctx</code> my $rv =
Net::SSLeay::CTX_set1_param($ctx, $vpm); # $ctx - value corresponding to
openssls SSL_CTX structure # $vpm - value corresponding to openssls
X509_VERIFY_PARAM structure # # returns: 1 on success, 0 on failure
Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p></li>
<li><p>CTX_set_cert_store Sets/replaces the certificate verification
storage of <code>$ctx</code> to/with <code>$store</code>.
Net::SSLeay::CTX_set_cert_store($ctx, $store); # $ctx - value
corresponding to openssls SSL_CTX structure # $store - value
corresponding to openssls X509_STORE structure # # returns: no return
value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_store.html&gt;</p></li>
<li><p>CTX_set_cert_verify_callback Sets the verification callback
function for <code>$ctx</code>. SSL objects that are created from
<code>$ctx</code> inherit the setting valid at the time when
<code>Net::SSLeay::new($ctx)</code> is called.
Net::SSLeay::CTX_set_cert_verify_callback($ctx, $func, $data); # $ctx -
value corresponding to openssls SSL_CTX structure # $func - perl
reference to callback function # $data - [optional] data that will be
passed to callback function when invoked # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cert_verify_callback.html&gt;</p></li>
<li><p>CTX_set_cipher_list Sets the list of available ciphers for
<code>$ctx</code> using the control string <code>$str</code>. The list
of ciphers is inherited by all ssl objects created from
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_set_cipher_list($s, $str);
# $s - value corresponding to openssls SSL_CTX structure # $str -
(string) cipher list e.g. 3DES:+RSA # # returns: 1 if any cipher could
be selected and 0 on complete failure The format of <code>$str</code> is
described in
&lt;https://www.openssl.org/docs/manmaster/man1/openssl-ciphers.html&gt;
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_cipher_list.html&gt;</p></li>
<li><p>CTX_set_ciphersuites <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.1, not in LibreSSL Configure the available TLSv1.3 ciphersuites. my
$rv = Net::SSLeay::CTX_set_ciphersuites($ctx, $str); # $ctx - value
corresponding to openssls SSL_CTX structure # $str - colon (":")
separated list of TLSv1.3 ciphersuite names in order of preference # #
returns: (integer) 1 if the requested ciphersuite list was configured,
and 0 otherwise Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_ciphersuites.html&gt;</p></li>
<li><p>CTX_set_client_CA_list Sets the list of CAs sent to the client
when requesting a client certificate for <code>$ctx</code>.
Net::SSLeay::CTX_set_client_CA_list($ctx, $list); # $ctx - value
corresponding to openssls SSL_CTX structure # $list - value
corresponding to openssls X509_NAME_STACK structure # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p></li>
<li><p>CTX_set_default_passwd_cb Sets the default password callback
called when loading/storing a PEM certificate with encryption.
Net::SSLeay::CTX_set_default_passwd_cb($ctx, $func); # $ctx - value
corresponding to openssls SSL_CTX structure # $func - perl reference to
callback function # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p></li>
<li><p>CTX_set_default_passwd_cb_userdata Sets a pointer to userdata
which will be provided to the password callback on invocation.
Net::SSLeay::CTX_set_default_passwd_cb_userdata($ctx, $userdata); # $ctx
- value corresponding to openssls SSL_CTX structure # $userdata - data
that will be passed to callback function when invoked # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p></li>
<li><p>CTX_set_default_verify_paths ??? (more info needed) my $rv =
Net::SSLeay::CTX_set_default_verify_paths($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: 1 on success, 0
on failure</p></li>
<li><p>CTX_set_ex_data Is used to store application data at
<code>$data</code> for <code>$idx</code> into the <code>$ctx</code>
object. my $rv = Net::SSLeay::CTX_set_ex_data($ssl, $idx, $data); # $ssl
- value corresponding to openssls SSL_CTX structure # $idx - (integer)
??? # $data - (pointer) ??? # # returns: 1 on success, 0 on failure
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_ex_new_index.html&gt;</p></li>
<li><p>CTX_set_purpose my $rv = Net::SSLeay::CTX_set_purpose($s,
$purpose); # $s - value corresponding to openssls SSL_CTX structure #
$purpose - (integer) purpose identifier # # returns: 1 on success, 0 on
failure #avainable purpose identifier 1 - X509_PURPOSE_SSL_CLIENT 2 -
X509_PURPOSE_SSL_SERVER 3 - X509_PURPOSE_NS_SSL_SERVER 4 -
X509_PURPOSE_SMIME_SIGN 5 - X509_PURPOSE_SMIME_ENCRYPT 6 -
X509_PURPOSE_CRL_SIGN 7 - X509_PURPOSE_ANY 8 - X509_PURPOSE_OCSP_HELPER
9 - X509_PURPOSE_TIMESTAMP_SIGN #or use corresponding constants $purpose
= &amp;Net::SSLeay::X509_PURPOSE_SSL_CLIENT; ... $purpose =
&amp;Net::SSLeay::X509_PURPOSE_TIMESTAMP_SIGN;</p></li>
<li><p>CTX_set_quiet_shutdown Sets the 'quiet shutdown' flag for
<code>$ctx</code> to be mode. SSL objects created from <code>$ctx</code>
inherit the mode valid at the time <code>Net::SSLeay::new($ctx)</code>
is called. Net::SSLeay::CTX_set_quiet_shutdown($ctx, $mode); # $ctx -
value corresponding to openssls SSL_CTX structure # $mode - 0 or 1 # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p></li>
<li><p>CTX_set_read_ahead my $rv = Net::SSLeay::CTX_set_read_ahead($ctx,
$val); # $ctx - value corresponding to openssls SSL_CTX structure # $val
- read_ahead value to be set # # returns: the original read_ahead
value</p></li>
<li><p>CTX_set_session_id_context Sets the context <code>$sid_ctx</code>
of length <code>$sid_ctx_len</code> within which a session can be reused
for the <code>$ctx</code> object. my $rv =
Net::SSLeay::CTX_set_session_id_context($ctx, $sid_ctx, $sid_ctx_len); #
$ctx - value corresponding to openssls SSL_CTX structure # $sid_ctx -
data buffer # $sid_ctx_len - length of data in $sid_ctx # # returns: 1
on success, 0 on failure (the error is logged to the error stack) Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html&gt;</p></li>
<li><p>CTX_set_ssl_version Sets a new default TLS/SSL method for SSL
objects newly created from this <code>$ctx</code>. SSL objects already
created with <code>Net::SSLeay::new($ctx)</code> are not affected,
except when <code>Net::SSLeay:clear($ssl)</code> is being called. my $rv
= Net::SSLeay::CTX_set_ssl_version($ctx, $meth); # $ctx - value
corresponding to openssls SSL_CTX structure # $meth - value
corresponding to openssls SSL_METHOD structure # # returns: 1 on
success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p></li>
<li><p>CTX_set_timeout Sets the timeout for newly created sessions for
<code>$ctx</code> to <code>$t</code>. The timeout value <code>$t</code>
must be given in seconds. my $rv = Net::SSLeay::CTX_set_timeout($ctx,
$t); # $ctx - value corresponding to openssls SSL_CTX structure # $t -
timeout in seconds # # returns: previously set timeout value Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_timeout.html&gt;</p></li>
<li><p>CTX_set_tmp_dh Sets DH parameters to be used to be
<code>$dh</code>. The key is inherited by all ssl objects created from
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_set_tmp_dh($ctx, $dh); #
$ctx - value corresponding to openssls SSL_CTX structure # $dh - value
corresponding to openssls DH structure # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p></li>
<li><p>CTX_set_tmp_dh_callback Sets the callback function for
<code>$ctx</code> to be used when a DH parameters are required to
<code>$tmp_dh_callback</code>.
Net::SSLeay::CTX_set_tmp_dh_callback($ctx, $tmp_dh_callback); # $ctx -
value corresponding to openssls SSL_CTX structure # tmp_dh_callback -
(function pointer) ??? # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p></li>
<li><p>CTX_set_tmp_rsa Sets the temporary/ephemeral RSA key to be used
to be <code>$rsa</code>. my $rv = Net::SSLeay::CTX_set_tmp_rsa($ctx,
$rsa); # $ctx - value corresponding to openssls SSL_CTX structure # $rsa
- value corresponding to openssls RSA structure # # returns: 1 on
success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;
Not available with OpenSSL 1.1 and later.</p></li>
<li><p>CTX_set_tmp_rsa_callback Sets the callback function for ctx to be
used when a temporary/ephemeral RSA key is required to
<code>$tmp_rsa_callback</code>. ??? (does this function really work?)
Net::SSLeay::CTX_set_tmp_rsa_callback($ctx, $tmp_rsa_callback); # $ctx -
value corresponding to openssls SSL_CTX structure # $tmp_rsa_callback -
(function pointer) ??? # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;
Not available with OpenSSL 1.1 and later.</p></li>
<li><p>CTX_set_trust my $rv = Net::SSLeay::CTX_set_trust($s, $trust); #
$s - value corresponding to openssls SSL_CTX structure # $trust -
(integer) trust identifier # # returns: the original value #available
trust identifiers 1 - X509_TRUST_COMPAT 2 - X509_TRUST_SSL_CLIENT 3 -
X509_TRUST_SSL_SERVER 4 - X509_TRUST_EMAIL 5 - X509_TRUST_OBJECT_SIGN 6
- X509_TRUST_OCSP_SIGN 7 - X509_TRUST_OCSP_REQUEST 8 - X509_TRUST_TSA
#or use corresponding constants $trust =
&amp;Net::SSLeay::X509_TRUST_COMPAT; ... $trust =
&amp;Net::SSLeay::X509_TRUST_TSA;</p></li>
<li><p>CTX_set_verify_depth Sets the maximum depth for the certificate
chain verification that shall be allowed for ctx.
Net::SSLeay::CTX_set_verify_depth($ctx, $depth); # $ctx - value
corresponding to openssls SSL_CTX structure # $depth - max. depth # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p></li>
<li><p>CTX_use_PKCS12_file Adds the certificate and private key from
PKCS12 file <code>$p12filename</code> to <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_use_PKCS12_file($ctx, $p12filename, $password); # $ctx
- value corresponding to openssls SSL_CTX structure # $p12filename -
(string) filename # $password - (string) password to decrypt private key
# # returns: 1 on success, 0 on failure</p></li>
<li><p>CTX_use_PrivateKey Adds the private key <code>$pkey</code> to
<code>$ctx</code>. my $rv = Net::SSLeay::CTX_use_PrivateKey($ctx,
$pkey); # $ctx - value corresponding to openssls SSL_CTX structure #
$pkey - value corresponding to openssls EVP_PKEY structure # # returns:
1 on success, otherwise check out the error stack to find out the reason
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_use_PrivateKey_file Adds the first private key found in
<code>$file</code> to <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_use_PrivateKey_file($ctx, $file, $type); # $ctx - value
corresponding to openssls SSL_CTX structure # $file - (string) file name
# $type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM
or &amp;Net::SSLeay::FILETYPE_ASN1 # # returns: 1 on success, otherwise
check out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_use_RSAPrivateKey Adds the RSA private key <code>$rsa</code>
to <code>$ctx</code>. my $rv = Net::SSLeay::CTX_use_RSAPrivateKey($ctx,
$rsa); # $ctx - value corresponding to openssls SSL_CTX structure # $rsa
- value corresponding to openssls RSA structure # # returns: 1 on
success, otherwise check out the error stack to find out the reason
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_use_RSAPrivateKey_file Adds the first RSA private key found
in <code>$file</code> to <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_use_RSAPrivateKey_file($ctx, $file, $type); # $ctx -
value corresponding to openssls SSL_CTX structure # $file - (string)
file name # $type - (integer) type - use constants
&amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1 # #
returns: 1 on success, otherwise check out the error stack to find out
the reason</p></li>
<li><p>CTX_use_certificate Loads the certificate <code>$x</code> into
<code>$ctx</code> my $rv = Net::SSLeay::CTX_use_certificate($ctx, $x); #
$ctx - value corresponding to openssls SSL_CTX structure # $x - value
corresponding to openssls X509 structure # # returns: 1 on success,
otherwise check out the error stack to find out the reason Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_use_certificate_chain_file Loads a certificate chain from
<code>$file</code> into <code>$ctx</code>. The certificates must be in
PEM format and must be sorted starting with the subject's certificate
(actual client or server certificate), followed by intermediate CA
certificates if applicable, and ending at the highest level (root) CA.
my $rv = Net::SSLeay::CTX_use_certificate_chain_file($ctx, $file); #
$ctx - value corresponding to openssls SSL_CTX structure # $file -
(string) file name # # returns: 1 on success, otherwise check out the
error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_use_certificate_file Loads the first certificate stored in
<code>$file</code> into <code>$ctx</code>. my $rv =
Net::SSLeay::CTX_use_certificate_file($ctx, $file, $type); # $ctx -
value corresponding to openssls SSL_CTX structure # $file - (string)
file name # $type - (integer) type - use constants
&amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1 # #
returns: 1 on success, otherwise check out the error stack to find out
the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>CTX_get_security_level <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.0, not in LibreSSL Returns the security level associated with
<code>$ctx</code>. my $level =
Net::SSLeay::CTX_get_security_level($ctx); # $ctx - value corresponding
to openssls SSL_CTX structure # # returns: (integer) current security
level Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_security_level.html&gt;</p></li>
<li><p>CTX_set_security_level <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.0, not in LibreSSL Sets the security level associated with
<code>$ctx</code> to <code>$level</code>.
Net::SSLeay::CTX_set_security_level($ctx, $level); # $ssl - value
corresponding to openssls SSL_CTX structure # $level - new security
level # # returns: no return value Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_security_level.html&gt;</p></li>
<li><p>CTX_set_num_tickets <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Set number of TLSv1.3 session tickets that will be sent to a
client. my $rv = Net::SSLeay::CTX_set_num_tickets($ctx,
$number_of_tickets); # $ctx - value corresponding to openssls SSL_CTX
structure # $number_of_tickets - number of tickets to send # # returns:
1 on success, 0 on failure Set to zero if you do not no want to support
a session resumption. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_num_tickets.html&gt;</p></li>
<li><p>CTX_get_num_tickets <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Get number of TLSv1.3 session tickets that will be sent to a
client. my $number_of_tickets = Net::SSLeay::CTX_get_num_tickets($ctx);
# $ctx - value corresponding to openssls SSL_CTX structure # # returns:
(integer) number of tickets to send Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_num_tickets.html&gt;</p></li>
<li><p>CTX_set_keylog_callback <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.90 and before; requires at least OpenSSL
1.1.1pre1, not in LibreSSL Set the TLS key logging callback.
Net::SSLeay::CTX_set_keylog_callback($ctx, $cb); # $ctx - value
corresponding to openssls SSL_CTX structure # $cb - reference to a perl
callback function # # returns: no return value The callback function
will be called like this: keylog_cb_func($ssl, $line); # $ssl - value
corresponding to OpenSSLs SSL object associated with the connection #
$line - a string containing the key material in the format used by NSS
for its SSLKEYLOGFILE debugging output Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_keylog_callback.html&gt;</p></li>
<li><p>CTX_get_keylog_callback <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.90 and before; requires at least OpenSSL
1.1.1pre1, not in LibreSSL Retrieve the previously set TLS key logging
callback. my $cb = Net::SSLeay::CTX_get_keylog_callback($ctx); # $ctx -
value corresponding to openssls SSL_CTX structure # # returns: a
reference to a perl callback function or undef if no callback is set
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_CTX_get_keylog_callback.html&gt;</p></li>
</ul>
<p><em>Low level API: SSL_* related functions</em></p>
<p><strong>NOTE:</strong> Please note that the function described in
this chapter have SSL_ part stripped from their original openssl
names.</p>
<ul>
<li><p>new Creates a new SSL structure which is needed to hold the data
for a TLS/SSL connection. The new structure inherits the settings of the
underlying context <code>$ctx:</code> connection method
(SSLv2/v3/TLSv1), options, verification settings, timeout settings. my
$rv = Net::SSLeay::new($ctx); # $ctx - value corresponding to openssls
SSL_CTX structure # # returns: value corresponding to openssls SSL
structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_new.html&gt;</p></li>
<li><p>accept Waits for a TLS/SSL client to initiate the TLS/SSL
handshake. The communication channel must already have been set and
assigned to the ssl by setting an underlying BIO. my $rv =
Net::SSLeay::accept($ssl); # $ssl - value corresponding to openssls SSL
structure # # returns: 1 = success, 0 = handshake not successful, &lt;0
= fatal error during handshake Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_accept.html&gt;</p></li>
<li><p>add_client_CA Adds the CA name extracted from cacert to the list
of CAs sent to the client when requesting a client certificate for the
chosen ssl, overriding the setting valid for ssl's SSL_CTX object. my
$rv = Net::SSLeay::add_client_CA($ssl, $x); # $ssl - value corresponding
to openssls SSL structure # $x - value corresponding to openssls X509
structure # # returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p></li>
<li><p>callback_ctrl ??? (more info needed) my $rv =
Net::SSLeay::callback_ctrl($ssl, $cmd, $fp); # $ssl - value
corresponding to openssls SSL structure # $cmd - (integer) command id #
$fp - (function pointer) ??? # # returns: ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p></li>
<li><p>check_private_key Checks the consistency of a private key with
the corresponding certificate loaded into <code>$ssl</code> my $rv =
Net::SSLeay::check_private_key($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: 1 on success, otherwise check out
the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>clear Reset SSL object to allow another connection.
Net::SSLeay::clear($ssl); # $ssl - value corresponding to openssls SSL
structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_clear.html&gt;</p></li>
<li><p>connect Initiate the TLS/SSL handshake with an TLS/SSL server. my
$rv = Net::SSLeay::connect($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: 1 = success, 0 = handshake not
successful, &lt;0 = fatal error during handshake Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_connect.html&gt;</p></li>
<li><p>copy_session_id Copies the session structure fro
<code>$from</code> to <code>$to</code> (+ also the private key and
certificate associated with <code>$from</code>).
Net::SSLeay::copy_session_id($to, $from); # $to - value corresponding to
openssls SSL structure # $from - value corresponding to openssls SSL
structure # # returns: no return value</p></li>
<li><p>ctrl Internal handling function for SSL objects.
<strong>BEWARE:</strong> openssl doc says: This function should never be
called directly! my $rv = Net::SSLeay::ctrl($ssl, $cmd, $larg, $parg); #
$ssl - value corresponding to openssls SSL structure # $cmd - (integer)
command id # $larg - (integer) long ??? # $parg - (string/pointer) ??? #
# returns: (long) result of given command ??? For more details about
valid <code>$cmd</code> values check CTX_ctrl. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_ctrl.html&gt;</p></li>
<li><p>do_handshake Will wait for a SSL/TLS handshake to take place. If
the connection is in client mode, the handshake will be started. The
handshake routines may have to be explicitly set in advance using either
SSL_set_connect_state or <strong>SSL_set_accept_state</strong>(3). my
$rv = Net::SSLeay::do_handshake($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: 1 = success, 0 = handshake not
successful, &lt;0 = fatal error during handshake Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_do_handshake.html&gt;</p></li>
<li><p>dup Returns a duplicate of <code>$ssl</code>. my $rv =
Net::SSLeay::dup($ssl); # $ssl - value corresponding to openssls SSL
structure # # returns: value corresponding to openssls SSL structure (0
on failure)</p></li>
<li><p>free Free an allocated SSL structure. Net::SSLeay::free($ssl); #
$ssl - value corresponding to openssls SSL structure # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_free.html&gt;</p></li>
<li><p>get0_param <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.82 and before; requires at least OpenSSL 1.0.2-beta1 or
LibreSSL 2.7.0 Returns the current verification parameters. my $vpm =
Net::SSLeay::get0_param($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: value corresponding to openssls
X509_VERIFY_PARAM structure Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CTX_get0_param.html&gt;</p></li>
<li><p>get_SSL_CTX Returns a pointer to the SSL_CTX object, from which
<code>$ssl</code> was created with Net::SSLeay::new. my $rv =
Net::SSLeay::get_SSL_CTX($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: value corresponding to openssls SSL_CTX
structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_SSL_CTX.html&gt;</p></li>
<li><p>set_SSL_CTX <strong>COMPATIBILITY:</strong> requires at least
OpenSSL 0.9.8f Sets the SSL_CTX the corresponds to an SSL session. my
$the_ssl_ctx = Net::SSLeay::set_SSL_CTX($ssl, $ssl_ctx); # $ssl - value
corresponding to openssls SSL structure # $ssl_ctx - Change the ssl
object to the given ssl_ctx # # returns - the ssl_ctx</p></li>
<li><p>get_app_data Can be used to get application defined value/data.
my $rv = Net::SSLeay::get_app_data($ssl); # $ssl - value corresponding
to openssls SSL structure # # returns: string/buffer/pointer
???</p></li>
<li><p>set_app_data Can be used to set some application defined
value/data. my $rv = Net::SSLeay::set_app_data($ssl, $arg); # $ssl -
value corresponding to openssls SSL structure # $arg -
(string/buffer/pointer ???) data # # returns: ???</p></li>
<li><p>get_certificate Gets X509 certificate from an established SSL
connection. my $rv = Net::SSLeay::get_certificate($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: value corresponding
to openssls X509 structure (0 on failure)</p></li>
<li><p>get_cipher Obtains the name of the currently used cipher. my $rv
= Net::SSLeay::get_cipher($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: (string) cipher name e.g.
DHE-RSA-AES256-SHA or , when no session has been established. Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt;</p></li>
<li><p>get_cipher_bits Obtain the number of secret/algorithm bits used.
my $rv = Net::SSLeay::get_cipher_bits($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: number of secret
bits used by current cipher Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt; and
&lt;http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;</p></li>
<li><p>get_ciphers <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.88 and before Returns a list of SSL_CIPHER structures
available for <code>$ssl</code> sorted by preference my @ciphers =
Net::SSLeay::get_ciphers($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: (list) SSL_CIPHER structures or nothing when
$ssl is undefined or no ciphers are available Example: my @ciphers =
Net::SSLeay::get_ciphers($ssl); foreach my $c (@ciphers) { print
Net::SSLeay::CIPHER_get_name($c) . "\n"; } Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_get_ciphers.html&gt;</p></li>
<li><p>get_cipher_list Returns the name (string) of the SSL_CIPHER
listed for <code>$ssl</code> with priority <code>$n</code>. my $rv =
Net::SSLeay::get_cipher_list($ssl, $n); # $ssl - value corresponding to
openssls SSL structure # $n - (integer) priority # # returns: (string)
cipher name e.g. EDH-DSS-DES-CBC3-SHA or undef in case of error Call
Net::SSLeay::get_cipher_list with priority starting from 0 to obtain the
sorted list of available ciphers, until undef is returned: my $priority
= 0; while (my $c = Net::SSLeay::get_cipher_list($ssl, $priority)) {
print "cipher[$priority] = $c\n"; $priority++; } Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_get_cipher_list.html&gt;</p></li>
<li><p>get_client_CA_list Returns the list of client CAs explicitly set
for <code>$ssl</code> using <code>Net::SSleay::set_client_CA_list</code>
or <code>$ssl</code>'s SSL_CTX object with
<code>Net::SSLeay::CTX_set_client_CA_list</code>, when in server mode.
In client mode, returns the list of client CAs sent from the server, if
any. my $rv = Net::SSLeay::get_client_CA_list($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: value corresponding
to openssls STACK_OF(X509_NAME) structure (0 on failure) Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_client_CA_list.html&gt;</p></li>
<li><p>get_current_cipher Returns the cipher actually used. my $rv =
Net::SSLeay::get_current_cipher($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: value corresponding to openssls
SSL_CIPHER structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_current_cipher.html&gt;</p></li>
<li><p>get_default_timeout Returns the default timeout value assigned to
SSL_SESSION objects negotiated for the protocol valid for
<code>$ssl</code>. my $rv = Net::SSLeay::get_default_timeout($ssl); #
$ssl - value corresponding to openssls SSL structure # # returns: (long)
timeout in seconds Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_default_timeout.html&gt;</p></li>
<li><p>get_error Returns a result code for a preceding call to
<code>connect</code>, <code>accept</code>, <code>do_handshake</code>,
<code>read</code>, <code>peek</code> or <code>write</code> on
<code>$ssl</code>. my $rv = Net::SSLeay::get_error($ssl, $ret); # $ssl -
value corresponding to openssls SSL structure # $ret - return value of
preceding TLS/SSL I/O operation # # returns: result code, which is one
of the following values: # 0 - SSL_ERROR_NONE # 1 - SSL_ERROR_SSL # 2 -
SSL_ERROR_WANT_READ # 3 - SSL_ERROR_WANT_WRITE # 4 -
SSL_ERROR_WANT_X509_LOOKUP # 5 - SSL_ERROR_SYSCALL # 6 -
SSL_ERROR_ZERO_RETURN # 7 - SSL_ERROR_WANT_CONNECT # 8 -
SSL_ERROR_WANT_ACCEPT Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_error.html&gt;</p></li>
<li><p>get_ex_data Is used to retrieve the information for
<code>$idx</code> from <code>$ssl</code>. my $rv =
Net::SSLeay::get_ex_data($ssl, $idx); # $ssl - value corresponding to
openssls SSL structure # $idx - (integer) index for application specific
data # # returns: pointer to ??? Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p></li>
<li><p>set_ex_data Is used to store application data at
<code>$data</code> for <code>$idx</code> into the <code>$ssl</code>
object. my $rv = Net::SSLeay::set_ex_data($ssl, $idx, $data); # $ssl -
value corresponding to openssls SSL structure # $idx - (integer) ??? #
$data - (pointer) ??? # # returns: 1 on success, 0 on failure Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p></li>
<li><p>get_ex_new_index Is used to register a new index for application
specific data. my $rv = Net::SSLeay::get_ex_new_index($argl, $argp,
$new_func, $dup_func, $free_func); # $argl - (long) ??? # $argp -
(pointer) ??? # $new_func - function pointer ??? (CRYPTO_EX_new *) #
$dup_func - function pointer ??? (CRYPTO_EX_dup *) # $free_func -
function pointer ??? (CRYPTO_EX_free *) # # returns: (integer) ??? Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_ex_new_index.html&gt;</p></li>
<li><p>get_fd Returns the file descriptor which is linked to
<code>$ssl</code>. my $rv = Net::SSLeay::get_fd($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: file descriptor
(&gt;=0) or -1 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_fd.html&gt;</p></li>
<li><p>get_finished Obtains the latest 'Finished' message sent to the
peer. Return value is zero if there's been no Finished message yet.
Default count is 2*EVP_MAX_MD_SIZE that is long enough for all possible
Finish messages. If you supply a non-default count, the resulting return
value may be longer than returned buf's length. my $rv =
Net::SSLeay::get_finished($ssl, $buf, $count); # $ssl - value
corresponding to openssls SSL structure # $buf - buffer where the
returned data will be stored # $count - [optional] max size of return
data - default is 2*EVP_MAX_MD_SIZE # # returns: length of latest
Finished message</p></li>
<li><p>get_peer_finished Obtains the latest 'Finished' message expected
from the peer. Parameters and return value are similar to
<strong>get_finished()</strong>. my $rv =
Net::SSLeay::get_peer_finished($ssl, $buf, $count); # $ssl - value
corresponding to openssls SSL structure # $buf - buffer where the
returned data will be stored # $count - [optional] max size of return
data - default is 2*EVP_MAX_MD_SIZE # # returns: length of latest
Finished message</p></li>
<li><p>get_keyblock_size Gets the length of the TLS keyblock.
<strong>NOTE:</strong> Does not exactly correspond to any low level API
function. my $rv = Net::SSLeay::get_keyblock_size($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: keyblock size, -1
on error</p></li>
<li><p>get_mode Returns the mode (bitmask) set for <code>$ssl</code>. my
$rv = Net::SSLeay::get_mode($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: mode (bitmask) To decode the return
value (bitmask) see documentation for CTX_get_mode. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p></li>
<li><p>set_mode Adds the mode set via bitmask in <code>$mode</code> to
<code>$ssl</code>. Options already set before are not cleared. my $rv =
Net::SSLeay::set_mode($ssl, $mode); # $ssl - value corresponding to
openssls SSL structure # $mode - mode (bitmask) # # returns: the new
mode bitmask after adding $mode For <code>$mode</code> bitmask details
see CTX_get_mode. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_mode.html&gt;</p></li>
<li><p>get_options Returns the options (bitmask) set for
<code>$ssl</code>. my $rv = Net::SSLeay::get_options($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: options
(bitmask) To decode the return value (bitmask) see documentation for
CTX_get_options. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html&gt;</p></li>
<li><p>set_options Adds the options set via bitmask in
<code>$options</code> to <code>$ssl</code>. Options already set before
are not cleared! Net::SSLeay::set_options($ssl, $options); # $ssl -
value corresponding to openssls SSL structure # $options - options
(bitmask) # # returns: the new options bitmask after adding $options For
<code>$options</code> bitmask details see CTX_get_options. Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html&gt;</p></li>
<li><p>get_peer_certificate Get the X509 certificate of the peer. my $rv
= Net::SSLeay::get_peer_certificate($ssl); # $ssl - value corresponding
to openssls SSL structure # # returns: value corresponding to openssls
X509 structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_peer_certificate.html&gt;</p></li>
<li><p>get_peer_cert_chain Get the certificate chain of the peer as an
array of X509 structures. my @rv =
Net::SSLeay::get_peer_cert_chain($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: list of X509 structures Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_peer_certificate.html&gt;</p></li>
<li><p>get_quiet_shutdown Returns the 'quiet shutdown' setting of ssl.
my $rv = Net::SSLeay::get_quiet_shutdown($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: (integer) current
quiet shutdown value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p></li>
<li><p>get_rbio Get 'read' BIO linked to an SSL object
<code>$ssl</code>. my $rv = Net::SSLeay::get_rbio($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: value corresponding
to openssls BIO structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_rbio.html&gt;</p></li>
<li><p>get_read_ahead my $rv = Net::SSLeay::get_read_ahead($ssl); # $ssl
- value corresponding to openssls SSL structure # # returns: (integer)
read_ahead value</p></li>
<li><p>set_read_ahead Net::SSLeay::set_read_ahead($ssl, $val); # $ssl -
value corresponding to openssls SSL structure # $val - read_ahead value
to be set # # returns: the original read_ahead value</p></li>
<li><p>get_security_level <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in
LibreSSL Returns the security level associated with <code>$ssl</code>.
my $level = Net::SSLeay::get_security_level($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: (integer) current
security level Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_security_level.html&gt;</p></li>
<li><p>set_security_level <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in
LibreSSL Sets the security level associated with <code>$ssl</code> to
<code>$level</code>. Net::SSLeay::set_security_level($ssl, $level); #
$ssl - value corresponding to openssls SSL structure # $level - new
security level # # returns: no return value Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_security_level.html&gt;</p></li>
<li><p>set_num_tickets <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Set number of TLSv1.3 session tickets that will be sent to a
client. my $rv = Net::SSLeay::set_num_tickets($ssl, $number_of_tickets);
# $ssl - value corresponding to openssls SSL structure #
$number_of_tickets - number of tickets to send # # returns: 1 on
success, 0 on failure Set to zero if you do not no want to support a
session resumption. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_num_tickets.html&gt;</p></li>
<li><p>get_num_tickets <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Get number of TLSv1.3 session tickets that will be sent to a
client. my $number_of_tickets = Net::SSLeay::get_num_tickets($ctx); #
$ctx - value corresponding to openssls SSL structure # # returns: number
of tickets to send Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_num_tickets.html&gt;</p></li>
<li><p>get_server_random Returns internal SSLv3 server_random value.
Net::SSLeay::get_server_random($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: server_random value (binary
data)</p></li>
<li><p>get_client_random <strong>NOTE:</strong> Does not exactly
correspond to any low level API function Returns internal SSLv3
client_random value. Net::SSLeay::get_client_random($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: client_random
value (binary data)</p></li>
<li><p>export_keying_material Returns keying material based on the
string <code>$label</code> and optional <code>$context</code>. Note that
with TLSv1.2 and lower, empty context (empty string) and undefined
context (no value or 'undef') will return different values. my $out =
Net::SSLeay::export_keying_material($ssl, $olen, $label, $context); #
$ssl - value corresponding to openssls SSL structure # $olen - number of
bytes to return # $label - application specific label # $context -
[optional] context - default is undef for no context # # returns: keying
material (binary data) or undef on error Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_export_keying_material.html&gt;</p></li>
<li><p>get_session Retrieve TLS/SSL session data used in
<code>$ssl</code>. The reference count of the SSL_SESSION is NOT
incremented. my $rv = Net::SSLeay::get_session($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: value corresponding
to openssls SSL_SESSION structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_session.html&gt;</p></li>
<li><p>SSL_get0_session The alias for get_session (note that the name is
<code>SSL_get0_session</code> NOT <code>get0_session</code>). my $rv =
Net::SSLeay::SSL_get0_session();</p></li>
<li><p>get1_session Returns a pointer to the SSL_SESSION actually used
in <code>$ssl</code>. The reference count of the SSL_SESSION is
incremented by 1. my $rv = Net::SSLeay::get1_session($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: value
corresponding to openssls SSL_SESSION structure (0 on failure) Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_session.html&gt;</p></li>
<li><p>get_shared_ciphers Returns string with a list (colon ':'
separated) of ciphers shared between client and server within SSL
session <code>$ssl</code>. my $rv = Net::SSLeay::get_shared_ciphers() #
# returns: string like
ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES256-SHA:DHE-DSS-AES256-SHA:...</p></li>
<li><p>get_shutdown Returns the shutdown mode of <code>$ssl</code>. my
$rv = Net::SSLeay::get_shutdown($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: shutdown mode (bitmask) of ssl #to
decode the return value (bitmask) use: 0 - No shutdown setting, yet 1 -
SSL_SENT_SHUTDOWN 2 - SSL_RECEIVED_SHUTDOWN Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_shutdown.html&gt;</p></li>
<li><p>get_ssl_method Returns a function pointer to the TLS/SSL method
set in <code>$ssl</code>. my $rv = Net::SSLeay::get_ssl_method($ssl); #
$ssl - value corresponding to openssls SSL structure # # returns: value
corresponding to openssls SSL_METHOD structure (0 on failure) Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p></li>
<li><p>in_init, in_before, is_init_finished, in_connect_init,
in_accept_init <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before. Retrieve information about the handshake
state machine. All functions take <code>$ssl</code> as the only argument
and return 0 or 1. These functions are recommended over
<strong>get_state()</strong> and <strong>state()</strong>. my $rv =
Net::SSLeay::is_init_finished($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: All functions return 1 or 0 Check
openssl doc https://www.openssl.org/docs/ssl/SSL_in_init.html
&lt;http://www.openssl.org/docs/ssl/SSL_in_init.html&gt;</p></li>
<li><p>get_state <strong>COMPATIBILITY:</strong> OpenSSL 1.1.0 and later
use different constants which are not made available. Use
<strong>is_init_finished()</strong> and related functions instead.
Returns the SSL connection state. my $rv = Net::SSLeay::get_state($ssl);
# $ssl - value corresponding to openssls SSL structure # # returns:
(integer) state value # to decode the returned state check: # SSL_ST_*
constants in openssl/ssl.h # SSL2_ST_* constants in openssl/ssl2.h #
SSL23_ST_* constants in openssl/ssl23.h # SSL3_ST_* + DTLS1_ST_*
constants in openssl/ssl3.h</p></li>
<li><p>state Exactly the same as get_state. my $rv =
Net::SSLeay::state($ssl);</p></li>
<li><p>set_state Sets the SSL connection state.
Net::SSLeay::set_state($ssl,Net::SSLeay::SSL_ST_ACCEPT()); Not available
with OpenSSL 1.1 and later.</p></li>
<li><p>get_verify_depth Returns the verification depth limit currently
set in <code>$ssl</code>. my $rv = Net::SSLeay::get_verify_depth($ssl);
# $ssl - value corresponding to openssls SSL structure # # returns:
current depth or -1 if no limit has been explicitly set Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p></li>
<li><p>set_verify_depth Sets the maximum depth for the certificate chain
verification that shall be allowed for <code>$ssl</code>.
Net::SSLeay::set_verify_depth($ssl, $depth); # $ssl - value
corresponding to openssls SSL structure # $depth - (integer) depth # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p></li>
<li><p>get_verify_mode Returns the verification mode (bitmask) currently
set in <code>$ssl</code>. my $rv = Net::SSLeay::get_verify_mode($ssl); #
$ssl - value corresponding to openssls SSL structure # # returns: mode
(bitmask) To decode the return value (bitmask) see documentation for
CTX_get_verify_mode. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_get_verify_mode.html&gt;</p></li>
<li><p>set_verify Sets the verification flags for <code>$ssl</code> to
be <code>$mode</code> and specifies the <code>$verify_callback</code>
function to be used. Net::SSLeay::set_verify($ssl, $mode, $callback); #
$ssl - value corresponding to openssls SSL structure # $mode - mode
(bitmask) # $callback - [optional] reference to perl callback function #
# returns: no return value For <code>$mode</code> bitmask details see
CTX_get_verify_mode. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_verify.html&gt;</p></li>
<li><p>set_post_handshake_auth <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.1, not in LibreSSL Enable the Post-Handshake Authentication
extension to be added to the ClientHello such that post-handshake
authentication can be requested by the server.
Net::SSLeay::set_posthandshake_auth($ssl, $val); # $ssl - value
corresponding to openssls SSL structure # $val - 0 then the extension is
not sent, otherwise it is # # returns: no return value Check openssl doc
https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_post_handshake_auth.html&gt;</p></li>
<li><p>verify_client_post_handshake <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.85 and before; requires at least OpenSSL
1.1.1, not in LibreSSL verify_client_post_handshake causes a
CertificateRequest message to be sent by a server on the given ssl
connection. my $rv = Net::SSLeay::verify_client_post_handshake($ssl); #
$ssl - value corresponding to openssls SSL structure # # returns: 1 if
the request succeeded, and 0 if the request failed. The error stack can
be examined to determine the failure reason. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_verify_client_post_handshake.html&gt;</p></li>
<li><p>get_verify_result Returns the result of the verification of the
X509 certificate presented by the peer, if any. my $rv =
Net::SSLeay::get_verify_result($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: (integer) # 0 - X509_V_OK: ok # 2 -
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT: unable to get issuer certificate #
3 - X509_V_ERR_UNABLE_TO_GET_CRL: unable to get certificate CRL # 4 -
X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE: unable to decrypt
certificates signature # 5 - X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE:
unable to decrypt CRLs signature # 6 -
X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY: unable to decode issuer
public key # 7 - X509_V_ERR_CERT_SIGNATURE_FAILURE: certificate
signature failure # 8 - X509_V_ERR_CRL_SIGNATURE_FAILURE: CRL signature
failure # 9 - X509_V_ERR_CERT_NOT_YET_VALID: certificate is not yet
valid # 10 - X509_V_ERR_CERT_HAS_EXPIRED: certificate has expired # 11 -
X509_V_ERR_CRL_NOT_YET_VALID: CRL is not yet valid # 12 -
X509_V_ERR_CRL_HAS_EXPIRED: CRL has expired # 13 -
X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD: format error in certificates
notBefore field # 14 - X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD: format
error in certificates notAfter field # 15 -
X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD: format error in CRLs
lastUpdate field # 16 - X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD:
format error in CRLs nextUpdate field # 17 - X509_V_ERR_OUT_OF_MEM: out
of memory # 18 - X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT: self signed
certificate # 19 - X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN: self signed
certificate in certificate chain # 20 -
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY: unable to get local issuer
certificate # 21 - X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE: unable to
verify the first certificate # 22 - X509_V_ERR_CERT_CHAIN_TOO_LONG:
certificate chain too long # 23 - X509_V_ERR_CERT_REVOKED: certificate
revoked # 24 - X509_V_ERR_INVALID_CA: invalid CA certificate # 25 -
X509_V_ERR_PATH_LENGTH_EXCEEDED: path length constraint exceeded # 26 -
X509_V_ERR_INVALID_PURPOSE: unsupported certificate purpose # 27 -
X509_V_ERR_CERT_UNTRUSTED: certificate not trusted # 28 -
X509_V_ERR_CERT_REJECTED: certificate rejected # 29 -
X509_V_ERR_SUBJECT_ISSUER_MISMATCH: subject issuer mismatch # 30 -
X509_V_ERR_AKID_SKID_MISMATCH: authority and subject key identifier
mismatch # 31 - X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH: authority and
issuer serial number mismatch # 32 - X509_V_ERR_KEYUSAGE_NO_CERTSIGN:key
usage does not include certificate signing # 50 -
X509_V_ERR_APPLICATION_VERIFICATION: application verification failure
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_verify_result.html&gt;</p></li>
<li><p>set_verify_result Override result of peer certificate
verification. Net::SSLeay::set_verify_result($ssl, $v); # $ssl - value
corresponding to openssls SSL structure # $v - (integer) result value #
# returns: no return value For more info about valid return values see
get_verify_result Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_verify_result.html&gt;</p></li>
<li><p>get_wbio Get 'write' BIO linked to an SSL object
<code>$ssl</code>. my $rv = Net::SSLeay::get_wbio($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: value corresponding
to openssls BIO structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_get_rbio.html&gt;</p></li>
<li><p>load_client_CA_file Load X509 certificates from file (PEM
formatted). my $rv = Net::SSLeay::load_client_CA_file($file); # $file -
(string) file name # # returns: value corresponding to openssls
STACK_OF(X509_NAME) structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_load_client_CA_file.html&gt;</p></li>
<li><p>clear_num_renegotiations Executes
SSL_CTRL_CLEAR_NUM_RENEGOTIATIONS command on <code>$ssl</code>. my $rv =
Net::SSLeay::clear_num_renegotiations($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: command
result</p></li>
<li><p>need_tmp_RSA Executes SSL_CTRL_NEED_TMP_RSA command on
<code>$ssl</code>. my $rv = Net::SSLeay::need_tmp_RSA($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: command
result Not available with OpenSSL 1.1 and later.</p></li>
<li><p>num_renegotiations Executes SSL_CTRL_GET_NUM_RENEGOTIATIONS
command on <code>$ssl</code>. my $rv =
Net::SSLeay::num_renegotiations($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: command result</p></li>
<li><p>total_renegotiations Executes SSL_CTRL_GET_TOTAL_RENEGOTIATIONS
command on <code>$ssl</code>. my $rv =
Net::SSLeay::total_renegotiations($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: command result</p></li>
<li><p>peek Copies <code>$max</code> bytes from the specified
<code>$ssl</code> into the returned value. In contrast to the
<code>Net::SSLeay::read()</code> function, the data in the SSL buffer is
unmodified after the <strong>SSL_peek()</strong> operation.
Net::SSLeay::peek($ssl, $max); # $ssl - value corresponding to openssls
SSL structure # $max - [optional] max bytes to peek (integer) - default
is 32768 # # in scalar context: data read from the TLS/SSL connection,
undef on error # in list context: two-item array consisting of data read
(undef on error), # and return code from SSL_peek().</p></li>
<li><p>peek_ex <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Copies <code>$max</code> bytes from the specified
<code>$ssl</code> into the returned value. In contrast to the
<code>Net::SSLeay::read_ex()</code> function, the data in the SSL buffer
is unmodified after the <strong>SSL_peek_ex()</strong> operation.
my($got, $rv) = Net::SSLeay::peek_ex($ssl, $max); # $ssl - value
corresponding to openssls SSL structure # $max - [optional] max bytes to
peek (integer) - default is 32768 # # returns a list: two-item list
consisting of data read (undef on error), # and return code from
SSL_peek_ex(). Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_peek_ex.html&gt;</p></li>
<li><p>pending Obtain number of readable bytes buffered in
<code>$ssl</code> object. my $rv = Net::SSLeay::pending($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: the number of
bytes pending Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_pending.html&gt;</p></li>
<li><p>has_pending <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in
LibreSSL Returns 1 if <code>$ssl</code> has buffered data (whether
processed or unprocessed) and 0 otherwise. my $rv =
Net::SSLeay::has_pending($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: (integer) 1 or 0 Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_has_pending.html&gt;</p></li>
<li><p>read Tries to read <code>$max</code> bytes from the specified
<code>$ssl</code>. my $got = Net::SSLeay::read($ssl, $max); my($got,
$rv) = Net::SSLeay::read($ssl, $max); # $ssl - value corresponding to
openssls SSL structure # $max - [optional] max bytes to read (integer) -
default is 32768 # # returns: # in scalar context: data read from the
TLS/SSL connection, undef on error # in list context: two-item array
consisting of data read (undef on error), # and return code from
SSL_read(). Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_read.html&gt;</p></li>
<li><p>read_ex <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Tries to read <code>$max</code> bytes from the specified
<code>$ssl</code>. my($got, $rv) = Net::SSLeay::read_ex($ssl, $max); #
$ssl - value corresponding to openssls SSL structure # $max - [optional]
max bytes to read (integer) - default is 32768 # # returns a list:
two-item list consisting of data read (undef on error), # and return
code from SSL_read_ex(). Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_read_ex.html&gt;</p></li>
<li><p>renegotiate Turn on flags for renegotiation so that renegotiation
will happen my $rv = Net::SSLeay::renegotiate($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>rstate_string Returns a 2 letter string indicating the current
read state of the SSL object <code>$ssl</code>. my $rv =
Net::SSLeay::rstate_string($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: 2-letter string Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_rstate_string.html&gt;</p></li>
<li><p>rstate_string_long Returns a string indicating the current read
state of the SSL object ssl. my $rv =
Net::SSLeay::rstate_string_long($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: string with current state Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_rstate_string.html&gt;</p></li>
<li><p>session_reused Query whether a reused session was negotiated
during handshake. my $rv = Net::SSLeay::session_reused($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: 0 - new
session was negotiated; 1 - session was reused. Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_session_reused.html&gt;</p></li>
<li><p>set1_param <strong>COMPATIBILITY:</strong> requires at least
OpenSSL 1.0.0-beta3 Applies X509 verification parameters
<code>$vpm</code> on <code>$ssl</code> my $rv =
Net::SSLeay::set1_param($ssl, $vpm); # $ssl - value corresponding to
openssls SSL structure # $vpm - value corresponding to openssls
X509_VERIFY_PARAM structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>set_accept_state Sets <code>$ssl</code> to work in server mode.
Net::SSLeay::set_accept_state($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_connect_state.html&gt;</p></li>
<li><p>set_bio Connects the BIOs <code>$rbio</code> and
<code>$wbio</code> for the read and write operations of the TLS/SSL
(encrypted) side of <code>$ssl</code>. Net::SSLeay::set_bio($ssl, $rbio,
$wbio); # $ssl - value corresponding to openssls SSL structure # $rbio -
value corresponding to openssls BIO structure # $wbio - value
corresponding to openssls BIO structure # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_bio.html&gt;</p></li>
<li><p>set_cipher_list Sets the list of ciphers only for ssl. my $rv =
Net::SSLeay::set_cipher_list($ssl, $str); # $ssl - value corresponding
to openssls SSL structure # $str - (string) cipher list e.g. 3DES:+RSA #
# returns: 1 if any cipher could be selected and 0 on complete failure
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cipher_list.html&gt;</p></li>
<li><p>set_ciphersuites <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Configure the available TLSv1.3 ciphersuites. my $rv =
Net::SSLeay::set_ciphersuites($ssl, $str); # $ssl - value corresponding
to openssls SSL structure # $str - colon (":") separated list of TLSv1.3
ciphersuite names in order of preference # # returns: (integer) 1 if the
requested ciphersuite list was configured, and 0 otherwise Check openssl
doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_set_ciphersuites.html&gt;</p></li>
<li><p>set_client_CA_list Sets the list of CAs sent to the client when
requesting a client certificate for the chosen <code>$ssl</code>,
overriding the setting valid for <code>$ssl</code>'s SSL_CTX object. my
$rv = Net::SSLeay::set_client_CA_list($ssl, $list); # $ssl - value
corresponding to openssls SSL structure # $list - value corresponding to
openssls STACK_OF(X509_NAME) structure # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_client_CA_list.html&gt;</p></li>
<li><p>set_connect_state Sets <code>$ssl</code> to work in client mode.
Net::SSLeay::set_connect_state($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_connect_state.html&gt;</p></li>
<li><p>set_fd Sets the file descriptor <code>$fd</code> as the
input/output facility for the TLS/SSL (encrypted) side of
<code>$ssl</code>, <code>$fd</code> will typically be the socket file
descriptor of a network connection. my $rv = Net::SSLeay::set_fd($ssl,
$fd); # $ssl - value corresponding to openssls SSL structure # $fd -
(integer) file handle (got via perls fileno) # # returns: 1 on success,
0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p></li>
<li><p>set_psk_client_callback Sets the psk client callback.
Net::SSLeay::set_psk_client_callback($ssl, sub { my $hint = shift;
return ($identity, $key) } ); # $ssl - value corresponding to openssls
SSL structure # $hint - PSK identity hint send by the server # $identity
- PSK identity # $key - PSK key, hex string without the leading 0x, e.g.
deadbeef # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_psk_client_callback.html&gt;</p></li>
<li><p>set_rfd Sets the file descriptor <code>$fd</code> as the input
(read) facility for the TLS/SSL (encrypted) side of <code>$ssl</code>.
my $rv = Net::SSLeay::set_rfd($ssl, $fd); # $ssl - value corresponding
to openssls SSL structure # $fd - (integer) file handle (got via perls
fileno) # # returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p></li>
<li><p>set_wfd my $rv = Net::SSLeay::set_wfd($ssl, $fd); # $ssl - value
corresponding to openssls SSL structure # $fd - (integer) file handle
(got via perls fileno) # # returns: 1 on success, 0 on failure Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_fd.html&gt;</p></li>
<li><p>set_info_callback Sets the callback function, that can be used to
obtain state information for <code>$ssl</code> during connection setup
and use. When callback is undef, the callback setting currently valid
for ctx is used. Net::SSLeay::set_info_callback($ssl, $cb, [$data]); #
$ssl - value corresponding to openssls SSL structure # $cb - sub { my
($ssl,$where,$ret,$data) = @_; ... } # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_info_callback.html&gt;</p></li>
<li><p>CTX_set_info_callback Sets the callback function on ctx, that can
be used to obtain state information during ssl connection setup and use.
When callback is undef, an existing callback will be disabled.
Net::SSLeay::CTX_set_info_callback($ssl, $cb, [$data]); # $ssl - value
corresponding to openssls SSL structure # $cb - sub { my
($ssl,$where,$ret,$data) = @_; ... } # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_info_callback.html&gt;</p></li>
<li><p>set_msg_callback Sets the callback function, that can be used to
obtain protocol messages information for <code>$ssl</code> during
connection setup and use. When callback is undef, the callback setting
currently valid for ctx is used. Note that set_msg_callback_arg is not
provided as there is no need to explicitly set <code>$arg</code>, this
is handled by set_msg_callback. Net::SSLeay::set_msg_callback($ssl, $cb,
[$arg]); # $ssl - value corresponding to openssls SSL structure # $cb -
sub { my ($write_p,$version,$content_type,$buf,$len,$ssl,$arg) = @_; ...
} # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/manmaster/man3/SSL_set_msg_callback.html&gt;</p></li>
<li><p>CTX_set_msg_callback Sets the callback function on ctx, that can
be used to obtain protocol messages information for ssl connection setup
and use. When callback is undef, the existing callback will be disabled.
Note that CTX_set_msg_callback_arg is not provided as there is no need
to explicitly set <code>$arg</code>, this is handled by
CTX_set_msg_callback. Net::SSLeay::CTX_set_msg_callback($ssl, $cb,
[$arg]); # $ssl - value corresponding to openssls SSL structure # $cb -
sub { my ($write_p,$version,$content_type,$buf,$len,$ssl,$arg) = @_; ...
} # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/manmaster/man3/SSL_CTX_set_msg_callback.html&gt;</p></li>
<li><p>set_pref_cipher Sets the list of available ciphers for
<code>$ssl</code> using the control string <code>$str</code>. my $rv =
Net::SSLeay::set_pref_cipher($ssl, $str); # $ssl - value corresponding
to openssls SSL structure # $str - (string) cipher list e.g. 3DES:+RSA #
# returns: 1 if any cipher could be selected and 0 on complete failure
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_cipher_list.html&gt;</p></li>
<li><p>CTX_set_psk_client_callback Sets the psk client callback.
Net::SSLeay::CTX_set_psk_client_callback($ssl, sub { my $hint = shift;
return ($identity, $key) } ); # $ssl - value corresponding to openssls
SSL structure # $hint - PSK identity hint send by the server # $identity
- PSK identity # $key - PSK key, hex string without the leading 0x, e.g.
deadbeef # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_psk_client_callback.html&gt;</p></li>
<li><p>set_purpose my $rv = Net::SSLeay::set_purpose($ssl, $purpose); #
$ssl - value corresponding to openssls SSL structure # $purpose -
(integer) purpose identifier # # returns: 1 on success, 0 on failure For
more info about available <code>$purpose</code> identifiers see
CTX_set_purpose.</p></li>
<li><p>set_quiet_shutdown Sets the 'quiet shutdown' flag for
<code>$ssl</code> to be <code>$mode</code>.
Net::SSLeay::set_quiet_shutdown($ssl, $mode); # $ssl - value
corresponding to openssls SSL structure # $mode - 0 or 1 # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_quiet_shutdown.html&gt;</p></li>
<li><p>set_session Set a TLS/SSL session to be used during TLS/SSL
connect. my $rv = Net::SSLeay::set_session($to, $ses); # $to - value
corresponding to openssls SSL structure # $ses - value corresponding to
openssls SSL_SESSION structure # # returns: 1 on success, 0 on failure
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_session.html&gt;</p></li>
<li><p>set_session_id_context Sets the context <code>$sid_ctx</code> of
length <code>$sid_ctx_len</code> within which a session can be reused
for the <code>$ssl</code> object. my $rv =
Net::SSLeay::set_session_id_context($ssl, $sid_ctx, $sid_ctx_len); #
$ssl - value corresponding to openssls SSL structure # $sid_ctx - data
buffer # $sid_ctx_len - length of data in $sid_ctx # # returns: 1 on
success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_session_id_context.html&gt;</p></li>
<li><p>set_session_secret_cb Setup pre-shared secret session resumption
function. Net::SSLeay::set_session_secret_cb($ssl, $func, $data); # $ssl
- value corresponding to openssls SSL structure # $func - perl reference
to callback function # $data - [optional] data that will be passed to
callback function when invoked # # returns: no return value The callback
function will be called like: callback_function($secret, $ciphers,
$pref_cipher, $data); # $secret is the current master session key,
usually all 0s at the beginning of a session # $ciphers is ref to an
array of peer cipher names # $pref_cipher is a ref to an index into the
list of cipher names of # the preferred cipher. Set it if you want to
specify a preferred cipher # $data is the data passed to
set_session_secret_cb The callback function should return 1 if it likes
the suggested cipher (or has selected an alternative by setting
pref_cipher), else it should return 0 (in which case OpenSSL will select
its own preferred cipher). With OpenSSL 1.1 and later, callback_function
can change the master key for the session by altering
<code>$secret</code> and returning 1.</p></li>
<li><p>CTX_set_tlsext_ticket_getkey_cb Setup encryption for TLS session
tickets (stateless session reuse).
Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($ctx, $func, $data); # $ctx
- value corresponding to openssls SSL_CTX structure # $func - perl
reference to callback function # $data - [optional] data that will be
passed to callback function when invoked # # returns: no return value
The callback function will be called like: getkey($data,[$key_name])
-&gt; ($key,$current_key_name) # $data is the data passed to
set_session_secret_cb # $key_name is the name of the key OpenSSL has
extracted from the session ticket # $key is the requested key for ticket
encryption + HMAC # $current_key_name is the name for the currently
valid key OpenSSL will call the function without a key name if it
generates a new ticket. It then needs the callback to return the
encryption+HMAC key and an identifier (key name) for this key. When
OpenSSL gets a session ticket from the client it extracts the key name
and calls the callback with this name as argument. It then expects the
callback to return the encryption+HMAC key matching the requested key
name and and also the key name which should be used at the moment. If
the requested key name and the returned key name differ it means that
this session ticket was created with an expired key and need to be
renewed. In this case OpenSSL will call the callback again with no key
name to create a new session ticket based on the old one. The key must
be at least 32 byte of random data which can be created with RAND_bytes.
Internally the first 16 byte are used as key in AES-128 encryption while
the next 16 byte are used for the SHA-256 HMAC. The key name are binary
data and must be exactly 16 byte long. Example:
Net::SSLeay::RAND_bytes(my $oldkey,32); Net::SSLeay::RAND_bytes(my
$newkey,32); my $oldkey_name = pack("a16",oldsecret); my $newkey_name =
pack("a16",newsecret); my @keys = ( [ $newkey_name, $newkey ], # current
active key [ $oldkey_name, $oldkey ], # already expired );
Net::SSLeay::CTX_set_tlsext_ticket_getkey_cb($server2-&gt;_ctx, sub { my
($mykeys,$name) = @_; # return (current_key, current_key_name) if no
name given return ($mykeys-&gt;[0][1],$mykeys-&gt;[0][0]) if ! $name; #
return (matching_key, current_key_name) if we find a key matching # the
given name for(my $i = 0; $i&lt;@$mykeys; $i++) { next if $name ne
$mykeys-&gt;[$i][0]; return ($mykeys-&gt;[$i][1],$mykeys-&gt;[0][0]); }
# no matching key found return; },\@keys); This function is based on the
OpenSSL function SSL_CTX_set_tlsext_ticket_key_cb but provides a simpler
to use interface. For more information see
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tlsext_ticket_key_cb.html&gt;</p></li>
<li><p>set_session_ticket_ext_cb Setup callback for TLS session tickets
(stateless session reuse). Net::SSLeay::set_session_ticket_ext_cb($ssl,
$func, $data); # $ssl - value corresponding to openssls SSL structure #
$func - perl reference to callback function # $data - [optional] data
that will be passed to callback function when invoked # # returns: no
return value The callback function will be called like:
getticket($ssl,$ticket,$data) -&gt; $return_value # $ssl is a value
corresponding to openssls SSL structure # $ticket is a value of received
TLS session ticket (can also be empty) # $data is the data passed to
set_session_ticket_ext_cb # $return_value is either 0 (failure) or 1
(success) This function is based on the OpenSSL function
SSL_set_session_ticket_ext_cb.</p></li>
<li><p>set_session_ticket_ext Set TLS session ticket (stateless session
reuse). Net::SSLeay::set_session_ticket_ext($ssl, $ticket); # $ssl -
value corresponding to openssls SSL structure # $ticket - is a value of
TLS session ticket which client will send (can also be empty string) # #
returns: no return value The callback function will be called like:
getticket($ssl,$ticket,$data) -&gt; $return_value # $ssl is a value
corresponding to openssls SSL structure # $ticket is a value of received
TLS session ticket (can also be empty) # $data is the data passed to
set_session_ticket_ext_cb # $return_value is either 0 (failure) or 1
(success) This function is based on the OpenSSL function
SSL_set_session_ticket_ext_cb.</p></li>
<li><p>set_shutdown Sets the shutdown state of <code>$ssl</code> to
<code>$mode</code>. Net::SSLeay::set_shutdown($ssl, $mode); # $ssl -
value corresponding to openssls SSL structure # $mode - (integer)
shutdown mode: # 0 - No shutdown # 1 - SSL_SENT_SHUTDOWN # 2 -
SSL_RECEIVED_SHUTDOWN # 3 - SSL_RECEIVED_SHUTDOWN+SSL_SENT_SHUTDOWN # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_set_shutdown.html&gt;</p></li>
<li><p>set_ssl_method Sets a new TLS/SSL method for a particular
<code>$ssl</code> object. my $rv = Net::SSLeay::set_ssl_method($ssl,
$method); # $ssl - value corresponding to openssls SSL structure #
$method - value corresponding to openssls SSL_METHOD structure # #
returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_ssl_version.html&gt;</p></li>
<li><p>set_tmp_dh Sets DH parameters to be used to be <code>$dh</code>.
my $rv = Net::SSLeay::set_tmp_dh($ssl, $dh); # $ssl - value
corresponding to openssls SSL structure # $dh - value corresponding to
openssls DH structure # # returns: 1 on success, 0 on failure Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p></li>
<li><p>set_tmp_dh_callback Sets the callback function for
<code>$ssl</code> to be used when a DH parameters are required to
<code>$dh_cb</code>. ??? (does this function really work?)
Net::SSLeay::set_tmp_dh_callback($ssl, $dh); # $ssl - value
corresponding to openssls SSL structure # $dh_cb - pointer to function
??? # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_dh_callback.html&gt;</p></li>
<li><p>set_tmp_rsa Sets the temporary/ephemeral RSA key to be used in
<code>$ssl</code> to be <code>$rsa</code>. my $rv =
Net::SSLeay::set_tmp_rsa($ssl, $rsa); # $ssl - value corresponding to
openssls SSL structure # $rsa - value corresponding to openssls RSA
structure # # returns: 1 on success, 0 on failure Example: $rsakey =
Net::SSLeay::RSA_generate_key(); Net::SSLeay::set_tmp_rsa($ssl,
$rsakey); Net::SSLeay::RSA_free($rsakey); Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p></li>
<li><p>set_tmp_rsa_callback Sets the callback function for
<code>$ssl</code> to be used when a temporary/ephemeral RSA key is
required to <code>$tmp_rsa_callback</code>. ??? (does this function
really work?) Net::SSLeay::set_tmp_rsa_callback($ssl,
$tmp_rsa_callback); # $ssl - value corresponding to openssls SSL
structure # $tmp_rsa_callback - (function pointer) ??? # # returns: no
return value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_tmp_rsa_callback.html&gt;</p></li>
<li><p>set_trust my $rv = Net::SSLeay::set_trust($ssl, $trust); # $ssl -
value corresponding to openssls SSL structure # $trust - (integer) trust
identifier # # returns: the original value For more details about
<code>$trust</code> values see CTX_set_trust.</p></li>
<li><p>shutdown Shuts down an active TLS/SSL connection. It sends the
'close notify' shutdown alert to the peer. my $rv =
Net::SSLeay::shutdown($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: 1 - shutdown was successfully completed # 0 -
shutdown is not yet finished, # -1 - shutdown was not successful Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_shutdown.html&gt;</p></li>
<li><p>state_string Returns a 6 letter string indicating the current
state of the SSL object <code>$ssl</code>. my $rv =
Net::SSLeay::state_string($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: 6-letter string Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_state_string.html&gt;</p></li>
<li><p>state_string_long Returns a string indicating the current state
of the SSL object <code>$ssl</code>. my $rv =
Net::SSLeay::state_string_long($ssl); # $ssl - value corresponding to
openssls SSL structure # # returns: state strings Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_state_string.html&gt;</p></li>
<li><p>set_default_passwd_cb <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.1.0f. Not needed with LibreSSL. Sets the default password callback
called when loading/storing a PEM certificate with encryption for
<code>$ssl</code>. Net::SSLeay::set_default_passwd_cb($ssl, $func); #
$ssl - value corresponding to openssls SSL structure # $func - perl
reference to callback function # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p></li>
<li><p>set_default_passwd_cb_userdata <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.1.0f. Not needed with LibreSSL. Sets a pointer to userdata which will
be provided to the password callback of <code>$ssl</code> on invocation.
Net::SSLeay::set_default_passwd_cb_userdata($ssl, $userdata); # $ssl -
value corresponding to openssls SSL structure # $userdata - data that
will be passed to callback function when invoked # # returns: no return
value Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_set_default_passwd_cb.html&gt;</p></li>
<li><p>use_PrivateKey Adds <code>$pkey</code> as private key to
<code>$ssl</code>. my $rv = Net::SSLeay::use_PrivateKey($ssl, $pkey); #
$ssl - value corresponding to openssls SSL structure # $pkey - value
corresponding to openssls EVP_PKEY structure # # returns: 1 on success,
otherwise check out the error stack to find out the reason Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_PrivateKey_ASN1 Adds the private key of type <code>$pk</code>
stored in <code>$data</code> to <code>$ssl</code>. my $rv =
Net::SSLeay::use_PrivateKey_ASN1($pk, $ssl, $d, $len); # $pk - (integer)
key type, NID of corresponding algorithm # $ssl - value corresponding to
openssls SSL structure # $data - key data (binary) # $len - length of
$data # # returns: 1 on success, otherwise check out the error stack to
find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_PrivateKey_file Adds the first private key found in
<code>$file</code> to <code>$ssl</code>. my $rv =
Net::SSLeay::use_PrivateKey_file($ssl, $file, $type); # $ssl - value
corresponding to openssls SSL structure # $file - (string) file name #
$type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or
&amp;Net::SSLeay::FILETYPE_ASN1 # # returns: 1 on success, otherwise
check out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_RSAPrivateKey Adds <code>$rsa</code> as RSA private key to
<code>$ssl</code>. my $rv = Net::SSLeay::use_RSAPrivateKey($ssl, $rsa);
# $ssl - value corresponding to openssls SSL structure # $rsa - value
corresponding to openssls RSA structure # # returns: 1 on success,
otherwise check out the error stack to find out the reason Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_RSAPrivateKey_ASN1 Adds RSA private key stored in
<code>$data</code> to <code>$ssl</code>. my $rv =
Net::SSLeay::use_RSAPrivateKey_ASN1($ssl, $data, $len); # $ssl - value
corresponding to openssls SSL structure # $data - key data (binary) #
$len - length of $data # # returns: 1 on success, otherwise check out
the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_RSAPrivateKey_file Adds the first RSA private key found in
<code>$file</code> to <code>$ssl</code>. my $rv =
Net::SSLeay::use_RSAPrivateKey_file($ssl, $file, $type); # $ssl - value
corresponding to openssls SSL structure # $file - (string) file name #
$type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or
&amp;Net::SSLeay::FILETYPE_ASN1 # # returns: 1 on success, otherwise
check out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_certificate Loads the certificate <code>$x</code> into
<code>$ssl</code>. my $rv = Net::SSLeay::use_certificate($ssl, $x); #
$ssl - value corresponding to openssls SSL structure # $x - value
corresponding to openssls X509 structure # # returns: 1 on success,
otherwise check out the error stack to find out the reason Check openssl
doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_certificate_ASN1 Loads the ASN1 encoded certificate from
<code>$data</code> to <code>$ssl</code>. my $rv =
Net::SSLeay::use_certificate_ASN1($ssl, $data, $len); # $ssl - value
corresponding to openssls SSL structure # $data - certificate data
(binary) # $len - length of $data # # returns: 1 on success, otherwise
check out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_certificate_chain_file <strong>COMPATIBILITY</strong>: not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL 1.1.0
Loads a certificate chain from <code>$file</code> into
<code>$ssl</code>. The certificates must be in PEM format and must be
sorted starting with the subject's certificate (actual client or server
certificate), followed by intermediate CA certificates if applicable,
and ending at the highest level (root) CA. my $rv =
Net::SSLeay::use_certificate_chain_file($ssl, $file); # $ssl - value
corresponding to openssls SSL structure # $file - (string) file name # #
returns: 1 on success, otherwise check out the error stack to find out
the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>use_certificate_file Loads the first certificate stored in
<code>$file</code> into <code>$ssl</code>. my $rv =
Net::SSLeay::use_certificate_file($ssl, $file, $type); # $ssl - value
corresponding to openssls SSL structure # $file - (string) file name #
$type - (integer) type - use constants &amp;Net::SSLeay::FILETYPE_PEM or
&amp;Net::SSLeay::FILETYPE_ASN1 # # returns: 1 on success, otherwise
check out the error stack to find out the reason Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_CTX_use_certificate.html&gt;</p></li>
<li><p>get_version Returns SSL/TLS protocol name my $rv =
Net::SSLeay::get_version($ssl); # $ssl - value corresponding to openssls
SSL structure # # returns: (string) protocol name, see OpenSSL manual
for the full list # TLSv1 # TLSv1.3 Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_get_version.html&gt;</p></li>
<li><p>version Returns SSL/TLS protocol version my $rv =
Net::SSLeay::version($ssl); # $ssl - value corresponding to openssls SSL
structure # # returns: (integer) protocol version, see OpenSSL manual
for the full list # 0x0301 - TLS1_VERSION (TLSv1) # 0xFEFF -
DTLS1_VERSION (DTLSv1) Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_version.html&gt;</p></li>
<li><p>client_version <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in
LibreSSL Returns TLS protocol version used by the client when initiating
the connection my $rv = Net::SSLeay::client_version($ssl); # $ssl -
value corresponding to openssls SSL structure # # returns: (integer)
protocol version, see OpenSSL manual for the full list # 0x0301 -
TLS1_VERSION (TLSv1) # 0xFEFF - DTLS1_VERSION (DTLSv1) Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_client_version.html&gt;</p></li>
<li><p>is_dtls <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.0, not in
LibreSSL my $rv = Net::SSLeay::is_dtls($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: (integer) zero or
one # 0 - connection is not using DTLS # 1 - connection is using DTLS
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_is_dtls.html&gt;</p></li>
<li><p>want Returns state information for the SSL object
<code>$ssl</code>. my $rv = Net::SSLeay::want($ssl); # $ssl - value
corresponding to openssls SSL structure # # returns: state # 1 -
SSL_NOTHING # 2 - SSL_WRITING # 3 - SSL_READING # 4 - SSL_X509_LOOKUP
Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_want.html&gt;</p></li>
<li><p>write Writes data from the buffer <code>$data</code> into the
specified <code>$ssl</code> connection. my $rv =
Net::SSLeay::write($ssl, $data); # $ssl - value corresponding to
openssls SSL structure # $data - data to be written # # returns: &gt;0 -
(success) number of bytes actually written to the TLS/SSL connection # 0
- write not successful, probably the underlying connection was closed #
&lt;0 - error Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_write.html&gt;</p></li>
<li><p>write_ex <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Writes data from the buffer <code>$data</code> into the
specified <code>$ssl</code> connection. my ($len, $rv) =
Net::SSLeay::write_ex($ssl, $data); # $ssl - value corresponding to
openssls SSL structure # $data - data to be written # # returns a list:
two-item list consisting of number of bytes written, # and return code
from SSL_write_ex() Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/SSL_write_ex.html&gt;</p></li>
<li><p>write_partial <strong>NOTE:</strong> Does not exactly correspond
to any low level API function Writes a fragment of data in
<code>$data</code> from the buffer <code>$data</code> into the specified
<code>$ssl</code> connection. This is a non-blocking function like
<strong>Net::SSLeay::write()</strong>. my $rv =
Net::SSLeay::write_partial($ssl, $from, $count, $data); # $ssl - value
corresponding to openssls SSL structure # $from - (integer) offset from
the beginning of $data # $count - (integer) length of data to be written
# $data - data buffer # # returns: &gt;0 - (success) number of bytes
actually written to the TLS/SSL connection # 0 - write not successful,
probably the underlying connection was closed # &lt;0 - error</p></li>
<li><p>set_tlsext_host_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least
openssl-0.9.8f Sets TLS servername extension on SLL object
<code>$ssl</code> to value <code>$name</code>. my $rv =
set_tlsext_host_name($ssl, $name); # $ssl - value corresponding to
openssls SSL structure # $name - (string) name to be set # # returns: 1
on success, 0 on failure</p></li>
</ul>
<p><em>Low level API: RAND_* related functions</em></p>
<p>Check openssl doc related to RAND stuff
&lt;http://www.openssl.org/docs/crypto/rand.html&gt;</p>
<ul>
<li><p>RAND_add Mixes the <code>$num</code> bytes at <code>$buf</code>
into the PRNG state. Net::SSLeay::RAND_add($buf, $num, $entropy); # $buf
- buffer with data to be mixed into the PRNG state # $num - number of
bytes in $buf # $entropy - estimate of how much randomness is contained
in $buf (in bytes) # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p></li>
<li><p>RAND_seed Equivalent to RAND_add when <code>$num</code> ==
<code>$entropy</code>. Net::SSLeay::RAND_seed($buf); # Perlishly figures
out buf size # $buf - buffer with data to be mixed into the PRNG state #
$num - number of bytes in $buf # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p></li>
<li><p>RAND_status Gives PRNG status (seeded enough or not). my $rv =
Net::SSLeay::RAND_status(); #returns: 1 if the PRNG has been seeded with
enough data, 0 otherwise Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_add.html&gt;</p></li>
<li><p>RAND_bytes Puts <code>$num</code> cryptographically strong
pseudo-random bytes into <code>$buf</code>. my $rv =
Net::SSLeay::RAND_bytes($buf, $num); # $buf - buffer where the random
data will be stored # $num - the size (in bytes) of requested random
data # # returns: 1 on success, -1 if not supported by the current RAND
method, or 0 on other failure Check openssl doc
&lt;http://www.openssl.org/docs/manmaster/man3/RAND_bytes.html&gt;</p></li>
<li><p>RAND_priv_bytes <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.85 and before; requires at least OpenSSL 1.1.1, not in
LibreSSL Puts <code>$num</code> cryptographically strong pseudo-random
bytes into <code>$buf</code>. my $rv =
Net::SSLeay::RAND_priv_bytes($buf, $num); # $buf - buffer where the
random data will be stored # $num - the size (in bytes) of requested
random data # # returns: 1 on success, -1 if not supported by the
current RAND method, or 0 on other failure RAND_priv_bytes has the same
semantics as RAND_bytes, but see see the documentation for more
information. Check openssl doc
&lt;http://www.openssl.org/docs/manmaster/man3/RAND_priv_bytes.html&gt;</p></li>
<li><p>RAND_pseudo_bytes Puts <code>$num</code> pseudo-random (not
necessarily unpredictable) bytes into <code>$buf</code>. my $rv =
Net::SSLeay::RAND_pseudo_bytes($buf, $num); # $buf - buffer where the
random data will be stored # $num - the size (in bytes) of requested
random data # # returns: 1 if the bytes generated are cryptographically
strong, 0 otherwise Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_bytes.html&gt;</p></li>
<li><p>RAND_cleanup Erase the PRNG state. Net::SSLeay::RAND_cleanup(); #
no args, no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_cleanup.html&gt;</p></li>
<li><p>RAND_egd_bytes Queries the entropy gathering daemon EGD on socket
<code>$path</code> for <code>$bytes</code> bytes. my $rv =
Net::SSLeay::RAND_egd_bytes($path, $bytes); # $path - path to a socket
of entropy gathering daemon EGD # $bytes - number of bytes we want from
EGD # # returns: the number of bytes read from the daemon on success,
and -1 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_egd.html&gt;</p></li>
<li><p>RAND_file_name Generates a default path for the random seed file.
my $file = Net::SSLeay::RAND_file_name($num); # $num - maximum size of
returned file name # # returns: string with file name on success, (empty
string) or undef on failure LibreSSL and OpenSSL 1.1.0a and later return
undef when, for example, <code>$num</code> is not large enough to hold
the filename. Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p></li>
<li><p>RAND_load_file <strong>COMPATIBILITY:</strong> Is no longer
functional on LibreSSL Reads <code>$max_bytes</code> of bytes from
<code>$file_name</code> and adds them to the PRNG. my $rv =
Net::SSLeay::RAND_load_file($file_name, $max_bytes); # $file_name - the
name of file # $max_bytes - bytes to read from $file_name; -1 =&gt; the
complete file is read # # returns: the number of bytes read Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p></li>
<li><p>RAND_write_file Writes 1024 random bytes to
<code>$file_name</code> which can be used to initialize the PRNG by
calling RAND_load_file in a later session. my $rv =
Net::SSLeay::RAND_write_file($file_name); # $file_name - the name of
file # # returns: the number of bytes written, and -1 if the bytes
written were generated without appropriate seed Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RAND_load_file.html&gt;</p></li>
<li><p>RAND_poll Collects some entropy from operating system and adds it
to the PRNG. my $rv = Net::SSLeay::RAND_poll(); # returns: 1 on success,
0 on failure (unable to gather reasonable entropy)</p></li>
</ul>
<p><em>Low level API: OBJ_* related functions</em></p>
<ul>
<li><p>OBJ_cmp Compares ASN1_OBJECT <code>$a</code> to ASN1_OBJECT
<code>$b</code>. my $rv = Net::SSLeay::OBJ_cmp($a, $b); # $a - value
corresponding to openssls ASN1_OBJECT structure # $b - value
corresponding to openssls ASN1_OBJECT structure # # returns: if the two
are identical 0 is returned Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_dup Returns a copy/duplicate of <code>$o</code>. my $rv =
Net::SSLeay::OBJ_dup($o); # $o - value corresponding to openssls
ASN1_OBJECT structure # # returns: value corresponding to openssls
ASN1_OBJECT structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_nid2ln Returns long name for given NID <code>$n</code>. my
$rv = Net::SSLeay::OBJ_nid2ln($n); # $n - (integer) NID # # returns:
(string) long name e.g. commonName Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_ln2nid Returns NID corresponding to given long name
<code>$n</code>. my $rv = Net::SSLeay::OBJ_ln2nid($s); # $s - (string)
long name e.g. commonName # # returns: (integer) NID</p></li>
<li><p>OBJ_nid2sn Returns short name for given NID <code>$n</code>. my
$rv = Net::SSLeay::OBJ_nid2sn($n); # $n - (integer) NID # # returns:
(string) short name e.g. CN Example: print
Net::SSLeay::OBJ_nid2sn(&amp;Net::SSLeay::NID_commonName);</p></li>
<li><p>OBJ_sn2nid Returns NID corresponding to given short name
<code>$s</code>. my $rv = Net::SSLeay::OBJ_sn2nid($s); # $s - (string)
short name e.g. CN # # returns: (integer) NID Example: print
"NID_commonName constant=", &amp;Net::SSLeay::NID_commonName; print
"OBJ_sn2nid(CN)=", Net::SSLeay::OBJ_sn2nid(CN);</p></li>
<li><p>OBJ_nid2obj Returns ASN1_OBJECT for given NID <code>$n</code>. my
$rv = Net::SSLeay::OBJ_nid2obj($n); # $n - (integer) NID # # returns:
value corresponding to openssls ASN1_OBJECT structure (0 on failure)
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_obj2nid Returns NID corresponding to given ASN1_OBJECT
<code>$o</code>. my $rv = Net::SSLeay::OBJ_obj2nid($o); # $o - value
corresponding to openssls ASN1_OBJECT structure # # returns: (integer)
NID Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_txt2obj Converts the text string s into an ASN1_OBJECT
structure. If <code>$no_name</code> is 0 then long names (e.g.
'commonName') and short names (e.g. 'CN') will be interpreted as well as
numerical forms (e.g. '2.5.4.3'). If <code>$no_name</code> is 1 only the
numerical form is acceptable. my $rv = Net::SSLeay::OBJ_txt2obj($s,
$no_name); # $s - text string to be converted # $no_name - (integer) 0
or 1 # # returns: value corresponding to openssls ASN1_OBJECT structure
(0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_obj2txt Converts the ASN1_OBJECT a into a textual
representation. Net::SSLeay::OBJ_obj2txt($a, $no_name); # $a - value
corresponding to openssls ASN1_OBJECT structure # $no_name - (integer) 0
or 1 # # returns: textual representation e.g. commonName ($no_name=0),
2.5.4.3 ($no_name=1) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
<li><p>OBJ_txt2nid Returns NID corresponding to text string
<code>$s</code> which can be a long name, a short name or the numerical
representation of an object. my $rv = Net::SSLeay::OBJ_txt2nid($s); # $s
- (string) e.g. commonName or CN or 2.5.4.3 # # returns: (integer) NID
Example: my $nid = Net::SSLeay::OBJ_txt2nid(2.5.4.3);
Net::SSLeay::OBJ_nid2sn($n); Check openssl doc
&lt;http://www.openssl.org/docs/crypto/OBJ_nid2obj.html&gt;</p></li>
</ul>
<p><em>Low level API: ASN1_INTEGER_* related functions</em></p>
<ul>
<li><p>ASN1_INTEGER_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Creates a new ASN1_INTEGER structure. my $rv
= Net::SSLeay::ASN1_INTEGER_new(); # # returns: value corresponding to
openssls ASN1_INTEGER structure (0 on failure)</p></li>
<li><p>ASN1_INTEGER_free <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Free an allocated ASN1_INTEGER structure.
Net::SSLeay::ASN1_INTEGER_free($i); # $i - value corresponding to
openssls ASN1_INTEGER structure # # returns: no return value</p></li>
<li><p>ASN1_INTEGER_get <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns integer value of given ASN1_INTEGER
object. <strong>BEWARE:</strong> If the value stored in ASN1_INTEGER is
greater than max. integer that can be stored in 'long' type (usually
32bit but may vary according to platform) then this function will return
-1. For getting large ASN1_INTEGER values consider using
P_ASN1_INTEGER_get_dec or P_ASN1_INTEGER_get_hex. my $rv =
Net::SSLeay::ASN1_INTEGER_get($a); # $a - value corresponding to
openssls ASN1_INTEGER structure # # returns: integer value of
ASN1_INTEGER object in $a</p></li>
<li><p>ASN1_INTEGER_set <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Sets value of given ASN1_INTEGER object to
value <code>$val</code> <strong>BEWARE:</strong> <code>$val</code> has
max. limit (= max. integer that can be stored in 'long' type). For
setting large ASN1_INTEGER values consider using P_ASN1_INTEGER_set_dec
or P_ASN1_INTEGER_set_hex. my $rv = Net::SSLeay::ASN1_INTEGER_set($i,
$val); # $i - value corresponding to openssls ASN1_INTEGER structure #
$val - integer value # # returns: 1 on success, 0 on failure</p></li>
<li><p>P_ASN1_INTEGER_get_dec <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns string with decimal
representation of integer value of given ASN1_INTEGER object.
Net::SSLeay::P_ASN1_INTEGER_get_dec($i); # $i - value corresponding to
openssls ASN1_INTEGER structure # # returns: string with decimal
representation</p></li>
<li><p>P_ASN1_INTEGER_get_hex <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns string with hexadecimal
representation of integer value of given ASN1_INTEGER object.
Net::SSLeay::P_ASN1_INTEGER_get_hex($i); # $i - value corresponding to
openssls ASN1_INTEGER structure # # returns: string with hexadecimal
representation</p></li>
<li><p>P_ASN1_INTEGER_set_dec <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets value of given ASN1_INTEGER
object to value <code>$val</code> (decimal string, suitable for large
integers) Net::SSLeay::P_ASN1_INTEGER_set_dec($i, $str); # $i - value
corresponding to openssls ASN1_INTEGER structure # $str - string with
decimal representation # # returns: 1 on success, 0 on failure</p></li>
<li><p>P_ASN1_INTEGER_set_hex <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets value of given ASN1_INTEGER
object to value <code>$val</code> (hexadecimal string, suitable for
large integers) Net::SSLeay::P_ASN1_INTEGER_set_hex($i, $str); # $i -
value corresponding to openssls ASN1_INTEGER structure # $str - string
with hexadecimal representation # # returns: 1 on success, 0 on
failure</p></li>
</ul>
<p><em>Low level API: ASN1_STRING_* related functions</em></p>
<ul>
<li><p>P_ASN1_STRING_get <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Returns string value of given ASN1_STRING
object. Net::SSLeay::P_ASN1_STRING_get($s, $utf8_decode); # $s - value
corresponding to openssls ASN1_STRING structure # $utf8_decode -
[optional] 0 or 1 whether the returned value should be utf8 decoded
(default=0) # # returns: string $string =
Net::SSLeay::P_ASN1_STRING_get($s); #is the same as: $string =
Net::SSLeay::P_ASN1_STRING_get($s, 0);</p></li>
</ul>
<p><em>Low level API: ASN1_TIME_* related functions</em></p>
<ul>
<li><p>ASN1_TIME_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before my $time = ASN1_TIME_new(); # returns: value
corresponding to openssls ASN1_TIME structure</p></li>
<li><p>ASN1_TIME_free <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before ASN1_TIME_free($time); # $time - value
corresponding to openssls ASN1_TIME structure</p></li>
<li><p>ASN1_TIME_set <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before ASN1_TIME_set($time, $t); # $time - value
corresponding to openssls ASN1_TIME structure # $t - time value in
seconds since 1.1.1970 <strong>BEWARE:</strong> It is platform dependent
how this function will handle dates after 2038. Although perl's integer
is large enough the internal implementation of this function is
dependent on the size of time_t structure (32bit time_t has problem with
2038). If you want to safely set date and time after 2038 use function
P_ASN1_TIME_set_isotime.</p></li>
<li><p>P_ASN1_TIME_get_isotime <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.42 and before; requires at least
openssl-0.9.7e <strong>NOTE:</strong> Does not exactly correspond to any
low level API function Gives ISO-8601 string representation of ASN1_TIME
structure. my $datetime_string = P_ASN1_TIME_get_isotime($time); # $time
- value corresponding to openssls ASN1_TIME structure # # returns:
datetime string like 2033-05-16T20:39:37Z or on failure The output
format is compatible with module DateTime::Format::RFC3339</p></li>
<li><p>P_ASN1_TIME_set_isotime <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.42 and before; requires at least
openssl-0.9.7e <strong>NOTE:</strong> Does not exactly correspond to any
low level API function Sets time and date value of ANS1_time structure.
my $rv = P_ASN1_TIME_set_isotime($time, $string); # $time - value
corresponding to openssls ASN1_TIME structure # $string - ISO-8601
timedate string like 2033-05-16T20:39:37Z # # returns: 1 on success, 0
on failure The <code>$string</code> parameter has to be in full form
like <code>"2012-03-22T23:55:33"</code> or
<code>"2012-03-22T23:55:33Z"</code> or
<code>"2012-03-22T23:55:33CET"</code>. Short forms like
<code>"2012-03-22T23:55"</code> or <code>"2012-03-22"</code> are not
supported.</p></li>
<li><p>P_ASN1_TIME_put2string <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.42 and before, has bugs with openssl-0.9.8i
<strong>NOTE:</strong> Does not exactly correspond to any low level API
function Gives string representation of ASN1_TIME structure. my $str =
P_ASN1_TIME_put2string($time); # $time - value corresponding to openssls
ASN1_TIME structure # # returns: datetime string like May 16 20:39:37
2033 GMT</p></li>
<li><p>P_ASN1_UTCTIME_put2string <strong>NOTE:</strong> deprecated
function, only for backward compatibility, just an alias for
P_ASN1_TIME_put2string</p></li>
</ul>
<p><em>Low level API: X509_* related functions</em></p>
<ul>
<li><p>X509_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Allocates and initializes a X509 structure.
my $rv = Net::SSLeay::X509_new(); # # returns: value corresponding to
openssls X509 structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_new.html&gt;</p></li>
<li><p>X509_free Frees up the X509 structure.
Net::SSLeay::X509_free($a); # $a - value corresponding to openssls X509
structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_new.html&gt;</p></li>
<li><p>X509_check_host <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2.
X509_CHECK_FLAG_NEVER_CHECK_SUBJECT requires OpenSSL 1.1.0. Checks if
the certificate Subject Alternative Name (SAN) or Subject CommonName
(CN) matches the specified host name. my $rv =
Net::SSLeay::X509_check_host($cert, $name, $flags, $peername); # $cert -
value corresponding to openssls X509 structure # $name - host name to
check # $flags (optional, default: 0) - can be the bitwise OR of: #
&amp;Net::SSLeay::X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT #
&amp;Net::SSLeay::X509_CHECK_FLAG_NO_WILDCARDS #
&amp;Net::SSLeay::X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS #
&amp;Net::SSLeay::X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS #
&amp;Net::SSLeay::X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS #
&amp;Net::SSLeay::X509_CHECK_FLAG_NEVER_CHECK_SUBJECT # $peername
(optional) - If not omitted and $host matches $cert, # a copy of the
matching SAN or CN from # the peer certificate is stored in $peername. #
# returns: # 1 for a successful match # 0 for a failed match # -1 for an
internal error # -2 if the input is malformed Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_check_host.html&gt;.</p></li>
<li><p>X509_check_email <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2. Checks if
the certificate matches the specified email address. my $rv =
Net::SSLeay::X509_check_email($cert, $address, $flags); # $cert - value
corresponding to openssls X509 structure # $address - email address to
check # $flags (optional, default: 0) - see X509_check_host() # #
returns: see X509_check_host() Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_check_email.html&gt;.</p></li>
<li><p>X509_check_ip <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2. Checks if
the certificate matches the specified IPv4 or IPv6 address. my $rv =
Net::SSLeay::X509_check_ip($cert, $address, $flags); # $cert - value
corresponding to openssls X509 structure # $address - IP address to
check in binary format, in network byte order # $flags (optional,
default: 0) - see X509_check_host() # # returns: see X509_check_host()
Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_check_ip.html&gt;.</p></li>
<li><p>X509_check_ip_asc <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.68 and before; requires at least OpenSSL 1.0.2. Checks
if the certificate matches the specified IPv4 or IPv6 address. my $rv =
Net::SSLeay::X509_check_ip_asc($cert, $address, $flags); # $cert - value
corresponding to openssls X509 structure # $address - IP address to
check in text representation # $flags (optional, default: 0) - see
X509_check_host() # # returns: see X509_check_host() Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_check_ip_asc.html&gt;.</p></li>
<li><p>X509_certificate_type <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns bitmask with type of
certificate <code>$x</code>. my $rv =
Net::SSLeay::X509_certificate_type($x); # $x - value corresponding to
openssls X509 structure # # returns: (integer) bitmask with certificate
type #to decode bitmask returned by this function use these constants:
&amp;Net::SSLeay::EVP_PKS_DSA &amp;Net::SSLeay::EVP_PKS_EC
&amp;Net::SSLeay::EVP_PKS_RSA &amp;Net::SSLeay::EVP_PKT_ENC
&amp;Net::SSLeay::EVP_PKT_EXCH &amp;Net::SSLeay::EVP_PKT_EXP
&amp;Net::SSLeay::EVP_PKT_SIGN &amp;Net::SSLeay::EVP_PK_DH
&amp;Net::SSLeay::EVP_PK_DSA &amp;Net::SSLeay::EVP_PK_EC
&amp;Net::SSLeay::EVP_PK_RSA</p></li>
<li><p>X509_digest <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Computes digest/fingerprint of X509
<code>$data</code> using <code>$type</code> hash function. my
$digest_value = Net::SSLeay::X509_digest($data, $type); # $data - value
corresponding to openssls X509 structure # $type - value corresponding
to openssls EVP_MD structure - e.g. got via EVP_get_digestbyname() # #
returns: hash value (binary) #to get printable (hex) value of digest
use: print unpack(H*, $digest_value);</p></li>
<li><p>X509_issuer_and_serial_hash <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sort of a checksum of issuer
name and serial number of X509 certificate <code>$x</code>. The result
is not a full hash (e.g. sha-1), it is kind-of-a-hash truncated to the
size of 'unsigned long' (32 bits). The resulting value might differ
across different openssl versions for the same X509 certificate. my $rv
= Net::SSLeay::X509_issuer_and_serial_hash($x); # $x - value
corresponding to openssls X509 structure # # returns: number
representing checksum</p></li>
<li><p>X509_issuer_name_hash <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sort of a checksum of issuer
name of X509 certificate <code>$x</code>. The result is not a full hash
(e.g. sha-1), it is kind-of-a-hash truncated to the size of 'unsigned
long' (32 bits). The resulting value might differ across different
openssl versions for the same X509 certificate. my $rv =
Net::SSLeay::X509_issuer_name_hash($x); # $x - value corresponding to
openssls X509 structure # # returns: number representing
checksum</p></li>
<li><p>X509_subject_name_hash <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sort of a checksum of subject
name of X509 certificate <code>$x</code>. The result is not a full hash
(e.g. sha-1), it is kind-of-a-hash truncated to the size of 'unsigned
long' (32 bits). The resulting value might differ across different
openssl versions for the same X509 certificate. my $rv =
Net::SSLeay::X509_subject_name_hash($x); # $x - value corresponding to
openssls X509 structure # # returns: number representing
checksum</p></li>
<li><p>X509_pubkey_digest <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7 Computes
digest/fingerprint of public key from X509 certificate
<code>$data</code> using <code>$type</code> hash function. my
$digest_value = Net::SSLeay::X509_pubkey_digest($data, $type); # $data -
value corresponding to openssls X509 structure # $type - value
corresponding to openssls EVP_MD structure - e.g. got via
EVP_get_digestbyname() # # returns: hash value (binary) #to get
printable (hex) value of digest use: print unpack(H*,
$digest_value);</p></li>
<li><p>X509_set_issuer_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets issuer of X509 certificate
<code>$x</code> to <code>$name</code>. my $rv =
Net::SSLeay::X509_set_issuer_name($x, $name); # $x - value corresponding
to openssls X509 structure # $name - value corresponding to openssls
X509_NAME structure # # returns: 1 on success, 0 on failure</p></li>
<li><p>X509_set_pubkey <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Sets public key of X509 certificate
<code>$x</code> to <code>$pkey</code>. my $rv =
Net::SSLeay::X509_set_pubkey($x, $pkey); # $x - value corresponding to
openssls X509 structure # $pkey - value corresponding to openssls
EVP_PKEY structure # # returns: 1 on success, 0 on failure</p></li>
<li><p>X509_set_serialNumber <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets serial number of X509
certificate <code>$x</code> to <code>$serial</code>. my $rv =
Net::SSLeay::X509_set_serialNumber($x, $serial); # $x - value
corresponding to openssls X509 structure # $serial - value corresponding
to openssls ASN1_INTEGER structure # # returns: 1 on success, 0 on
failure #to create $serial value use one of these: $serial =
Net::SSLeay::P_ASN1_INTEGER_set_hex(45ad6f); $serial =
Net::SSLeay::P_ASN1_INTEGER_set_dec(7896541238529631478); $serial =
Net::SSLeay::ASN1_INTEGER_set(45896);</p></li>
<li><p>X509_set_subject_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets subject of X509 certificate
<code>$x</code> to <code>$name</code>. my $rv =
Net::SSLeay::X509_set_subject_name($x, $name); # $x - value
corresponding to openssls X509 structure # $name - value corresponding
to openssls X509_NAME structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_set_version <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Set 'version' value for X509 certificate $ to
<code>$version</code>. my $rv = Net::SSLeay::X509_set_version($x,
$version); # $x - value corresponding to openssls X509 structure #
$version - (integer) version number # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_sign <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Sign X509 certificate <code>$x</code> with
private key <code>$pkey</code> (using digest algorithm
<code>$md</code>). my $rv = Net::SSLeay::X509_sign($x, $pkey, $md); # $x
- value corresponding to openssls X509 structure # $pkey - value
corresponding to openssls EVP_PKEY structure # $md - value corresponding
to openssls EVP_MD structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_verify <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Verifies X509 object <code>$a</code> using
public key <code>$r</code> (pubkey of issuing CA). my $rv =
Net::SSLeay::X509_verify($x, $r); # $x - value corresponding to openssls
X509 structure # $r - value corresponding to openssls EVP_PKEY structure
# # returns: 0 - verify failure, 1 - verify OK, &lt;0 - error</p></li>
<li><p>X509_get_ext_count <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Returns the total number of extensions in
X509 object <code>$x</code>. my $rv =
Net::SSLeay::X509_get_ext_count($x); # $x - value corresponding to
openssls X509 structure # # returns: count of extensions</p></li>
<li><p>X509_get_pubkey <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns public key corresponding to given
X509 object <code>$x</code>. my $rv = Net::SSLeay::X509_get_pubkey($x);
# $x - value corresponding to openssls X509 structure # # returns: value
corresponding to openssls EVP_PKEY structure (0 on failure)
<strong>NOTE:</strong> This method returns only the public key's key
bits, without the algorithm or parameters. Use
<code>X509_get_X509_PUBKEY()</code> to return the full public key (SPKI)
instead.</p></li>
<li><p>X509_get_X509_PUBKEY <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.72 and before Returns the full public key
(SPKI) of given X509 certificate <code>$x</code>.
Net::SSLeay::X509_get_X509_PUBKEY($x); # $x - value corresponding to
openssls X509 structure # # returns: public key data in DER format
(binary)</p></li>
<li><p>X509_get_serialNumber <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns serial number of X509
certificate <code>$x</code>. my $rv =
Net::SSLeay::X509_get_serialNumber($x); # $x - value corresponding to
openssls X509 structure # # returns: value corresponding to openssls
ASN1_INTEGER structure (0 on failure) See P_ASN1_INTEGER_get_dec,
P_ASN1_INTEGER_get_hex or ASN1_INTEGER_get to decode ASN1_INTEGER
object.</p></li>
<li><p>X509_get0_serialNumber <strong>COMPATIBILITY:</strong> available
in Net-SSLeay-1.86 onwards <strong>X509_get0_serialNumber()</strong> is
the same as <strong>X509_get_serialNumber()</strong> except it accepts a
const parameter and returns a const result.</p></li>
<li><p>X509_get_version <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns 'version' value of given X509
certificate <code>$x</code>. my $rv = Net::SSLeay::X509_get_version($x);
# $x - value corresponding to openssls X509 structure # # returns:
(integer) version</p></li>
<li><p>X509_get_ext Returns X509_EXTENSION from <code>$x509</code> based
on given position/index. my $rv = Net::SSLeay::X509_get_ext($x509,
$index); # $x509 - value corresponding to openssls X509 structure #
$index - (integer) position/index of extension within $x509 # # returns:
value corresponding to openssls X509_EXTENSION structure (0 on
failure)</p></li>
<li><p>X509_get_ext_by_NID Returns X509_EXTENSION from
<code>$x509</code> based on given NID. my $rv =
Net::SSLeay::X509_get_ext_by_NID($x509, $nid, $loc); # $x509 - value
corresponding to openssls X509 structure # $nid - (integer) NID value #
$loc - (integer) position to start lookup at # # returns: position/index
of extension, negative value on error # call
Net::SSLeay::X509_get_ext($x509, $rv) to get the actual
extension</p></li>
<li><p>X509_get_fingerprint Returns fingerprint of certificate
<code>$cert</code>. <strong>NOTE:</strong> Does not exactly correspond
to any low level API function. The implementation is based on openssl's
<code>X509_digest()</code>. Net::SSLeay::X509_get_fingerprint($x509,
$type); # $x509 - value corresponding to openssls X509 structure # $type
- (string) digest type, currently supported values: # "md5" # "sha1" #
"sha256" # "ripemd160" # # returns: certificate digest - hexadecimal
string (NOT binary data!)</p></li>
<li><p>X509_get_issuer_name Return an X509_NAME object representing the
issuer of the certificate <code>$cert</code>. my $rv =
Net::SSLeay::X509_get_issuer_name($cert); # $cert - value corresponding
to openssls X509 structure # # returns: value corresponding to openssls
X509_NAME structure (0 on failure)</p></li>
<li><p>X509_get_notAfter Return an object giving the time after which
the certificate <code>$cert</code> is not valid. my $rv =
Net::SSLeay::X509_get_notAfter($cert); # $cert - value corresponding to
openssls X509 structure # # returns: value corresponding to openssls
ASN1_TIME structure (0 on failure) To get human readable/printable form
the return value you can use: my $time =
Net::SSLeay::X509_get_notAfter($cert); print "notAfter=",
Net::SSLeay::P_ASN1_TIME_get_isotime($time), "\n";</p></li>
<li><p>X509_get_notBefore Return an object giving the time before which
the certificate <code>$cert</code> is not valid my $rv =
Net::SSLeay::X509_get_notBefore($cert); # $cert - value corresponding to
openssls X509 structure # # returns: value corresponding to openssls
ASN1_TIME structure (0 on failure) To get human readable/printable form
the return value you can use: my $time =
Net::SSLeay::X509_get_notBefore($cert); print "notBefore=",
Net::SSLeay::P_ASN1_TIME_get_isotime($time), "\n";</p></li>
<li><p>X509_get_subjectAltNames <strong>NOTE:</strong> Does not exactly
correspond to any low level API function. Returns the list of
alternative subject names from X509 certificate <code>$cert</code>. my
@rv = Net::SSLeay::X509_get_subjectAltNames($cert); # $cert - value
corresponding to openssls X509 structure # # returns: list containing
pairs - name_type (integer), name_value (string) # where name_type can
be: # 0 - GEN_OTHERNAME # 1 - GEN_EMAIL # 2 - GEN_DNS # 3 - GEN_X400 # 4
- GEN_DIRNAME # 5 - GEN_EDIPARTY # 6 - GEN_URI # 7 - GEN_IPADD # 8 -
GEN_RID Note: type 7 - GEN_IPADD contains the IP address as a packed
binary address. GEN_RID is available in Net-SSLeay-1.90 and later.
Maximum length for returned RID string is currently 2500. Invalid and
overly long RID values are skipped and not returned. GEN_X400 and
GEN_EDIPARTY are not supported and will not be returned even when
present in the certificate.</p></li>
<li><p>X509_get_subject_name Returns the subject of the certificate
<code>$cert</code>. my $rv = Net::SSLeay::X509_get_subject_name($cert);
# $cert - value corresponding to openssls X509 structure # # returns:
value corresponding to openssls X509_NAME structure (0 on
failure)</p></li>
<li><p>X509_gmtime_adj Adjust th ASN1_TIME object to the timestamp (in
GMT). my $rv = Net::SSLeay::X509_gmtime_adj($s, $adj); # $s - value
corresponding to openssls ASN1_TIME structure # $adj - timestamp
(seconds since 1.1.1970) # # returns: value corresponding to openssls
ASN1_TIME structure (0 on failure) <strong>BEWARE:</strong> this
function may fail for dates after 2038 as it is dependent on time_t size
on your system (32bit time_t does not work after 2038). Consider using
P_ASN1_TIME_set_isotime instead).</p></li>
<li><p>X509_load_cert_crl_file Takes PEM file and loads all X509
certificates and X509 CRLs from that file into X509_LOOKUP structure. my
$rv = Net::SSLeay::X509_load_cert_crl_file($ctx, $file, $type); # $ctx -
value corresponding to openssls X509_LOOKUP structure # $file - (string)
file name # $type - (integer) type - use constants
&amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1 # if
not FILETYPE_PEM then behaves as Net::SSLeay::X509_load_cert_file() # #
returns: 1 on success, 0 on failure</p></li>
<li><p>X509_load_cert_file Loads/adds X509 certificate from
<code>$file</code> to X509_LOOKUP structure my $rv =
Net::SSLeay::X509_load_cert_file($ctx, $file, $type); # $ctx - value
corresponding to openssls X509_LOOKUP structure # $file - (string) file
name # $type - (integer) type - use constants
&amp;Net::SSLeay::FILETYPE_PEM or &amp;Net::SSLeay::FILETYPE_ASN1 # #
returns: 1 on success, 0 on failure</p></li>
<li><p>X509_load_crl_file Loads/adds X509 CRL from <code>$file</code> to
X509_LOOKUP structure my $rv = Net::SSLeay::X509_load_crl_file($ctx,
$file, $type); # $ctx - value corresponding to openssls X509_LOOKUP
structure # $file - (string) file name # $type - (integer) type - use
constants &amp;Net::SSLeay::FILETYPE_PEM or
&amp;Net::SSLeay::FILETYPE_ASN1 # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_policy_level_get0_node ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_level_get0_node($level, $i); # $level - value
corresponding to openssls X509_POLICY_LEVEL structure # $i - (integer)
index/position # # returns: value corresponding to openssls
X509_POLICY_NODE structure (0 on failure)</p></li>
<li><p>X509_policy_level_node_count ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_level_node_count($level); # $level - value
corresponding to openssls X509_POLICY_LEVEL structure # # returns:
(integer) node count</p></li>
<li><p>X509_policy_node_get0_parent ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_node_get0_parent($node); # $node - value
corresponding to openssls X509_POLICY_NODE structure # # returns: value
corresponding to openssls X509_POLICY_NODE structure (0 on
failure)</p></li>
<li><p>X509_policy_node_get0_policy ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_node_get0_policy($node); # $node - value
corresponding to openssls X509_POLICY_NODE structure # # returns: value
corresponding to openssls ASN1_OBJECT structure (0 on failure)</p></li>
<li><p>X509_policy_node_get0_qualifiers ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_node_get0_qualifiers($node); # $node - value
corresponding to openssls X509_POLICY_NODE structure # # returns: value
corresponding to openssls STACK_OF(POLICYQUALINFO) structure (0 on
failure)</p></li>
<li><p>X509_policy_tree_free ??? (more info needed)
Net::SSLeay::X509_policy_tree_free($tree); # $tree - value corresponding
to openssls X509_POLICY_TREE structure # # returns: no return
value</p></li>
<li><p>X509_policy_tree_get0_level ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_tree_get0_level($tree, $i); # $tree - value
corresponding to openssls X509_POLICY_TREE structure # $i - (integer)
level index # # returns: value corresponding to openssls
X509_POLICY_LEVEL structure (0 on failure)</p></li>
<li><p>X509_policy_tree_get0_policies ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_tree_get0_policies($tree); # $tree - value
corresponding to openssls X509_POLICY_TREE structure # # returns: value
corresponding to openssls X509_POLICY_NODE structure (0 on
failure)</p></li>
<li><p>X509_policy_tree_get0_user_policies ??? (more info needed) my $rv
= Net::SSLeay::X509_policy_tree_get0_user_policies($tree); # $tree -
value corresponding to openssls X509_POLICY_TREE structure # # returns:
value corresponding to openssls X509_POLICY_NODE structure (0 on
failure)</p></li>
<li><p>X509_policy_tree_level_count ??? (more info needed) my $rv =
Net::SSLeay::X509_policy_tree_level_count($tree); # $tree - value
corresponding to openssls X509_POLICY_TREE structure # # returns:
(integer) count</p></li>
<li><p>X509_verify_cert_error_string Returns a human readable error
string for verification error <code>$n</code>. my $rv =
Net::SSLeay::X509_verify_cert_error_string($n); # $n - (long) numeric
error code # # returns: error string Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p></li>
<li><p>P_X509_add_extensions <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Adds one or more X509 extensions
to X509 object <code>$x</code>. my $rv =
Net::SSLeay::P_X509_add_extensions($x, $ca_cert, $nid, $value); # $x -
value corresponding to openssls X509 structure # $ca_cert - value
corresponding to openssls X509 structure (issuers cert - necessary for
sertting NID_authority_key_identifier) # $nid - NID identifying
extension to be set # $value - extension value # # returns: 1 on
success, 0 on failure You can set more extensions at once: my $rv =
Net::SSLeay::P_X509_add_extensions($x509, $ca_cert,
&amp;Net::SSLeay::NID_key_usage =&gt; digitalSignature,keyEncipherment,
&amp;Net::SSLeay::NID_subject_key_identifier =&gt; hash,
&amp;Net::SSLeay::NID_authority_key_identifier =&gt; keyid,
&amp;Net::SSLeay::NID_authority_key_identifier =&gt; issuer,
&amp;Net::SSLeay::NID_basic_constraints =&gt; CA:FALSE,
&amp;Net::SSLeay::NID_ext_key_usage =&gt; serverAuth,clientAuth,
&amp;Net::SSLeay::NID_netscape_cert_type =&gt; server,
&amp;Net::SSLeay::NID_subject_alt_name =&gt;
DNS:s1.dom.com,DNS:s2.dom.com,DNS:s3.dom.com, );</p></li>
<li><p>P_X509_copy_extensions <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Copies X509 extensions from
X509_REQ object to X509 object - handy when you need to turn X509_REQ
into X509 certificate. Net::SSLeay::P_X509_copy_extensions($x509_req,
$x509, $override); # $x509_req - value corresponding to openssls
X509_REQ structure # $x509 - value corresponding to openssls X509
structure # $override - (integer) flag indication whether to override
already existing items in $x509 (default 1) # # returns: 1 on success, 0
on failure</p></li>
<li><p>P_X509_get_crl_distribution_points
<strong>COMPATIBILITY:</strong> not available in Net-SSLeay-1.45 and
before; requires at least openssl-0.9.7 Get the list of CRL distribution
points from X509 certificate. my @cdp =
Net::SSLeay::P_X509_get_crl_distribution_points($x509); # $x509 - value
corresponding to openssls X509 structure # # returns: list of
distribution points (usually URLs)</p></li>
<li><p>P_X509_get_ext_key_usage <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Gets the list of extended key usage of given X509 certificate
<code>$cert</code>. my @ext_usage =
Net::SSLeay::P_X509_get_ext_key_usage($cert, $format); # $cert - value
corresponding to openssls X509 structure # $format - choose type of
return values: 0=OIDs, 1=NIDs, 2=shortnames, 3=longnames # # returns:
list of values Examples: my @extkeyusage_oid =
Net::SSLeay::P_X509_get_ext_key_usage($x509,0); # returns for example:
("1.3.6.1.5.5.7.3.1", "1.3.6.1.5.5.7.3.2") my @extkeyusage_nid =
Net::SSLeay::P_X509_get_ext_key_usage($x509,1); # returns for example:
(129, 130) my @extkeyusage_sn =
Net::SSLeay::P_X509_get_ext_key_usage($x509,2); # returns for example:
("serverAuth", "clientAuth") my @extkeyusage_ln =
Net::SSLeay::P_X509_get_ext_key_usage($x509,3); # returns for example:
("TLS Web Server Authentication", "TLS Web Client
Authentication")</p></li>
<li><p>P_X509_get_key_usage <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Gets the list of key usage of
given X509 certificate <code>$cert</code>. my @keyusage =
Net::SSLeay::P_X509_get_key_usage($cert); # $cert - value corresponding
to openssls X509 structure # # returns: list of key usage values which
can be none, one or more from the following list: # "digitalSignature" #
"nonRepudiation" # "keyEncipherment" # "dataEncipherment" #
"keyAgreement" # "keyCertSign" # "cRLSign" # "encipherOnly" #
"decipherOnly"</p></li>
<li><p>P_X509_get_netscape_cert_type <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Gets the list of Netscape cert
types of given X509 certificate <code>$cert</code>.
Net::SSLeay::P_X509_get_netscape_cert_type($cert); # $cert - value
corresponding to openssls X509 structure # # returns: list of Netscape
type values which can be none, one or more from the following list: #
"client" # "server" # "email" # "objsign" # "reserved" # "sslCA" #
"emailCA" # "objCA"</p></li>
<li><p>P_X509_get_pubkey_alg <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns ASN1_OBJECT
corresponding to X509 certificate public key algorithm. my $rv =
Net::SSLeay::P_X509_get_pubkey_alg($x); # $x - value corresponding to
openssls X509 structure # # returns: value corresponding to openssls
ASN1_OBJECT structure (0 on failure) To get textual representation use:
my $alg =
Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_pubkey_alg($x509)); #
returns for example: "rsaEncryption"</p></li>
<li><p>P_X509_get_signature_alg <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns ASN1_OBJECT
corresponding to X509 signarite key algorithm. my $rv =
Net::SSLeay::P_X509_get_signature_alg($x); # $x - value corresponding to
openssls X509 structure # # returns: value corresponding to openssls
ASN1_OBJECT structure (0 on failure) To get textual representation use:
my $alg =
Net::SSLeay::OBJ_obj2txt(Net::SSLeay::P_X509_get_signature_alg($x509)) #
returns for example: "sha1WithRSAEncryption"</p></li>
<li><p>sk_X509_new_null Returns a new, empty, STACK_OF(X509) structure.
my $rv = Net::SSLeay::sk_X509_new_null(); # # returns: value
corresponding to openssls STACK_OF(X509) structure</p></li>
<li><p>sk_X509_push Pushes an X509 structure onto a STACK_OF(X509)
structure. my $rv = Net::SSLeay::sk_X509_push($sk_x509, $x509); #
$sk_x509 - value corresponding to openssls STACK_OF(X509) structure #
$x509 - value corresponding to openssls X509 structure # # returns:
total number of elements after the operation, 0 on failure</p></li>
<li><p>sk_X509_pop Pops an single X509 structure from a STACK_OF(X509)
structure. my $x509 = NetSSLeay::sk_X509_pop($sk_x509) # $sk_x509 -
value corresponding to openssls STACK_OF(X509) structure # # returns: a
pointer to an X509 structure, undef on failure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_pop.html&gt;</p></li>
<li><p>sk_X509_shift Shifts an single X509 structure onto a
STACK_OF(X509) structure. my $x509 = NetSSLeay::sk_X509_shift($sk_x509,
$x509) # $sk_x509 - value corresponding to openssls STACK_OF(X509)
structure # $x509 - value corresponding to openssls X509 structure # #
returns: a pointer to an X509 structure, undef on failure Check openssl
doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_shift.html&gt;</p></li>
<li><p>sk_X509_unshift Unshifts an single X509 structure from a
STACK_OF(X509) structure. my $rv = NetSSLeay::sk_X509_unshift($sk_x509)
# $sk_x509 - value corresponding to openssls STACK_OF(X509) structure #
# returns: total number of elements after the operation, 0 on failure
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_unshift.html&gt;</p></li>
<li><p>sk_X509_insert Inserts a single X509 structure into a
STACK_OF(X509) at the specified index. my $rv =
Net::SSLeay::sk_X509_insert($sk_x509, $x509, index); # $sk_x509 - value
corresponding to openssls STACK_OF(X509) structure # $x509 - value
corresponding to openssls X509 structure # index - integer - 0 based
index # # returns: total number of elements after the operation, 0 on
failure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_insert.html&gt;</p></li>
<li><p>sk_X509_delete Delete a single X509 structure from a
STACK_OF(X509) at the specified index. my $x509 =
Net::SSLeay::sk_X509_delete($sk_x509, index); # $sk_x509 - value
corresponding to openssls STACK_OF(X509) structure # index - integer - 0
based index # # returns: a pointer to an X509 structure, undef on
failure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_delete.html&gt;</p></li>
<li><p>sk_X509_value Return a single X509 structure from a
STACK_OF(X509) at the specified index. my $x509 =
Net::SSLeay::sk_X509_value($sk_x509, index) # $sk_x509 - value
corresponding to openssls STACK_OF(X509) structure # index - integer - 0
based index # # returns: a pointer to an X509 structure, undef on
failure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_value.html&gt;</p></li>
<li><p>sk_X509_num Return the number of X509 elements in a
STACK_OF(X509). my $num = Net::SSLeay::sk_X509_num($sk_x509); # $sk_x509
- value corresponding to openssls STACK_OF(X509) structure # # returns:
the number of elements in the stack, -1 if the passed stack is NULL
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/sk_TYPE_num.html&gt;</p></li>
</ul>
<p><em>Low level API: X509_REQ_* related functions</em></p>
<ul>
<li><p>X509_REQ_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Creates a new X509_REQ structure. my $rv =
Net::SSLeay::X509_REQ_new(); # # returns: value corresponding to
openssls X509_REQ structure (0 on failure)</p></li>
<li><p>X509_REQ_free <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Free an allocated X509_REQ structure.
Net::SSLeay::X509_REQ_free($x); # $x - value corresponding to openssls
X509_REQ structure # # returns: no return value</p></li>
<li><p>X509_REQ_add1_attr_by_NID <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Adds an attribute whose name is
defined by a NID <code>$nid</code>. The field value to be added is in
<code>$bytes</code>. my $rv =
Net::SSLeay::X509_REQ_add1_attr_by_NID($req, $nid, $type, $bytes); #
$req - value corresponding to openssls X509_REQ structure # $nid -
(integer) NID value # $type - (integer) type of data in $bytes (see
below) # $bytes - data to be set # # returns: 1 on success, 0 on failure
# values for $type - use constants: &amp;Net::SSLeay::MBSTRING_UTF8 -
$bytes contains utf8 encoded data &amp;Net::SSLeay::MBSTRING_ASC -
$bytes contains ASCII data</p></li>
<li><p>X509_REQ_digest <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Computes digest/fingerprint of X509_REQ
<code>$data</code> using <code>$type</code> hash function. my
$digest_value = Net::SSLeay::X509_REQ_digest($data, $type); # $data -
value corresponding to openssls X509_REQ structure # $type - value
corresponding to openssls EVP_MD structure - e.g. got via
EVP_get_digestbyname() # # returns: hash value (binary) #to get
printable (hex) value of digest use: print unpack(H*,
$digest_value);</p></li>
<li><p>X509_REQ_get_attr_by_NID <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Retrieve the next index matching
<code>$nid</code> after <code>$lastpos</code> ($lastpos should initially
be set to -1). my $rv = Net::SSLeay::X509_REQ_get_attr_by_NID($req,
$nid, $lastpos=-1); # $req - value corresponding to openssls X509_REQ
structure # $nid - (integer) NID value # $lastpos - [optional] (integer)
index where to start search (default -1) # # returns: index (-1 if there
are no more entries) Note: use P_X509_REQ_get_attr to get the actual
attribute value - e.g. my $index =
Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid); my @attr_values =
Net::SSLeay::P_X509_REQ_get_attr($req, $index);</p></li>
<li><p>X509_REQ_get_attr_by_OBJ <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Retrieve the next index matching
<code>$obj</code> after <code>$lastpos</code> ($lastpos should initially
be set to -1). my $rv = Net::SSLeay::X509_REQ_get_attr_by_OBJ($req,
$obj, $lastpos=-1); # $req - value corresponding to openssls X509_REQ
structure # $obj - value corresponding to openssls ASN1_OBJECT structure
# $lastpos - [optional] (integer) index where to start search (default
-1) # # returns: index (-1 if there are no more entries) Note: use
P_X509_REQ_get_attr to get the actual attribute value - e.g. my $index =
Net::SSLeay::X509_REQ_get_attr_by_NID($req, $nid); my @attr_values =
Net::SSLeay::P_X509_REQ_get_attr($req, $index);</p></li>
<li><p>X509_REQ_get_attr_count <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns the total number of
attributes in <code>$req</code>. my $rv =
Net::SSLeay::X509_REQ_get_attr_count($req); # $req - value corresponding
to openssls X509_REQ structure # # returns: (integer) items
count</p></li>
<li><p>X509_REQ_get_pubkey <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Returns public key corresponding to given
X509_REQ object <code>$x</code>. my $rv =
Net::SSLeay::X509_REQ_get_pubkey($x); # $x - value corresponding to
openssls X509_REQ structure # # returns: value corresponding to openssls
EVP_PKEY structure (0 on failure)</p></li>
<li><p>X509_REQ_get_subject_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns X509_NAME object
corresponding to subject name of given X509_REQ object <code>$x</code>.
my $rv = Net::SSLeay::X509_REQ_get_subject_name($x); # $x - value
corresponding to openssls X509_REQ structure # # returns: value
corresponding to openssls X509_NAME structure (0 on failure)</p></li>
<li><p>X509_REQ_get_version <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns 'version' value for
given X509_REQ object <code>$x</code>. my $rv =
Net::SSLeay::X509_REQ_get_version($x); # $x - value corresponding to
openssls X509_REQ structure # # returns: (integer) version e.g. 0 =
"version 1"</p></li>
<li><p>X509_REQ_set_pubkey <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Sets public key of given X509_REQ object
<code>$x</code> to <code>$pkey</code>. my $rv =
Net::SSLeay::X509_REQ_set_pubkey($x, $pkey); # $x - value corresponding
to openssls X509_REQ structure # $pkey - value corresponding to openssls
EVP_PKEY structure # # returns: 1 on success, 0 on failure</p></li>
<li><p>X509_REQ_set_subject_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets subject name of given
X509_REQ object <code>$x</code> to X509_NAME object <code>$name</code>.
my $rv = Net::SSLeay::X509_REQ_set_subject_name($x, $name); # $x - value
corresponding to openssls X509_REQ structure # $name - value
corresponding to openssls X509_NAME structure # # returns: 1 on success,
0 on failure</p></li>
<li><p>X509_REQ_set_version <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Sets 'version' of given X509_REQ
object <code>$x</code> to <code>$version</code>. my $rv =
Net::SSLeay::X509_REQ_set_version($x, $version); # $x - value
corresponding to openssls X509_REQ structure # $version - (integer) e.g.
0 = "version 1" # # returns: 1 on success, 0 on failure</p></li>
<li><p>X509_REQ_sign <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Sign X509_REQ object <code>$x</code> with
private key <code>$pk</code> (using digest algorithm <code>$md</code>).
my $rv = Net::SSLeay::X509_REQ_sign($x, $pk, $md); # $x - value
corresponding to openssls X509_REQ structure # $pk - value corresponding
to openssls EVP_PKEY structure (requestors private key) # $md - value
corresponding to openssls EVP_MD structure # # returns: 1 on success, 0
on failure</p></li>
<li><p>X509_REQ_verify <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Verifies X509_REQ object <code>$x</code>
using public key <code>$r</code> (pubkey of requesting party). my $rv =
Net::SSLeay::X509_REQ_verify($x, $r); # $x - value corresponding to
openssls X509_REQ structure # $r - value corresponding to openssls
EVP_PKEY structure # # returns: 0 - verify failure, 1 - verify OK, &lt;0
- error</p></li>
<li><p>P_X509_REQ_add_extensions <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Adds one or more X509 extensions
to X509_REQ object <code>$x</code>. my $rv =
Net::SSLeay::P_X509_REQ_add_extensions($x, $nid, $value); # $x - value
corresponding to openssls X509_REQ structure # $nid - NID identifying
extension to be set # $value - extension value # # returns: 1 on
success, 0 on failure You can set more extensions at once: my $rv =
Net::SSLeay::P_X509_REQ_add_extensions($x509_req,
&amp;Net::SSLeay::NID_key_usage =&gt; digitalSignature,keyEncipherment,
&amp;Net::SSLeay::NID_basic_constraints =&gt; CA:FALSE,
&amp;Net::SSLeay::NID_ext_key_usage =&gt; serverAuth,clientAuth,
&amp;Net::SSLeay::NID_netscape_cert_type =&gt; server,
&amp;Net::SSLeay::NID_subject_alt_name =&gt; DNS:s1.com,DNS:s2.com,
&amp;Net::SSLeay::NID_crl_distribution_points =&gt;
URI:http://pki.com/crl1,URI:http://pki.com/crl2, );</p></li>
<li><p>P_X509_REQ_get_attr <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7 Returns
attribute value for X509_REQ's attribute at index <code>$n</code>.
Net::SSLeay::P_X509_REQ_get_attr($req, $n); # $req - value corresponding
to openssls X509_REQ structure # $n - (integer) attribute index # #
returns: value corresponding to openssls ASN1_STRING structure</p></li>
</ul>
<p><em>Low level API: X509_CRL_* related functions</em></p>
<ul>
<li><p>X509_CRL_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Creates a new X509_CRL structure. my $rv =
Net::SSLeay::X509_CRL_new(); # # returns: value corresponding to
openssls X509_CRL structure (0 on failure)</p></li>
<li><p>X509_CRL_free <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Free an allocated X509_CRL structure.
Net::SSLeay::X509_CRL_free($x); # $x - value corresponding to openssls
X509_CRL structure # # returns: no return value</p></li>
<li><p>X509_CRL_digest <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Computes digest/fingerprint of X509_CRL
<code>$data</code> using <code>$type</code> hash function. my
$digest_value = Net::SSLeay::X509_CRL_digest($data, $type); # $data -
value corresponding to openssls X509_CRL structure # $type - value
corresponding to openssls EVP_MD structure - e.g. got via
EVP_get_digestbyname() # # returns: hash value (binary) Example: my
$x509_crl my $md = Net::SSLeay::EVP_get_digestbyname("sha1"); my
$digest_value = Net::SSLeay::X509_CRL_digest($x509_crl, $md); #to get
printable (hex) value of digest use: print "digest=", unpack(H*,
$digest_value), "\n";</p></li>
<li><p>X509_CRL_get_ext <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.54 and before Returns X509_EXTENSION from
<code>$x509</code> based on given position/index. my $rv =
Net::SSLeay::X509_CRL_get_ext($x509, $index); # $x509 - value
corresponding to openssls X509_CRL structure # $index - (integer)
position/index of extension within $x509 # # returns: value
corresponding to openssls X509_EXTENSION structure (0 on
failure)</p></li>
<li><p>X509_CRL_get_ext_by_NID <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.54 and before Returns X509_EXTENSION from
<code>$x509</code> based on given NID. my $rv =
Net::SSLeay::X509_CRL_get_ext_by_NID($x509, $nid, $loc); # $x509 - value
corresponding to openssls X509_CRL structure # $nid - (integer) NID
value # $loc - (integer) position to start lookup at # # returns:
position/index of extension, negative value on error # call
Net::SSLeay::X509_CRL_get_ext($x509, $rv) to get the actual
extension</p></li>
<li><p>X509_CRL_get_ext_count <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.54 and before Returns the total number of
extensions in X509_CRL object <code>$x</code>. my $rv =
Net::SSLeay::X509_CRL_get_ext_count($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: count of extensions</p></li>
<li><p>X509_CRL_get_issuer <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Returns X509_NAME object corresponding to
the issuer of X509_CRL <code>$x</code>. my $rv =
Net::SSLeay::X509_CRL_get_issuer($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: value corresponding to openssls
X509_NAME structure (0 on failure) See other <code>X509_NAME_*</code>
functions to get more info from X509_NAME structure.</p></li>
<li><p>X509_CRL_get_lastUpdate <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns 'lastUpdate' date-time
value of X509_CRL object <code>$x</code>. my $rv =
Net::SSLeay::X509_CRL_get_lastUpdate($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: value corresponding to openssls
ASN1_TIME structure (0 on failure)</p></li>
<li><p>X509_CRL_get_nextUpdate <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns 'nextUpdate' date-time
value of X509_CRL object <code>$x</code>. my $rv =
Net::SSLeay::X509_CRL_get_nextUpdate($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: value corresponding to openssls
ASN1_TIME structure (0 on failure)</p></li>
<li><p>X509_CRL_get_version <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns 'version' value of given
X509_CRL structure <code>$x</code>. my $rv =
Net::SSLeay::X509_CRL_get_version($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: (integer) version</p></li>
<li><p>X509_CRL_set_issuer_name <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Sets the issuer of X509_CRL object <code>$x</code> to X509_NAME object
<code>$name</code>. my $rv = Net::SSLeay::X509_CRL_set_issuer_name($x,
$name); # $x - value corresponding to openssls X509_CRL structure #
$name - value corresponding to openssls X509_NAME structure # # returns:
1 on success, 0 on failure</p></li>
<li><p>X509_CRL_set_lastUpdate <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Sets 'lastUpdate' value of X509_CRL object <code>$x</code> to
<code>$tm</code>. my $rv = Net::SSLeay::X509_CRL_set_lastUpdate($x,
$tm); # $x - value corresponding to openssls X509_CRL structure # $tm -
value corresponding to openssls ASN1_TIME structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_CRL_set_nextUpdate <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Sets 'nextUpdate' value of X509_CRL object <code>$x</code> to
<code>$tm</code>. my $rv = Net::SSLeay::X509_CRL_set_nextUpdate($x,
$tm); # $x - value corresponding to openssls X509_CRL structure # $tm -
value corresponding to openssls ASN1_TIME structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_CRL_set_version <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Sets 'version' value of given X509_CRL structure <code>$x</code> to
<code>$version</code>. my $rv = Net::SSLeay::X509_CRL_set_version($x,
$version); # $x - value corresponding to openssls X509_CRL structure #
$version - (integer) version number (1 = version 2 CRL) # # returns: 1
on success, 0 on failure Note that if you want to use any X509_CRL
extension you need to set version 2 CRL -
<code>Net::SSLeay::X509_CRL_set_version($x, 1)</code>.</p></li>
<li><p>X509_CRL_sign <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Sign X509_CRL object <code>$x</code> with
private key <code>$pkey</code> (using digest algorithm
<code>$md</code>). my $rv = Net::SSLeay::X509_CRL_sign($x, $pkey, $md);
# $x - value corresponding to openssls X509_CRL structure # $pkey -
value corresponding to openssls EVP_PKEY structure # $md - value
corresponding to openssls EVP_MD structure # # returns: 1 on success, 0
on failure</p></li>
<li><p>X509_CRL_sort <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before; requires at least openssl-0.9.7 Sorts the
data of X509_CRL object so it will be written in serial number order. my
$rv = Net::SSLeay::X509_CRL_sort($x); # $x - value corresponding to
openssls X509_CRL structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_CRL_verify <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Verifies X509_CRL object <code>$a</code>
using public key <code>$r</code> (pubkey of issuing CA). my $rv =
Net::SSLeay::X509_CRL_verify($a, $r); # $a - value corresponding to
openssls X509_CRL structure # $r - value corresponding to openssls
EVP_PKEY structure # # returns: 0 - verify failure, 1 - verify OK, &lt;0
- error</p></li>
<li><p>P_X509_CRL_add_revoked_serial_hex <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.45 and before; requires at least
openssl-0.9.7 Adds given serial number <code>$serial_hex</code> to
X509_CRL object <code>$crl</code>.
Net::SSLeay::P_X509_CRL_add_revoked_serial_hex($crl, $serial_hex,
$rev_time, $reason_code, $comp_time); # $crl - value corresponding to
openssls X509_CRL structure # $serial_hex - string (hexadecimal)
representation of serial number # $rev_time - (revocation time) value
corresponding to openssls ASN1_TIME structure # $reason_code -
[optional] (integer) reason code (see below) - default 0 # $comp_time -
[optional] (compromise time) value corresponding to openssls ASN1_TIME
structure # # returns: no return value reason codes: 0 - unspecified 1 -
keyCompromise 2 - CACompromise 3 - affiliationChanged 4 - superseded 5 -
cessationOfOperation 6 - certificateHold 7 - removeFromCRL</p></li>
<li><p>P_X509_CRL_get_serial <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Returns serial number of X509_CRL object. my $rv =
Net::SSLeay::P_X509_CRL_get_serial($crl); # $crl - value corresponding
to openssls X509_CRL structure # # returns: value corresponding to
openssls ASN1_INTEGER structure (0 on failure)</p></li>
<li><p>P_X509_CRL_set_serial <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.7
Sets serial number of X509_CRL object to <code>$crl_number</code>. my
$rv = Net::SSLeay::P_X509_CRL_set_serial($crl, $crl_number); # $crl -
value corresponding to openssls X509_CRL structure # $crl_number - value
corresponding to openssls ASN1_INTEGER structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>P_X509_CRL_add_extensions <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.88 and before Adds one or more X509 extensions
to X509 CRL object <code>$x</code>. my $rv =
Net::SSLeay::P_X509_CRL_add_extensions($x, $ca_cert, $nid, $value); # $x
- value corresponding to openssls X509 CRL structure # $ca_cert - value
corresponding to openssls X509 structure (issuers cert - necessary for
sertting NID_authority_key_identifier) # $nid - NID identifying
extension to be set # $value - extension value # # returns: 1 on
success, 0 on failure For more details see
P_X509_add_extensions.</p></li>
</ul>
<p><em>Low level API: X509_EXTENSION_* related functions</em></p>
<ul>
<li><p>X509_EXTENSION_get_critical <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns 'critical' flag of given
X509_EXTENSION object <code>$ex</code>. my $rv =
Net::SSLeay::X509_EXTENSION_get_critical($ex); # $ex - value
corresponding to openssls X509_EXTENSION structure # # returns:
(integer) 1 - critical, 0 - noncritical</p></li>
<li><p>X509_EXTENSION_get_data <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns value (raw data) of
X509_EXTENSION object <code>$ne</code>. my $rv =
Net::SSLeay::X509_EXTENSION_get_data($ne); # $ne - value corresponding
to openssls X509_EXTENSION structure # # returns: value corresponding to
openssls ASN1_OCTET_STRING structure (0 on failure) Note: you can use
P_ASN1_STRING_get to convert ASN1_OCTET_STRING into perl scalar
variable.</p></li>
<li><p>X509_EXTENSION_get_object <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns OID (ASN1_OBJECT) of
X509_EXTENSION object <code>$ne</code>. my $rv =
Net::SSLeay::X509_EXTENSION_get_object($ex); # $ex - value corresponding
to openssls X509_EXTENSION structure # # returns: value corresponding to
openssls ASN1_OBJECT structure (0 on failure)</p></li>
<li><p>X509V3_EXT_print <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Returns string representation of given
X509_EXTENSION object <code>$ext</code>.
Net::SSLeay::X509V3_EXT_print($ext, $flags, $utf8_decode); # $ext -
value corresponding to openssls X509_EXTENSION structure # $flags -
[optional] (integer) Currently the flag argument is unused and should be
set to 0 # $utf8_decode - [optional] 0 or 1 whether the returned value
should be utf8 decoded (default=0) # # returns: no return value</p></li>
<li><p>X509V3_EXT_d2i Parses an extension and returns its internal
structure. my $rv = Net::SSLeay::X509V3_EXT_d2i($ext); # $ext - value
corresponding to openssls X509_EXTENSION structure # # returns: pointer
???</p></li>
</ul>
<p><em>Low level API: X509_NAME_* related functions</em></p>
<ul>
<li><p>X509_NAME_ENTRY_get_data <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Retrieves the field value of
<code>$ne</code> in and ASN1_STRING structure. my $rv =
Net::SSLeay::X509_NAME_ENTRY_get_data($ne); # $ne - value corresponding
to openssls X509_NAME_ENTRY structure # # returns: value corresponding
to openssls ASN1_STRING structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_ENTRY_get_object.html&gt;</p></li>
<li><p>X509_NAME_ENTRY_get_object <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Retrieves the field name of
<code>$ne</code> in and ASN1_OBJECT structure. my $rv =
Net::SSLeay::X509_NAME_ENTRY_get_object($ne); # $ne - value
corresponding to openssls X509_NAME_ENTRY structure # # returns: value
corresponding to openssls ASN1_OBJECT structure (0 on failure) Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_ENTRY_get_object.html&gt;</p></li>
<li><p>X509_NAME_new <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.55 and before; requires at least openssl-0.9.5 Creates a
new X509_NAME structure. Adds a field whose name is defined by a string
<code>$field</code>. The field value to be added is in
<code>$bytes</code>. my $rv = Net::SSLeay::X509_NAME_new(); # # returns:
value corresponding to openssls X509_NAME structure (0 on
failure)</p></li>
<li><p>X509_NAME_hash <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.55 and before; requires at least openssl-0.9.5 Sort of a
checksum of issuer name <code>$name</code>. The result is not a full
hash (e.g. sha-1), it is kind-of-a-hash truncated to the size of
'unsigned long' (32 bits). The resulting value might differ across
different openssl versions for the same X509 certificate. my $rv =
Net::SSLeay::X509_NAME_hash($name); # $name - value corresponding to
openssls X509_NAME structure # # returns: number representing
checksum</p></li>
<li><p>X509_NAME_add_entry_by_txt <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.5
Adds a field whose name is defined by a string <code>$field</code>. The
field value to be added is in <code>$bytes</code>. my $rv =
Net::SSLeay::X509_NAME_add_entry_by_txt($name, $field, $type, $bytes,
$len, $loc, $set); # $name - value corresponding to openssls X509_NAME
structure # $field - (string) field definition (name) - e.g.
"organizationName" # $type - (integer) type of data in $bytes (see
below) # $bytes - data to be set # $loc - [optional] (integer) index
where the new entry is inserted: if it is -1 (default) it is appended #
$set - [optional] (integer) determines how the new type is added. If it
is 0 (default) a new RDN is created # # returns: 1 on success, 0 on
failure # values for $type - use constants:
&amp;Net::SSLeay::MBSTRING_UTF8 - $bytes contains utf8 encoded data
&amp;Net::SSLeay::MBSTRING_ASC - $bytes contains ASCII data Unicode
note: when passing non-ascii (unicode) string in <code>$bytes</code> do
not forget to set <code>$flags = &amp;Net::SSLeay::MBSTRING_UTF8</code>
and encode the perl <code>$string</code> via
<code>$bytes = encode(utf-8, $string)</code>. Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p></li>
<li><p>X509_NAME_add_entry_by_NID <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.5
Adds a field whose name is defined by a NID <code>$nid</code>. The field
value to be added is in <code>$bytes</code>. my $rv =
Net::SSLeay::X509_NAME_add_entry_by_NID($name, $nid, $type, $bytes,
$len, $loc, $set); # $name - value corresponding to openssls X509_NAME
structure # $nid - (integer) field definition - NID value # $type -
(integer) type of data in $bytes (see below) # $bytes - data to be set #
$loc - [optional] (integer) index where the new entry is inserted: if it
is -1 (default) it is appended # $set - [optional] (integer) determines
how the new type is added. If it is 0 (default) a new RDN is created # #
returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p></li>
<li><p>X509_NAME_add_entry_by_OBJ <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-0.9.5
Adds a field whose name is defined by a object (OID) <code>$obj</code> .
The field value to be added is in <code>$bytes</code>. my $rv =
Net::SSLeay::X509_NAME_add_entry_by_OBJ($name, $obj, $type, $bytes,
$len, $loc, $set); # $name - value corresponding to openssls X509_NAME
structure # $obj - field definition - value corresponding to openssls
ASN1_OBJECT structure # $type - (integer) type of data in $bytes (see
below) # $bytes - data to be set # $loc - [optional] (integer) index
where the new entry is inserted: if it is -1 (default) it is appended #
$set - [optional] (integer) determines how the new type is added. If it
is 0 (default) a new RDN is created # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_add_entry_by_txt.html&gt;</p></li>
<li><p>X509_NAME_cmp <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Compares two X509_NAME obejcts. my $rv =
Net::SSLeay::X509_NAME_cmp($a, $b); # $a - value corresponding to
openssls X509_NAME structure # $b - value corresponding to openssls
X509_NAME structure # # returns: 0 if $a matches $b; non zero
otherwise</p></li>
<li><p>X509_NAME_digest <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.45 and before Computes digest/fingerprint of X509_NAME
<code>$data</code> using <code>$type</code> hash function. my
$digest_value = Net::SSLeay::X509_NAME_digest($data, $type); # $data -
value corresponding to openssls X509_NAME structure # $type - value
corresponding to openssls EVP_MD structure - e.g. got via
EVP_get_digestbyname() # # returns: hash value (binary) #to get
printable (hex) value of digest use: print unpack(H*,
$digest_value);</p></li>
<li><p>X509_NAME_entry_count <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns the total number of
entries in <code>$name</code>. my $rv =
Net::SSLeay::X509_NAME_entry_count($name); # $name - value corresponding
to openssls X509_NAME structure # # returns: (integer) entries count
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p></li>
<li><p>X509_NAME_get_entry <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Retrieves the X509_NAME_ENTRY from
<code>$name</code> corresponding to index <code>$loc</code>. Acceptable
values for <code>$loc</code> run from 0 to
<code>Net::SSLeay::X509_NAME_entry_count($name)- 1</code>. The value
returned is an internal pointer which must not be freed. my $rv =
Net::SSLeay::X509_NAME_get_entry($name, $loc); # $name - value
corresponding to openssls X509_NAME structure # $loc - (integer) index
of wanted entry # # returns: value corresponding to openssls
X509_NAME_ENTRY structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p></li>
<li><p>X509_NAME_print_ex <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.45 and before Returns a string with human readable
version of <code>$name</code>. Net::SSLeay::X509_NAME_print_ex($name,
$flags, $utf8_decode); # $name - value corresponding to openssls
X509_NAME structure # $flags - [optional] conversion flags (default
XN_FLAG_RFC2253) - see below # $utf8_decode - [optional] 0 or 1 whether
the returned value should be utf8 decoded (default=0) # # returns:
string representation of $name #available conversion flags - use
constants: &amp;Net::SSLeay::XN_FLAG_COMPAT
&amp;Net::SSLeay::XN_FLAG_DN_REV
&amp;Net::SSLeay::XN_FLAG_DUMP_UNKNOWN_FIELDS
&amp;Net::SSLeay::XN_FLAG_FN_ALIGN &amp;Net::SSLeay::XN_FLAG_FN_LN
&amp;Net::SSLeay::XN_FLAG_FN_MASK &amp;Net::SSLeay::XN_FLAG_FN_NONE
&amp;Net::SSLeay::XN_FLAG_FN_OID &amp;Net::SSLeay::XN_FLAG_FN_SN
&amp;Net::SSLeay::XN_FLAG_MULTILINE &amp;Net::SSLeay::XN_FLAG_ONELINE
&amp;Net::SSLeay::XN_FLAG_RFC2253
&amp;Net::SSLeay::XN_FLAG_SEP_COMMA_PLUS
&amp;Net::SSLeay::XN_FLAG_SEP_CPLUS_SPC
&amp;Net::SSLeay::XN_FLAG_SEP_MASK
&amp;Net::SSLeay::XN_FLAG_SEP_MULTILINE
&amp;Net::SSLeay::XN_FLAG_SEP_SPLUS_SPC &amp;Net::SSLeay::XN_FLAG_SPC_EQ
Most likely you will be fine with default:
Net::SSLeay::X509_NAME_print_ex($name,
&amp;Net::SSLeay::XN_FLAG_RFC2253); Or you might want RFC2253-like
output without utf8 chars escaping: use Net::SSLeay qw/XN_FLAG_RFC2253
ASN1_STRFLGS_ESC_MSB/; my $flag_rfc22536_utf8 = (XN_FLAG_RFC2253) &amp;
(~ ASN1_STRFLGS_ESC_MSB); my $result =
Net::SSLeay::X509_NAME_print_ex($name, $flag_rfc22536_utf8, 1); Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_print_ex.html&gt;</p></li>
<li><p>X509_NAME_get_text_by_NID Retrieves the text from the first entry
in name which matches <code>$nid</code>, if no such entry exists -1 is
returned. <strong>openssl note:</strong> this is a legacy function which
has various limitations which makes it of minimal use in practice. It
can only find the first matching entry and will copy the contents of the
field verbatim: this can be highly confusing if the target is a
multicharacter string type like a BMPString or a UTF8String.
Net::SSLeay::X509_NAME_get_text_by_NID($name, $nid); # $name - value
corresponding to openssls X509_NAME structure # $nid - NID value
(integer) # # returns: text value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_get_index_by_NID.html&gt;</p></li>
<li><p>X509_NAME_oneline Return an ASCII version of <code>$name</code>.
Net::SSLeay::X509_NAME_oneline($name); # $name - value corresponding to
openssls X509_NAME structure # # returns: (string) ASCII version of
$name Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_NAME_print_ex.html&gt;</p></li>
<li><p>sk_X509_NAME_free Free an allocated STACK_OF(X509_NAME)
structure. Net::SSLeay::sk_X509_NAME_free($sk); # $sk - value
corresponding to openssls STACK_OF(X509_NAME) structure # # returns: no
return value</p></li>
<li><p>sk_X509_NAME_num Return number of items in STACK_OF(X509_NAME) my
$rv = Net::SSLeay::sk_X509_NAME_num($sk); # $sk - value corresponding to
openssls STACK_OF(X509_NAME) structure # # returns: number of
items</p></li>
<li><p>sk_X509_NAME_value Returns X509_NAME from position
<code>$index</code> in STACK_OF(X509_NAME) my $rv =
Net::SSLeay::sk_X509_NAME_value($sk, $i); # $sk - value corresponding to
openssls STACK_OF(X509_NAME) structure # $i - (integer) index/position #
# returns: value corresponding to openssls X509_NAME structure (0 on
failure)</p></li>
<li><p>add_file_cert_subjects_to_stack Add a file of certs to a stack.
All certs in <code>$file</code> that are not already in the
<code>$stackCAs</code> will be added. my $rv =
Net::SSLeay::add_file_cert_subjects_to_stack($stackCAs, $file); #
$stackCAs - value corresponding to openssls STACK_OF(X509_NAME)
structure # $file - (string) filename # # returns: 1 on success, 0 on
failure</p></li>
<li><p>add_dir_cert_subjects_to_stack Add a directory of certs to a
stack. All certs in <code>$dir</code> that are not already in the
<code>$stackCAs</code> will be added. my $rv =
Net::SSLeay::add_dir_cert_subjects_to_stack($stackCAs, $dir); #
$stackCAs - value corresponding to openssls STACK_OF(X509_NAME)
structure # $dir - (string) the directory to append from. All files in
this directory will be examined as potential certs. Any that are
acceptable to SSL_add_dir_cert_subjects_to_stack() that are not already
in the stack will be included. # # returns: 1 on success, 0 on
failure</p></li>
</ul>
<p><em>Low level API: X509_STORE_* related functions</em></p>
<ul>
<li><p>X509_STORE_CTX_new returns a newly initialised X509_STORE_CTX
structure.</p></li>
<li><p>X509_STORE_CTX_init <strong>X509_STORE_CTX_init()</strong> sets
up an X509_STORE_CTX for a subsequent verification operation. It must be
called before each call to <strong>X509_verify_cert()</strong>. my $rv =
Net::SSLeay::X509_STORE_CTX_init($x509_store_ctx, $x509_store, $x509,
$chain); # $x509_store_ctx - value corresponding to openssls
X509_STORE_CTX structure (required) # $x509_store - value corresponding
to openssls X509_STORE structure (optional) # $x509 - value
corresponding to openssls X509 structure (optional) # $chain - value
corresponding to openssls STACK_OF(X509) structure (optional) # #
returns: 1 on success, 0 on failure # # Note: returns nothing with
Net::SSLeay 1.90 and earlier. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_init.html&gt;</p></li>
<li><p>X509_STORE_CTX_free Frees an X509_STORE_CTX structure.
Net::SSLeay::X509_STORE_CTX_free($x509_store_ctx); #
<code>$x509_store_ctx</code> - value corresponding to openssl's
X509_STORE_CTX structure</p></li>
<li><p>X509_verify_cert The <strong>X509_verify_cert()</strong> function
attempts to discover and validate a certificate chain based on
parameters in ctx. A complete description of the process is contained in
the <strong>verify</strong>(1) manual page. If this function returns 0,
use X509_STORE_CTX_get_error to get additional error information. my $rv
= Net::SSLeay::X509_verify_cert($x509_store_ctx); # $x509_store_ctx -
value corresponding to openssls X509_STORE_CTX structure # # returns: 1
if a complete chain can be built and validated, otherwise 0 Check
openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/X509_verify_cert.html&gt;</p></li>
<li><p>X509_STORE_CTX_get_current_cert Returns the certificate in ctx
which caused the error or 0 if no certificate is relevant. my $rv =
Net::SSLeay::X509_STORE_CTX_get_current_cert($x509_store_ctx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # # returns: value corresponding to openssls X509 structure (0
on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p></li>
<li><p>X509_STORE_CTX_get0_cert <strong>COMPATIBILITY</strong>: not
available in Net-SSLeay-1.88 and before; requires at least OpenSSL
1.1.0pre6 or LibreSSL 2.7.0 Returns an internal pointer to the
certificate being verified by the ctx. my $x509 =
Net::SSLeay::X509_STORE_CTX_get0_cert($x509_store_ctx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # # returns: value corresponding to openssls X509 structure
Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get0_cert.html&gt;</p></li>
<li><p>X509_STORE_CTX_get1_chain Returns a returns a complete validate
chain if a previous call to <strong>X509_verify_cert()</strong> is
successful. my $rv =
Net::SSLeay::X509_STORE_CTX_get1_chain($x509_store_ctx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # # returns: value corresponding to openssls STACK_OF(X509)
structure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/X509_STORE_CTX_get1_chain.html&gt;</p></li>
<li><p>X509_STORE_CTX_get_error Returns the error code of
<code>$ctx</code>. my $rv =
Net::SSLeay::X509_STORE_CTX_get_error($x509_store_ctx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # # returns: (integer) error code For more info about erro
code values check function get_verify_result. Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p></li>
<li><p>X509_STORE_CTX_get_error_depth Returns the depth of the error.
This is a non-negative integer representing where in the certificate
chain the error occurred. If it is zero it occurred in the end entity
certificate, one if it is the certificate which signed the end entity
certificate and so on. my $rv =
Net::SSLeay::X509_STORE_CTX_get_error_depth($x509_store_ctx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # # returns: (integer) depth Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p></li>
<li><p>X509_STORE_CTX_get_ex_data Is used to retrieve the information
for <code>$idx</code> from <code>$x509_store_ctx</code>. my $rv =
Net::SSLeay::X509_STORE_CTX_get_ex_data($x509_store_ctx, $idx); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # $idx - (integer) index for application specific data # #
returns: pointer to ???</p></li>
<li><p>X509_STORE_CTX_set_ex_data Is used to store application data at
arg for idx into <code>$x509_store_ctx</code>. my $rv =
Net::SSLeay::X509_STORE_CTX_set_ex_data($x509_store_ctx, $idx, $data); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # $idx - (integer) ??? # $data - (pointer) ??? # # returns: 1
on success, 0 on failure</p></li>
<li><p>X509_STORE_CTX_set_cert Sets the certificate to be verified in
<code>$x509_store_ctx</code> to <code>$x</code>.
Net::SSLeay::X509_STORE_CTX_set_cert($x509_store_ctx, $x); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # $x - value corresponding to openssls X509 structure # #
returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_new.html&gt;</p></li>
<li><p>X509_STORE_new Returns a newly initialized X509_STORE structure.
my $rv = Net::SSLeay::X509_STORE_new(); # # returns: value corresponding
to openssls X509_STORE structure (0 on failure)</p></li>
<li><p>X509_STORE_free Frees an X509_STORE structure
Net::SSLeay::X509_STORE_free($x509_store); # $x509_store - value
corresponding to openssls X509_STORE structure</p></li>
<li><p>X509_STORE_add_lookup Adds a lookup to an X509_STORE for a given
lookup method. my $method = &amp;Net::SSLeay::X509_LOOKUP_hash_dir; my
$rv = Net::SSLeay::X509_STORE_add_lookup($x509_store, $method); #
$method - value corresponding to openssls X509_LOOKUP_METHOD structure #
$x509_store - value corresponding to openssls X509_STORE structure # #
returns: value corresponding to openssls X509_LOOKUP structure Check
openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/X509_STORE_add_lookup.html&gt;</p></li>
<li><p>X509_STORE_CTX_set_error Sets the error code of <code>$ctx</code>
to <code>$s</code>. For example it might be used in a verification
callback to set an error based on additional checks.
Net::SSLeay::X509_STORE_CTX_set_error($x509_store_ctx, $s); #
$x509_store_ctx - value corresponding to openssls X509_STORE_CTX
structure # $s - (integer) error id # # returns: no return value Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_STORE_CTX_get_error.html&gt;</p></li>
<li><p>X509_STORE_add_cert Adds X509 certificate <code>$x</code> into
the X509_STORE <code>$store</code>. my $rv =
Net::SSLeay::X509_STORE_add_cert($store, $x); # $store - value
corresponding to openssls X509_STORE structure # $x - value
corresponding to openssls X509 structure # # returns: 1 on success, 0 on
failure</p></li>
<li><p>X509_STORE_add_crl Adds X509 CRL <code>$x</code> into the
X509_STORE <code>$store</code>. my $rv =
Net::SSLeay::X509_STORE_add_crl($store, $x); # $store - value
corresponding to openssls X509_STORE structure # $x - value
corresponding to openssls X509_CRL structure # # returns: 1 on success,
0 on failure</p></li>
<li><p>X509_STORE_set1_param ??? (more info needed) my $rv =
Net::SSLeay::X509_STORE_set1_param($store, $pm); # $store - value
corresponding to openssls X509_STORE structure # $pm - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_LOOKUP_hash_dir Returns an X509_LOOKUP structure that
instructs an X509_STORE to load files from a directory containing
certificates with filenames in the format <em>hash.N</em> or crls with
filenames in the format <em>hash.</em><strong>r</strong><em>N</em> my
$rv = Net::SSLeay::X509_LOOKUP_hash_dir(); # # returns: value
corresponding to openssls X509_LOOKUP_METHOD structure, with the hashed
directory method Check openssl doc
&lt;https://www.openssl.org/docs/man1.1.1/man3/X509_load_crl_file.html&gt;</p></li>
<li><p>X509_LOOKUP_add_dir Add a directory to an X509_LOOKUP structure,
usually obtained from X509_STORE_add_lookup. my $method =
&amp;Net::SSLeay::X509_LOOKUP_hash_dir; my $lookup =
Net::SSLeay::X509_STORE_add_lookup($x509_store, $method); my $type =
&amp;Net::SSLeay::X509_FILETYPE_PEM;
Net::SSLeay::X509_LOOKUP_add_dir($lookup, $dir, $type); # $lookup -
value corresponding to openssls X509_LOOKUP structure # $dir - string
path to a directory # $type - constant corresponding to the type of file
in the directory - can be X509_FILETYPE_PEM, X509_FILETYPE_DEFAULT, or
X509_FILETYPE_ASN1</p></li>
<li><p>X509_STORE_set_flags Net::SSLeay::X509_STORE_set_flags($ctx,
$flags); # $ctx - value corresponding to openssls X509_STORE structure #
$flags - (unsigned long) flags to be set (bitmask) # # returns: no
return value #to create $flags value use corresponding constants like
$flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK(); For more details about
<code>$flags</code> bitmask see X509_VERIFY_PARAM_set_flags.</p></li>
<li><p>X509_STORE_set_purpose Net::SSLeay::X509_STORE_set_purpose($ctx,
$purpose); # $ctx - value corresponding to openssls X509_STORE structure
# $purpose - (integer) purpose identifier # # returns: no return value
For more details about <code>$purpose</code> identifier check
CTX_set_purpose.</p></li>
<li><p>X509_STORE_set_trust Net::SSLeay::X509_STORE_set_trust($ctx,
$trust); # $ctx - value corresponding to openssls X509_STORE structure #
$trust - (integer) trust identifier # # returns: no return value For
more details about <code>$trust</code> identifier check
CTX_set_trust.</p></li>
</ul>
<p><em>Low Level API: X509_INFO related functions</em></p>
<ul>
<li><p>sk_X509_INFO_num Returns the number of values in a
STACK_OF(X509_INFO) structure. my $rv =
Net::SSLeay::sk_X509_INFO_num($sk_x509_info); # $sk_x509_info - value
corresponding to openssls STACK_OF(X509_INFO) structure # # returns:
number of values in $sk_X509_info</p></li>
<li><p>sk_X509_INFO_value Returns the value of a STACK_OF(X509_INFO)
structure at a given index. my $rv =
Net::SSLeay::sk_X509_INFO_value($sk_x509_info, $index); # $sk_x509_info
- value corresponding to openssls STACK_OF(X509_INFO) structure # $index
- index into the stack # # returns: value corresponding to openssls
X509_INFO structure at the given index</p></li>
<li><p>P_X509_INFO_get_x509 Returns the X509 structure stored in an
X509_INFO structure. my $rv =
Net::SSLeay::P_X509_INFO_get_x509($x509_info); # $x509_info - value
corresponding to openssls X509_INFO structure # # returns: value
corresponding to openssls X509 structure</p></li>
</ul>
<p><em>Low level API: X509_VERIFY_PARAM_* related functions</em></p>
<ul>
<li><p>X509_VERIFY_PARAM_add0_policy Enables policy checking (it is
disabled by default) and adds <code>$policy</code> to the acceptable
policy set. my $rv = Net::SSLeay::X509_VERIFY_PARAM_add0_policy($param,
$policy); # $param - value corresponding to openssls X509_VERIFY_PARAM
structure # $policy - value corresponding to openssls ASN1_OBJECT
structure # # returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_add0_table ??? (more info needed) my $rv =
Net::SSLeay::X509_VERIFY_PARAM_add0_table($param); # $param - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_VERIFY_PARAM_add1_host <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta2 or LibreSSL 2.7.0 Adds an additional reference identifier
that can match the peer's certificate. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_add1_host($param, $name); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $name -
(string) name to be set # # returns: 1 on success, 0 on failure See also
OpenSSL docs, X509_VERIFY_PARAM_set1_host and
X509_VERIFY_PARAM_set_hostflags for more information, including wildcard
matching. Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_clear_flags Clears the flags
<code>$flags</code> in param. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_clear_flags($param, $flags); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $flags -
(unsigned long) flags to be set (bitmask) # # returns: 1 on success, 0
on failure For more details about <code>$flags</code> bitmask see
X509_VERIFY_PARAM_set_flags. Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_free Frees up the X509_VERIFY_PARAM structure.
Net::SSLeay::X509_VERIFY_PARAM_free($param); # $param - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns: no
return value</p></li>
<li><p>X509_VERIFY_PARAM_get0_peername <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta2 or LibreSSL 2.7.0 Returns the DNS hostname or subject
CommonName from the peer certificate that matched one of the reference
identifiers. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_get0_peername($param); # $param - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns:
(string) name e.g. *.example.com or undef Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_get_depth Returns the current verification
depth. my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_depth($param); #
$param - value corresponding to openssls X509_VERIFY_PARAM structure # #
returns: (ineger) depth Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_get_flags Returns the current verification
flags. my $rv = Net::SSLeay::X509_VERIFY_PARAM_get_flags($param); #
$param - value corresponding to openssls X509_VERIFY_PARAM structure # #
returns: (unsigned long) flags to be set (bitmask) For more details
about returned flags bitmask see X509_VERIFY_PARAM_set_flags. Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_flags my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set_flags($param, $flags); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $flags -
(unsigned long) flags to be set (bitmask) # # returns: 1 on success, 0
on failure #to create $flags value use corresponding constants like
$flags = Net::SSLeay::X509_V_FLAG_CRL_CHECK(); For more details about
<code>$flags</code> bitmask, see the OpenSSL docs below. Check openssl
doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_inherit ??? (more info needed) my $rv =
Net::SSLeay::X509_VERIFY_PARAM_inherit($to, $from); # $to - value
corresponding to openssls X509_VERIFY_PARAM structure # $from - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_VERIFY_PARAM_lookup Finds X509_VERIFY_PARAM by name. my $rv
= Net::SSLeay::X509_VERIFY_PARAM_lookup($name); # $name - (string) name
we want to find # # returns: value corresponding to openssls
X509_VERIFY_PARAM structure (0 on failure)</p></li>
<li><p>X509_VERIFY_PARAM_new Creates a new X509_VERIFY_PARAM structure.
my $rv = Net::SSLeay::X509_VERIFY_PARAM_new(); # # returns: value
corresponding to openssls X509_VERIFY_PARAM structure (0 on
failure)</p></li>
<li><p>X509_VERIFY_PARAM_set1 Sets the name of X509_VERIFY_PARAM
structure <code>$to</code> to the same value as the name of
X509_VERIFY_PARAM structure <code>$from</code>. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set1($to, $from); # $to - value
corresponding to openssls X509_VERIFY_PARAM structure # $from - value
corresponding to openssls X509_VERIFY_PARAM structure # # returns: 1 on
success, 0 on failure</p></li>
<li><p>X509_VERIFY_PARAM_set1_email <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta1 or LibreSSL 2.7.0 Sets the expected RFC822 email address to
email. my $rv = Net::SSLeay::X509_VERIFY_PARAM_set1_email($param,
$email); # $param - value corresponding to openssls X509_VERIFY_PARAM
structure # $email - (string) email to be set # # returns: 1 on success,
0 on failure Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set1_host <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta1 or LibreSSL 2.7.0 Sets the expected DNS hostname to name
clearing any previously specified host name or names. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set1_host($param, $name); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $name -
(string) name to be set # # returns: 1 on success, 0 on failure See also
OpenSSL docs, X509_VERIFY_PARAM_add1_host and
X509_VERIFY_PARAM_set_hostflags for more information, including wildcard
matching. Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set1_ip <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta1 or LibreSSL 2.7.0 Sets the expected IP address to ip. my $rv
= Net::SSLeay::X509_VERIFY_PARAM_set1_ip($param, $ip); # $param - value
corresponding to openssls X509_VERIFY_PARAM structure # $ip - (binary) 4
octet IPv4 or 16 octet IPv6 address # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set1_ip_asc <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta1 or LibreSSL 2.7.0 Sets the expected IP address to ipasc. my
$rv = Net::SSLeay::X509_VERIFY_PARAM_set1_asc($param, $ipasc); # $param
- value corresponding to openssls X509_VERIFY_PARAM structure # $ip -
(string) IPv4 or IPv6 address # # returns: 1 on success, 0 on failure
Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set1_name Sets the name of X509_VERIFY_PARAM
structure <code>$param</code> to <code>$name</code>. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set1_name($param, $name); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $name -
(string) name to be set # # returns: 1 on success, 0 on failure</p></li>
<li><p>X509_VERIFY_PARAM_set1_policies Enables policy checking (it is
disabled by default) and sets the acceptable policy set to policies. Any
existing policy set is cleared. The policies parameter can be 0 to clear
an existing policy set. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set1_policies($param, $policies); #
$param - value corresponding to openssls X509_VERIFY_PARAM structure #
$policies - value corresponding to openssls STACK_OF(ASN1_OBJECT)
structure # # returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_depth Sets the maximum verification depth
to depth. That is the maximum number of untrusted CA certificates that
can appear in a chain. Net::SSLeay::X509_VERIFY_PARAM_set_depth($param,
$depth); # $param - value corresponding to openssls X509_VERIFY_PARAM
structure # $depth - (integer) depth to be set # # returns: no return
value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_hostflags <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.82 and before; requires at least OpenSSL
1.0.2-beta2 or LibreSSL 2.7.0
Net::SSLeay::X509_VERIFY_PARAM_set_hostflags($param, $flags); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $flags -
(unsigned int) flags to be set (bitmask) # # returns: no return value
See also OpenSSL docs, X509_VERIFY_PARAM_add1_host and
X509_VERIFY_PARAM_set1_host for more information. The flags for
controlling wildcard checks and other features are defined in OpenSSL
docs. Check openssl doc
&lt;https://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_purpose Sets the verification purpose in
<code>$param</code> to <code>$purpose</code>. This determines the
acceptable purpose of the certificate chain, for example SSL client or
SSL server. my $rv = Net::SSLeay::X509_VERIFY_PARAM_set_purpose($param,
$purpose); # $param - value corresponding to openssls X509_VERIFY_PARAM
structure # $purpose - (integer) purpose identifier # # returns: 1 on
success, 0 on failure For more details about <code>$purpose</code>
identifier check CTX_set_purpose. Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_time Sets the verification time in
<code>$param</code> to <code>$t</code>. Normally the current time is
used. Net::SSLeay::X509_VERIFY_PARAM_set_time($param, $t); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $t -
(time_t) time in seconds since 1.1.1970 # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_set_trust Sets the trust setting in
<code>$param</code> to <code>$trust</code>. my $rv =
Net::SSLeay::X509_VERIFY_PARAM_set_trust($param, $trust); # $param -
value corresponding to openssls X509_VERIFY_PARAM structure # $trust -
(integer) trust identifier # # returns: 1 on success, 0 on failure For
more details about <code>$trust</code> identifier check CTX_set_trust.
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/X509_VERIFY_PARAM_set_flags.html&gt;</p></li>
<li><p>X509_VERIFY_PARAM_table_cleanup ??? (more info needed)
Net::SSLeay::X509_VERIFY_PARAM_table_cleanup(); # # returns: no return
value</p></li>
</ul>
<p><em>Low level API: Cipher (EVP_CIPHER_*) related functions</em></p>
<ul>
<li><p>EVP_get_cipherbyname <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before Returns an EVP_CIPHER structure
when passed a cipher name. my $rv =
Net::SSLeay::EVP_get_cipherbyname($name); # $name - (string) cipher name
e.g. aes-128-cbc, camellia-256-ecb, des-ede, ... # # returns: value
corresponding to openssls EVP_CIPHER structure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/EVP_EncryptInit.html&gt;</p></li>
</ul>
<p><em>Low level API: Digest (EVP_MD_*) related functions</em></p>
<ul>
<li><p>OpenSSL_add_all_digests <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.42 and before
Net::SSLeay::OpenSSL_add_all_digests(); # no args, no return value
http://www.openssl.org/docs/crypto/OpenSSL_add_all_algorithms.html</p></li>
<li><p>P_EVP_MD_list_all <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.42 and before; requires at least openssl-1.0.0
<strong>NOTE:</strong> Does not exactly correspond to any low level API
function my $rv = Net::SSLeay::P_EVP_MD_list_all(); # # returns:
arrayref - list of available digest names The returned digest names
correspond to values expected by EVP_get_digestbyname. Note that some of
the digests are available by default and some only after calling
OpenSSL_add_all_digests.</p></li>
<li><p>EVP_get_digestbyname <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.42 and before my $rv =
Net::SSLeay::EVP_get_digestbyname($name); # $name - string with digest
name # # returns: value corresponding to openssls EVP_MD structure The
<code>$name</code> param can be: md2 md4 md5 mdc2 ripemd160 sha sha1
sha224 sha256 sha512 whirlpool Or better check the supported digests by
calling P_EVP_MD_list_all.</p></li>
<li><p>EVP_MD_type <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before my $rv = Net::SSLeay::EVP_MD_type($md); # $md
- value corresponding to openssls EVP_MD structure # # returns: the NID
(integer) of the OBJECT IDENTIFIER representing the given message
digest</p></li>
<li><p>EVP_MD_size <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before my $rv = Net::SSLeay::EVP_MD_size($md); # $md
- value corresponding to openssls EVP_MD structure # # returns: the size
of the message digest in bytes (e.g. 20 for SHA1)</p></li>
<li><p>EVP_MD_CTX_md <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.7
Net::SSLeay::EVP_MD_CTX_md($ctx); # $ctx - value corresponding to
openssls EVP_MD_CTX structure # # returns: value corresponding to
openssls EVP_MD structure</p></li>
<li><p>EVP_MD_CTX_create <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.42 and before; requires at least openssl-0.9.7
Allocates, initializes and returns a digest context. my $rv =
Net::SSLeay::EVP_MD_CTX_create(); # # returns: value corresponding to
openssls EVP_MD_CTX structure The complete idea behind EVP_MD_CTX looks
like this example: Net::SSLeay::OpenSSL_add_all_digests(); my $md =
Net::SSLeay::EVP_get_digestbyname("sha1"); my $ctx =
Net::SSLeay::EVP_MD_CTX_create(); Net::SSLeay::EVP_DigestInit($ctx,
$md); while(my $chunk = get_piece_of_data()) {
Net::SSLeay::EVP_DigestUpdate($ctx,$chunk); } my $result =
Net::SSLeay::EVP_DigestFinal($ctx);
Net::SSLeay::EVP_MD_CTX_destroy($ctx); print "digest=", unpack(H*,
$result), "\n"; #print hex value</p></li>
<li><p>EVP_DigestInit_ex <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Sets up
digest context <code>$ctx</code> to use a digest <code>$type</code> from
ENGINE <code>$impl</code>, <code>$ctx</code> must be initialized before
calling this function, type will typically be supplied by a function
such as EVP_get_digestbyname. If <code>$impl</code> is 0 then the
default implementation of digest <code>$type</code> is used. my $rv =
Net::SSLeay::EVP_DigestInit_ex($ctx, $type, $impl); # $ctx - value
corresponding to openssls EVP_MD_CTX structure # $type - value
corresponding to openssls EVP_MD structure # $impl - value corresponding
to openssls ENGINE structure # # returns: 1 for success and 0 for
failure</p></li>
<li><p>EVP_DigestInit <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Behaves in
the same way as EVP_DigestInit_ex except the passed context
<code>$ctx</code> does not have to be initialized, and it always uses
the default digest implementation. my $rv =
Net::SSLeay::EVP_DigestInit($ctx, $type); # $ctx - value corresponding
to openssls EVP_MD_CTX structure # $type - value corresponding to
openssls EVP_MD structure # # returns: 1 for success and 0 for
failure</p></li>
<li><p>EVP_MD_CTX_destroy <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Cleans up
digest context <code>$ctx</code> and frees up the space allocated to it,
it should be called only on a context created using EVP_MD_CTX_create.
Net::SSLeay::EVP_MD_CTX_destroy($ctx); # $ctx - value corresponding to
openssls EVP_MD_CTX structure # # returns: no return value</p></li>
<li><p>EVP_DigestUpdate <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 my $rv =
Net::SSLeay::EVP_DigestUpdate($ctx, $data); # $ctx - value corresponding
to openssls EVP_MD_CTX structure # $data - data to be hashed # #
returns: 1 for success and 0 for failure</p></li>
<li><p>EVP_DigestFinal_ex <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Retrieves
the digest value from <code>$ctx</code>. After calling
EVP_DigestFinal_ex no additional calls to EVP_DigestUpdate can be made,
but EVP_DigestInit_ex can be called to initialize a new digest
operation. my $digest_value = Net::SSLeay::EVP_DigestFinal_ex($ctx); #
$ctx - value corresponding to openssls EVP_MD_CTX structure # # returns:
hash value (binary) #to get printable (hex) value of digest use: print
unpack(H*, $digest_value);</p></li>
<li><p>EVP_DigestFinal <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Similar to
EVP_DigestFinal_ex except the digest context ctx is automatically
cleaned up. my $rv = Net::SSLeay::EVP_DigestFinal($ctx); # $ctx - value
corresponding to openssls EVP_MD_CTX structure # # returns: hash value
(binary) #to get printable (hex) value of digest use: print unpack(H*,
$digest_value);</p></li>
<li><p>MD2 <strong>COMPATIBILITY:</strong> no supported by default in
openssl-1.0.0 Computes MD2 from given <code>$data</code> (all data needs
to be loaded into memory) my $digest = Net::SSLeay::MD2($data); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>MD4 Computes MD4 from given <code>$data</code> (all data needs to
be loaded into memory) my $digest = Net::SSLeay::MD4($data); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>MD5 Computes MD5 from given <code>$data</code> (all data needs to
be loaded into memory) my $digest = Net::SSLeay::MD5($data); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>RIPEMD160 Computes RIPEMD160 from given <code>$data</code> (all
data needs to be loaded into memory) my $digest =
Net::SSLeay::RIPEMD160($data); print "digest(hexadecimal)=", unpack(H*,
$digest);</p></li>
<li><p>SHA1 <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before Computes SHA1 from given <code>$data</code>
(all data needs to be loaded into memory) my $digest =
Net::SSLeay::SHA1($data); print "digest(hexadecimal)=", unpack(H*,
$digest);</p></li>
<li><p>SHA256 <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.8 Computes
SHA256 from given <code>$data</code> (all data needs to be loaded into
memory) my $digest = Net::SSLeay::SHA256($data); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>SHA512 <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.8 Computes
SHA512 from given <code>$data</code> (all data needs to be loaded into
memory) my $digest = Net::SSLeay::SHA512($data); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>EVP_Digest <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.7 Computes any
digest from given <code>$data</code> (all data needs to be loaded into
memory) my $md = Net::SSLeay::EVP_get_digestbyname("sha1"); #or any
other algorithm my $digest = Net::SSLeay::EVP_Digest($data, $md); print
"digest(hexadecimal)=", unpack(H*, $digest);</p></li>
<li><p>EVP_sha1 <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before my $md = Net::SSLeay::EVP_sha1(); # #
returns: value corresponding to openssls EVP_MD structure</p></li>
<li><p>EVP_sha256 <strong>COMPATIBILITY:</strong> requires at least
openssl-0.9.8 my $md = Net::SSLeay::EVP_sha256(); # # returns: value
corresponding to openssls EVP_MD structure</p></li>
<li><p>EVP_sha512 <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before; requires at least openssl-0.9.8 my $md =
Net::SSLeay::EVP_sha512(); # # returns: value corresponding to openssls
EVP_MD structure</p></li>
<li><p>EVP_add_digest my $rv = Net::SSLeay::EVP_add_digest($digest); #
$digest - value corresponding to openssls EVP_MD structure # # returns:
1 on success, 0 otherwise</p></li>
</ul>
<p><em>Low level API: CIPHER_* related functions</em></p>
<ul>
<li><p>CIPHER_get_name <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.42 and before Returns name of the cipher used. my $rv =
Net::SSLeay::CIPHER_get_name($cipher); # $cipher - value corresponding
to openssls SSL_CIPHER structure # # returns: (string) cipher name e.g.
DHE-RSA-AES256-SHA, (NONE) if $cipher is undefined. Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html&gt;
Example: my $ssl_cipher = Net::SSLeay::get_current_cipher($ssl); my
$cipher_name = Net::SSLeay::CIPHER_get_name($ssl_cipher);</p></li>
<li><p>CIPHER_description <strong>COMPATIBILITY:</strong> doesn't work
correctly in Net-SSLeay-1.88 and before Returns a textual description of
the cipher used. my $rv = Net::SSLeay::CIPHER_description($cipher); #
$cipher - value corresponding to openssls SSL_CIPHER structure # #
returns: (string) cipher description e.g. DHE-RSA-AES256-SHA SSLv3 Kx=DH
Au=RSA Enc=AES(256) Mac=SHA1 Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CIPHER_description.html&gt;</p></li>
<li><p>CIPHER_get_bits <strong>COMPATIBILITY:</strong>
<code>$alg_bits</code> doesn't work correctly in Net-SSLeay-1.88 and
before Returns the number of secret bits used for cipher. my $rv =
Net::SSLeay::CIPHER_get_bits($cipher, $alg_bits); # $cipher - value
corresponding to openssls SSL_CIPHER structure # $alg_bits - [optional]
empty scalar for storing additional return value # # returns: (integer)
number of secret bits, 0 on error # (integer) in $alg_bits for bits
processed by the chosen algorithm Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CIPHER_get_bits.html&gt;
Example: # bits and alg_bits are not equal for e.g.,
TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA, # RFC 8422 name
TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA my $alg_bits; my $bits =
Net::SSLeay::CIPHER_get_bits($cipher, $alg_bits); #my $bits =
Net::SSLeay::CIPHER_get_bits($cipher); print "bits: $bits, alg_bits:
$alg_bits\n";</p></li>
<li><p>CIPHER_get_version <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.88 and before Returns version of SSL/TLS protocol that
first defined the cipher my $rv =
Net::SSLeay::CIPHER_get_version($cipher); # $cipher - value
corresponding to openssls SSL_CIPHER structure # # returns: (string)
cipher name e.g. TLSv1/SSLv3 with some libraries, TLSv1.0 or TLSv1.3,
(NONE) if $cipher is undefined. Check openssl doc
&lt;https://www.openssl.org/docs/ssl/SSL_CIPHER_get_version.html&gt;</p></li>
</ul>
<p><em>Low level API: RSA_* related functions</em></p>
<ul>
<li><p>RSA_generate_key Generates a key pair and returns it in a newly
allocated RSA structure. The pseudo-random number generator must be
seeded prior to calling RSA_generate_key. my $rv =
Net::SSLeay::RSA_generate_key($bits, $e, $perl_cb, $perl_cb_arg); #
$bits - (integer) modulus size in bits e.g. 512, 1024, 2048 # $e -
(integer) public exponent, an odd number, typically 3, 17 or 65537 #
$perl_cb - [optional] reference to perl callback function # $perl_cb_arg
- [optional] data that will be passed to callback function when invoked
# # returns: value corresponding to openssls RSA structure (0 on
failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RSA_generate_key.html&gt;</p></li>
<li><p>RSA_free Frees the RSA structure and its components. The key is
erased before the memory is returned to the system.
Net::SSLeay::RSA_free($r); # $r - value corresponding to openssls RSA
structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/RSA_new.html&gt;</p></li>
<li><p>RSA_get_key_parameters Returns a list of pointers to BIGNUMs
representing the parameters of the key in this order: (n, e, d, p, q,
dmp1, dmq1, iqmp) Caution: returned list consists of SV pointers to
BIGNUMs, which would need to be blessed as Crypt::OpenSSL::Bignum for
further use my (@params) = RSA_get_key_parameters($r);</p></li>
</ul>
<p><em>Low level API: BIO_* related functions</em></p>
<ul>
<li><p>BIO_eof Returns 1 if the BIO has read EOF, the precise meaning of
'EOF' varies according to the BIO type. my $rv =
Net::SSLeay::BIO_eof($s); # $s - value corresponding to openssls BIO
structure # # returns: 1 if EOF has been reached 0 otherwise Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p></li>
<li><p>BIO_f_ssl Returns the SSL BIO method. This is a filter BIO which
is a wrapper round the OpenSSL SSL routines adding a BIO 'flavour' to
SSL I/O. my $rv = Net::SSLeay::BIO_f_ssl(); # # returns: value
corresponding to openssls BIO_METHOD structure (0 on failure) Check
openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
<li><p>BIO_free Frees up a single BIO. my $rv =
Net::SSLeay::BIO_free($bio;); # $bio; - value corresponding to openssls
BIO structure # # returns: 1 on success, 0 on failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_new.html&gt;</p></li>
<li><p>BIO_new Returns a new BIO using method <code>$type</code> my $rv
= Net::SSLeay::BIO_new($type); # $type - value corresponding to openssls
BIO_METHOD structure # # returns: value corresponding to openssls BIO
structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_new.html&gt;</p></li>
<li><p>BIO_new_buffer_ssl_connect Creates a new BIO chain consisting of
a buffering BIO, an SSL BIO (using ctx) and a connect BIO. my $rv =
Net::SSLeay::BIO_new_buffer_ssl_connect($ctx); # $ctx - value
corresponding to openssls SSL_CTX structure # # returns: value
corresponding to openssls BIO structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
<li><p>BIO_new_file Creates a new file BIO with mode <code>$mode</code>
the meaning of mode is the same as the stdio function
<strong>fopen()</strong>. The BIO_CLOSE flag is set on the returned BIO.
my $rv = Net::SSLeay::BIO_new_file($filename, $mode); # $filename -
(string) filename # $mode - (string) opening mode (as mode by stdio
function fopen) # # returns: value corresponding to openssls BIO
structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_s_file.html&gt;</p></li>
<li><p>BIO_new_ssl Allocates an SSL BIO using SSL_CTX ctx and using
client mode if client is non zero. my $rv =
Net::SSLeay::BIO_new_ssl($ctx, $client); # $ctx - value corresponding to
openssls SSL_CTX structure # $client - (integer) 0 or 1 - indicates ssl
client mode # # returns: value corresponding to openssls BIO structure
(0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
<li><p>BIO_new_ssl_connect Creates a new BIO chain consisting of an SSL
BIO (using ctx) followed by a connect BIO. my $rv =
Net::SSLeay::BIO_new_ssl_connect($ctx); # $ctx - value corresponding to
openssls SSL_CTX structure # # returns: value corresponding to openssls
BIO structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
<li><p>BIO_pending Return the number of pending characters in the BIOs
read buffers. my $rv = Net::SSLeay::BIO_pending($s); # $s - value
corresponding to openssls BIO structure # # returns: the amount of
pending data Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p></li>
<li><p>BIO_wpending Return the number of pending characters in the BIOs
write buffers. my $rv = Net::SSLeay::BIO_wpending($s); # $s - value
corresponding to openssls BIO structure # # returns: the amount of
pending data Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_ctrl.html&gt;</p></li>
<li><p>BIO_read Read the underlying descriptor.
Net::SSLeay::BIO_read($s, $max); # $s - value corresponding to openssls
BIO structure # $max - [optional] max. bytes to read (if not specified,
the value 32768 is used) # # returns: data Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_read.html&gt;</p></li>
<li><p>BIO_write Attempts to write data from <code>$buffer</code> to BIO
<code>$b</code>. my $rv = Net::SSLeay::BIO_write($b, $buffer); # $b -
value corresponding to openssls BIO structure # $buffer - data # #
returns: amount of data successfully written # or that no data was
successfully read or written if the result is 0 or -1 # or -2 when the
operation is not implemented in the specific BIO type Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_read.html&gt;</p></li>
<li><p>BIO_s_mem Return the memory BIO method function. my $rv =
Net::SSLeay::BIO_s_mem(); # # returns: value corresponding to openssls
BIO_METHOD structure (0 on failure) Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_s_mem.html&gt;</p></li>
<li><p>BIO_ssl_copy_session_id Copies an SSL session id between BIO
chains from and to. It does this by locating the SSL BIOs in each chain
and calling <strong>SSL_copy_session_id()</strong> on the internal SSL
pointer. my $rv = Net::SSLeay::BIO_ssl_copy_session_id($to, $from); #
$to - value corresponding to openssls BIO structure # $from - value
corresponding to openssls BIO structure # # returns: 1 on success, 0 on
failure Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
<li><p>BIO_ssl_shutdown Closes down an SSL connection on BIO chain bio.
It does this by locating the SSL BIO in the chain and calling
<strong>SSL_shutdown()</strong> on its internal SSL pointer.
Net::SSLeay::BIO_ssl_shutdown($ssl_bio); # $ssl_bio - value
corresponding to openssls BIO structure # # returns: no return value
Check openssl doc
&lt;http://www.openssl.org/docs/crypto/BIO_f_ssl.html&gt;</p></li>
</ul>
<p><em>Low level API: Server side Server Name Indication (SNI)
support</em></p>
<ul>
<li><p>set_tlsext_host_name TBA</p></li>
<li><p>get_servername TBA</p></li>
<li><p>get_servername_type TBA</p></li>
<li><p>CTX_set_tlsext_servername_callback
<strong>COMPATIBILITY:</strong> requires at least OpenSSL 0.9.8f This
function is used in a server to support Server side Server Name
Indication (SNI). Net::SSLeay::CTX_set_tlsext_servername_callback($ctx,
$code) # $ctx - SSL context # $code - reference to a subroutine that
will be called when a new connection is being initiated # # returns: no
return value On the client side: use set_tlsext_host_name($ssl,
<code>$servername</code>) before initiating the SSL connection. On the
server side: Set up an additional <strong>SSL_CTX()</strong> for each
different certificate; Add a servername callback to each
<strong>SSL_CTX()</strong> using
<strong>CTX_set_tlsext_servername_callback()</strong>; The callback
function is required to retrieve the client-supplied servername with
get_servername(ssl). Figure out the right SSL_CTX to go with that host
name, then switch the SSL object to that SSL_CTX with
<strong>set_SSL_CTX()</strong>. Example: # set callback
Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub { my $ssl =
shift; my $h = Net::SSLeay::get_servername($ssl);
Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists
$hostnames{$h}; } ); More complete example: # ... initialize Net::SSLeay
my %hostnames = ( sni1 =&gt; { cert=&gt;sni1.pem, key=&gt;sni1.key },
sni2 =&gt; { cert=&gt;sni2.pem, key=&gt;sni2.key }, ); # create a new
context for each certificate/key pair for my $name (keys %hostnames) {
$hostnames{$name}-&gt;{ctx} = Net::SSLeay::CTX_new or die;
Net::SSLeay::CTX_set_cipher_list($hostnames{$name}-&gt;{ctx}, ALL);
Net::SSLeay::set_cert_and_key($hostnames{$name}-&gt;{ctx},
$hostnames{$name}-&gt;{cert}, $hostnames{$name}-&gt;{key}) or die; } #
create default context my $ctx = Net::SSLeay::CTX_new or die;
Net::SSLeay::CTX_set_cipher_list($ctx, ALL);
Net::SSLeay::set_cert_and_key($ctx, cert.pem,key.pem) or die; # set
callback Net::SSLeay::CTX_set_tlsext_servername_callback($ctx, sub { my
$ssl = shift; my $h = Net::SSLeay::get_servername($ssl);
Net::SSLeay::set_SSL_CTX($ssl, $hostnames{$h}-&gt;{ctx}) if exists
$hostnames{$h}; } ); # ... later $s = Net::SSLeay::new($ctx);
Net::SSLeay::set_fd($s, fileno($accepted_socket));
Net::SSLeay::accept($s);</p></li>
</ul>
<p><em>Low level API: NPN (next protocol negotiation) related
functions</em></p>
<p>NPN is being replaced with ALPN, a more recent TLS extension for
application protocol negotiation that's in process of being adopted by
IETF. Please look below for APLN API description.</p>
<p>Simple approach for using NPN support looks like this:</p>
<p>### client side use Net::SSLeay; use IO::Socket::INET;
Net::SSLeay::initialize(); my $sock =
IO::Socket::INET-&gt;new(PeerAddr=&gt;encrypted.google.com:443) or die;
my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
Net::SSLeay::CTX_set_next_proto_select_cb($ctx, [http1.1,spdy/2]); my
$ssl = Net::SSLeay::new($ctx) or die; Net::SSLeay::set_fd($ssl,
fileno($sock)) or die; Net::SSLeay::connect($ssl); warn
"client:negotiated=",Net::SSLeay::P_next_proto_negotiated($ssl), "\n";
warn "client:last_status=", Net::SSLeay::P_next_proto_last_status($ssl),
"\n"; ### server side use Net::SSLeay; use IO::Socket::INET;
Net::SSLeay::initialize(); my $ctx = Net::SSLeay::CTX_tlsv1_new() or
die; Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
Net::SSLeay::set_cert_and_key($ctx, "cert.pem", "key.pem");
Net::SSLeay::CTX_set_next_protos_advertised_cb($ctx, [spdy/2,http1.1]);
my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;localhost,
LocalPort=&gt;5443, Proto=&gt;tcp, Listen=&gt;20) or die; while (1) { my
$ssl = Net::SSLeay::new($ctx); warn("server:waiting for incoming
connection...\n"); my $fd = $sock-&gt;accept();
Net::SSLeay::set_fd($ssl, $fd-&gt;fileno); Net::SSLeay::accept($ssl);
warn
"server:negotiated=",Net::SSLeay::P_next_proto_negotiated($ssl),"\n"; my
$got = Net::SSLeay::read($ssl); Net::SSLeay::ssl_write_all($ssl,
"length=".length($got)); Net::SSLeay::free($ssl); $fd-&gt;close(); } #
check with: openssl s_client -connect localhost:5443 -nextprotoneg
http/1.1,spdy/2</p>
<p>Please note that the selection (negotiation) is performed by client
side, the server side simply advertise the list of supported
protocols.</p>
<p>Advanced approach allows you to implement your own negotiation
algorithm.</p>
<p>#see below documentation for:
Net::SSleay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function,
$callback_data); Net::SSleay::CTX_set_next_protos_advertised_cb($ctx,
$perl_callback_function, $callback_data);</p>
<p>Detection of NPN support (works even in older Net::SSLeay
versions):</p>
<p>use Net::SSLeay; if (exists
&amp;Net::SSLeay::P_next_proto_negotiated) { # do NPN stuff }</p>
<ul>
<li><p>CTX_set_next_proto_select_cb <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-1.0.1
<strong>NOTE:</strong> You need CTX_set_next_proto_select_cb on
<strong>client side</strong> of SSL connection. Simple usage - in this
case a common negotiation algorithm (as implemented by openssl's
function SSL_select_next_proto) is used. $rv =
Net::SSleay::CTX_set_next_proto_select_cb($ctx, $arrayref); # $ctx -
value corresponding to openssls SSL_CTX structure # $arrayref - list of
accepted protocols - e.g. [http1.0, http1.1] # # returns: 0 on success,
1 on failure Advanced usage (you probably do not need this): $rv =
Net::SSleay::CTX_set_next_proto_select_cb($ctx, $perl_callback_function,
$callback_data); # $ctx - value corresponding to openssls SSL_CTX
structure # $perl_callback_function - reference to perl function #
$callback_data - [optional] data to passed to callback function when
invoked # # returns: 0 on success, 1 on failure # where callback
function looks like sub npn_advertised_cb_invoke { my ($ssl,
$arrayref_proto_list_advertised_by_server, $callback_data) = @_; my
$status; # ... $status = 1; #status can be: # 0 -
OPENSSL_NPN_UNSUPPORTED # 1 - OPENSSL_NPN_NEGOTIATED # 2 -
OPENSSL_NPN_NO_OVERLAP return $status, [http1.1,spdy/2]; # the callback
has to return 2 values } To undefine/clear this callback use:
Net::SSleay::CTX_set_next_proto_select_cb($ctx, undef);</p></li>
<li><p>CTX_set_next_protos_advertised_cb <strong>COMPATIBILITY:</strong>
not available in Net-SSLeay-1.45 and before; requires at least
openssl-1.0.1 <strong>NOTE:</strong> You need
CTX_set_next_proto_select_cb on <strong>server side</strong> of SSL
connection. Simple usage: $rv =
Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, $arrayref); # $ctx
- value corresponding to openssls SSL_CTX structure # $arrayref - list
of advertised protocols - e.g. [http1.0, http1.1] # # returns: 0 on
success, 1 on failure Advanced usage (you probably do not need this):
$rv = Net::SSleay::CTX_set_next_protos_advertised_cb($ctx,
$perl_callback_function, $callback_data); # $ctx - value corresponding
to openssls SSL_CTX structure # $perl_callback_function - reference to
perl function # $callback_data - [optional] data to passed to callback
function when invoked # # returns: 0 on success, 1 on failure # where
callback function looks like sub npn_advertised_cb_invoke { my ($ssl,
$callback_data) = @_; # ... return [http1.1,spdy/2]; # the callback has
to return arrayref } To undefine/clear this callback use:
Net::SSleay::CTX_set_next_protos_advertised_cb($ctx, undef);</p></li>
<li><p>P_next_proto_negotiated <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-1.0.1
Returns the name of negotiated protocol for given SSL connection
<code>$ssl</code>. $rv = Net::SSLeay::P_next_proto_negotiated($ssl) #
$ssl - value corresponding to openssls SSL structure # # returns:
(string) negotiated protocol name (or undef if no negotiation was done
or failed with fatal error)</p></li>
<li><p>P_next_proto_last_status <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.45 and before; requires at least openssl-1.0.1
Returns the result of the last negotiation for given SSL connection
<code>$ssl</code>. $rv = Net::SSLeay::P_next_proto_last_status($ssl) #
$ssl - value corresponding to openssls SSL structure # # returns:
(integer) negotiation status # 0 - OPENSSL_NPN_UNSUPPORTED # 1 -
OPENSSL_NPN_NEGOTIATED # 2 - OPENSSL_NPN_NO_OVERLAP</p></li>
</ul>
<p><em>Low level API: ALPN (application layer protocol negotiation)
related functions</em></p>
<p>Application protocol can be negotiated via two different mechanisms
employing two different TLS extensions: NPN (obsolete) and ALPN
(recommended).</p>
<p>The API is rather similar, with slight differences reflecting
protocol specifics. In particular, with ALPN the protocol negotiation
takes place on server, while with NPN the client implements the protocol
negotiation logic.</p>
<p>With ALPN, the most basic implementation looks like this:</p>
<p>### client side use Net::SSLeay; use IO::Socket::INET;
Net::SSLeay::initialize(); my $sock =
IO::Socket::INET-&gt;new(PeerAddr=&gt;encrypted.google.com:443) or die;
my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
Net::SSLeay::CTX_set_alpn_protos($ctx, [http/1.1, http/2.0, spdy/3]); my
$ssl = Net::SSLeay::new($ctx) or die; Net::SSLeay::set_fd($ssl,
fileno($sock)) or die; Net::SSLeay::connect($ssl); warn
"client:selected=",Net::SSLeay::P_alpn_selected($ssl), "\n"; ### server
side use Net::SSLeay; use IO::Socket::INET; Net::SSLeay::initialize();
my $ctx = Net::SSLeay::CTX_tlsv1_new() or die;
Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL);
Net::SSLeay::set_cert_and_key($ctx, "cert.pem", "key.pem");
Net::SSLeay::CTX_set_alpn_select_cb($ctx, [http/1.1, http/2.0, spdy/3]);
my $sock = IO::Socket::INET-&gt;new(LocalAddr=&gt;localhost,
LocalPort=&gt;5443, Proto=&gt;tcp, Listen=&gt;20) or die; while (1) { my
$ssl = Net::SSLeay::new($ctx); warn("server:waiting for incoming
connection...\n"); my $fd = $sock-&gt;accept();
Net::SSLeay::set_fd($ssl, $fd-&gt;fileno); Net::SSLeay::accept($ssl);
warn "server:selected=",Net::SSLeay::P_alpn_selected($ssl),"\n"; my $got
= Net::SSLeay::read($ssl); Net::SSLeay::ssl_write_all($ssl,
"length=".length($got)); Net::SSLeay::free($ssl); $fd-&gt;close(); } #
check with: openssl s_client -connect localhost:5443 -alpn
spdy/3,http/1.1</p>
<p>Advanced approach allows you to implement your own negotiation
algorithm.</p>
<p>#see below documentation for:
Net::SSleay::CTX_set_alpn_select_cb($ctx, $perl_callback_function,
$callback_data);</p>
<p>Detection of ALPN support (works even in older Net::SSLeay
versions):</p>
<p>use Net::SSLeay; if (exists &amp;Net::SSLeay::P_alpn_selected) { # do
ALPN stuff }</p>
<ul>
<li><p>CTX_set_alpn_select_cb <strong>COMPATIBILITY:</strong> not
available in Net-SSLeay-1.55 and before; requires at least openssl-1.0.2
<strong>NOTE:</strong> You need CTX_set_alpn_select_cb on <strong>server
side</strong> of TLS connection. Simple usage - in this case a common
negotiation algorithm (as implemented by openssl's function
SSL_select_next_proto) is used. $rv =
Net::SSleay::CTX_set_alpn_select_cb($ctx, $arrayref); # $ctx - value
corresponding to openssls SSL_CTX structure # $arrayref - list of
accepted protocols - e.g. [http/2.0, http/1.1, spdy/3] # # returns: 0 on
success, 1 on failure Advanced usage (you probably do not need this):
$rv = Net::SSleay::CTX_set_alpn_select_cb($ctx, $perl_callback_function,
$callback_data); # $ctx - value corresponding to openssls SSL_CTX
structure # $perl_callback_function - reference to perl function #
$callback_data - [optional] data to passed to callback function when
invoked # # returns: 0 on success, 1 on failure # where callback
function looks like sub alpn_select_cb_invoke { my ($ssl,
$arrayref_proto_list_advertised_by_client, $callback_data) = @_; # ...
if ($negotiated) { return http/2.0; } else { return undef; } } To
undefine/clear this callback use:
Net::SSleay::CTX_set_alpn_select_cb($ctx, undef);</p></li>
<li><p>set_alpn_protos <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.55 and before; requires at least openssl-1.0.2
<strong>NOTE:</strong> You need set_alpn_protos on <strong>client
side</strong> of TLS connection. This adds list of supported application
layer protocols to ClientHello message sent by a client. It advertises
the enumeration of supported protocols:
Net::SSLeay::set_alpn_protos($ssl, [http/1.1, http/2.0, spdy/3]); #
returns 0 on success</p></li>
<li><p>CTX_set_alpn_protos <strong>COMPATIBILITY:</strong> not available
in Net-SSLeay-1.55 and before; requires at least openssl-1.0.2
<strong>NOTE:</strong> You need CTX_set_alpn_protos on <strong>client
side</strong> of TLS connection. This adds list of supported application
layer protocols to ClientHello message sent by a client. It advertises
the enumeration of supported protocols:
Net::SSLeay::CTX_set_alpn_protos($ctx, [http/1.1, http/2.0, spdy/3]); #
returns 0 on success</p></li>
<li><p>P_alpn_selected <strong>COMPATIBILITY:</strong> not available in
Net-SSLeay-1.55 and before; requires at least openssl-1.0.2 Returns the
name of negotiated protocol for given TLS connection <code>$ssl</code>.
$rv = Net::SSLeay::P_alpn_selected($ssl) # $ssl - value corresponding to
openssls SSL structure # # returns: (string) negotiated protocol name
(or undef if no negotiation was done or failed with fatal
error)</p></li>
</ul>
<p><em>Low level API: DANE Support</em></p>
<p>OpenSSL version 1.0.2 adds preliminary support RFC6698 Domain
Authentication of Named Entities (DANE) Transport Layer Association
within OpenSSL</p>
<ul>
<li><p>SSL_get_tlsa_record_byname <strong>COMPATIBILITY:</strong>
DELETED from net-ssleay, since it is not supported by OpenSSL In order
to facilitate DANE there is additional interface,
SSL_get_tlsa_record_byname, accepting hostname, port and socket type
that returns packed TLSA record. In order to make it even easier there
is additional SSL_ctrl function that calls SSL_get_tlsa_record_byname
for you. Latter is recommended for programmers that wish to maintain
broader binary compatibility, e.g. make application work with both 1.0.2
and prior version (in which case call to SSL_ctrl with new code
returning error would have to be ignored when running with prior
version). Net::SSLeay::get_tlsa_record_byname($name, $port,
$type);</p></li>
</ul>
<p><em>Low level API: Other functions</em></p>
<ul>
<li><p>COMP_add_compression_method Adds the compression method cm with
the identifier id to the list of available compression methods. This
list is globally maintained for all SSL operations within this
application. It cannot be set for specific SSL_CTX or SSL objects. my
$rv = Net::SSLeay::COMP_add_compression_method($id, $cm); # $id -
(integer) compression method id # 0 to 63: methods defined by the IETF #
64 to 192: external party methods assigned by IANA # 193 to 255:
reserved for private use # # $cm - value corresponding to openssls
COMP_METHOD structure # # returns: 0 on success, 1 on failure (check the
error queue to find out the reason) Check openssl doc
&lt;http://www.openssl.org/docs/ssl/SSL_COMP_add_compression_method.html&gt;</p></li>
<li><p>DH_free Frees the DH structure and its components. The values are
erased before the memory is returned to the system.
Net::SSLeay::DH_free($dh); # $dh - value corresponding to openssls DH
structure # # returns: no return value Check openssl doc
&lt;http://www.openssl.org/docs/crypto/DH_new.html&gt;</p></li>
<li><p>FIPS_mode_set Enable or disable FIPS mode in a FIPS capable
OpenSSL. Net::SSLeay:: FIPS_mode_set($enable); # $enable - (integer) 1
to enable, 0 to disable</p></li>
</ul>
<p><em>Low level API: EC related functions</em></p>
<ul>
<li><p>CTX_set_tmp_ecdh TBA</p></li>
<li><p>EC_KEY_free TBA</p></li>
<li><p>EC_KEY_new_by_curve_name TBA</p></li>
<li><p>EC_KEY_generate_key Generates a EC key and returns it in a newly
allocated EC_KEY structure. The EC key then can be used to create a PKEY
which can be used in calls like X509_set_pubkey. my $key =
Net::SSLeay::EVP_PKEY_new(); my $ec =
Net::SSLeay::EC_KEY_generate_key($curve);
Net::SSLeay::EVP_PKEY_assign_EC_KEY($key,$ec); # $curve - curve name
like secp521r1 or the matching Id (integer) of the curve # # returns:
value corresponding to openssls EC_KEY structure (0 on failure) This
function has no equivalent in OpenSSL but combines multiple OpenSSL
functions for an easier interface.</p></li>
<li><p>CTX_set_ecdh_auto, set_ecdh_auto These functions enable or
disable the automatic curve selection on the server side by calling
SSL_CTX_set_ecdh_auto or SSL_set_ecdh_auto respectively. If enabled the
highest preference curve is automatically used for ECDH temporary keys
used during key exchange. This function is no longer available for
OpenSSL 1.1.0 or higher. Net::SSLeay::CTX_set_ecdh_auto($ctx,1);
Net::SSLeay::set_ecdh_auto($ssl,1);</p></li>
<li><p>CTX_set1_curves_list, set1_curves_list These functions set the
supported curves (in order of preference) by calling
SSL_CTX_set1_curves_list or SSL_set1_curves_list respectively. For a TLS
client these curves are offered to the server in the supported curves
extension while on the server side these are used to determine the
shared curve. These functions are only available since OpenSSL 1.1.0.
Net::SSLeay::CTX_set1_curves_list($ctx,"P-521:P-384:P-256");
Net::SSLeay::set1_curves_list($ssl,"P-521:P-384:P-256");</p></li>
<li><p>CTX_set1_groups_list, set1_groups_list These functions set the
supported groups (in order of preference) by calling
SSL_CTX_set1_groups_list or SSL_set1_groups_list respectively. This is
practically the same as CTX_set1_curves_list and set1_curves_list except
that all DH groups can be given as supported by TLS 1.3. These functions
are only available since OpenSSL 1.1.1.
Net::SSLeay::CTX_set1_groups_list($ctx,"P-521:P-384:P-256");
Net::SSLeay::set1_groups_list($ssl,"P-521:P-384:P-256");</p></li>
</ul>
<p><em>Low level API: OSSL_LIB_CTX and OSSL_PROVIDER related
functions</em></p>
<ul>
<li><p>OSSL_LIB_CTX_get0_global_default Returns a concrete (non NULL)
reference to the global default library context. my $libctx =
Net::SSLeay::OSSL_LIB_CTX_get0_global_default(); # returns: a value
corresponding to OSSL_LIB_CTX structure or false on failure Typically
it's simpler to use undef with functions that take an OSSL_LIB_CTX
argument when global default library context is needed. Check openssl
doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_LIB_CTX_get0_global_default.html&gt;</p></li>
<li><p>OSSL_PROVIDER_load Loads and initializes a provider my $provider
= Net::SSLeay::OSSL_PROVIDER_load($libctx, $name); # $libctx - value
corresponding to OSSL_LIB_CTX structure or undef # $name - (string)
provider name, e.g., legacy # # returns: a value corresponding to
OSSL_PROVIDER or false on failure Using undef loads the provider within
the global default library context. my $provider =
Net::SSLeay::OSSL_PROVIDER_load(undef, legacy); Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_load.html&gt;</p></li>
<li><p>OSSL_PROVIDER_try_load Loads and initializes a provider similar
to OSSL_PROVIDER_load with additional fallback control. my $provider =
Net::SSLeay::OSSL_PROVIDER_try_load($libctx, $name, $retain_fallbacks);
# $libctx - value corresponding to OSSL_LIB_CTX structure or undef #
$name - (string) provider name, e.g., legacy # $retain_fallbacks -
(integer) 0 or 1 # # returns: a value corresponding to OSSL_PROVIDER or
false on failure Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_try_load.html&gt;</p></li>
<li><p>OSSL_PROVIDER_unload Unloads the given provider. my $rv =
Net::SSLeay::OSSL_PROVIDER_unload($provider); # $provider - a value
corresponding to OSSL_PROVIDER # # returns: (integer) 1 on success, 0 on
error Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_unload.html&gt;</p></li>
<li><p>OSSL_PROVIDER_available Checks if a named provider is available
for use. my $rv = Net::SSLeay::OSSL_PROVIDER_available($libctx, $name);
# $libctx - value corresponding to OSSL_LIB_CTX structure or undef #
$name - (string) provider name, e.g., legacy # # returns: (integer) 1 if
the named provider is available, otherwise 0. Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_available.html&gt;</p></li>
<li><p>OSSL_PROVIDER_do_all Iterates over all loaded providers. A
callback is called for each provider. my $rv =
Net::SSLeay::OSSL_PROVIDER_do_all($libctx, $cb, $cbdata); # $libctx -
value corresponding to OSSL_LIB_CTX structure or undef # $cb - reference
to a perl callback function $ $cbdata - data that will be passed to
callback function # # returns: (integer) 1 if all callbacks returned 1,
0 the first time a callback returns 0. Example: sub do_all_cb { my
($provider, $cbdata) = @_; my $name =
Net::SSLeay::OSSL_PROVIDER_get0_name($provider); print "Callback for
provider: $name, cbdata: $cbdata\n"; return 1; } my $data_for_cb =
Hello; # Triggers default provider automatic loading.
Net::SSLeay::OSSL_PROVIDER_available(undef, default) || die default
provider not available; Net::SSLeay::OSSL_PROVIDER_load(undef, legacy)
|| die load legacy; Net::SSLeay::OSSL_PROVIDER_load(undef, null) || die
load null; Net::SSLeay::OSSL_PROVIDER_do_all(undef, \&amp;do_all_cb,
$data_for_cb) || die a callback failed; Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_do_all.html&gt;</p></li>
<li><p>OSSL_PROVIDER_get0_name Returns the name of the given provider.
my $name = Net::SSLeay::OSSL_PROVIDER_get0_name($provider); # $provider
- a value corresponding to OSSL_PROVIDER # # returns: (string) provider
name, e.g., legacy Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_get0_name.html&gt;</p></li>
<li><p>OSSL_PROVIDER_self_test Runs the provider's self tests. my $rv =
Net::SSLeay::OSSL_PROVIDER_self_test($provider); # $libctx - value
corresponding to OSSL_LIB_CTX structure or undef # $provider - a value
corresponding to OSSL_PROVIDER # # returns: (integer) returns 1 if the
self tests pass, 0 on error Check openssl doc
&lt;https://www.openssl.org/docs/manmaster/man3/OSSL_PROVIDER_self_test.html&gt;</p></li>
</ul>
<h2>Constants</h2>
<p>There are many openssl constants available in Net::SSLeay. You can
use them like this:</p>
<p>use Net::SSLeay; print &amp;Net::SSLeay::NID_commonName; #or print
Net::SSLeay::NID_commonName();</p>
<p>Or you can import them and use:</p>
<p>use Net::SSLeay qw/NID_commonName/; print &amp;NID_commonName; #or
print NID_commonName(); #or print NID_commonName;</p>
<p>The constants names are derived from openssl constants, however
constants starting with <code>SSL_</code> prefix have name with
<code>SSL_</code> part stripped - e.g. openssl's constant
<code>SSL_OP_ALL</code> is available as
<code>Net::SSleay::OP_ALL</code></p>
<p>The list of all available constant names:</p>
<p>ASN1_STRFLGS_ESC_CTRL OPENSSL_VERSION_STRING ASN1_STRFLGS_ESC_MSB
OP_ALL ASN1_STRFLGS_ESC_QUOTE OP_ALLOW_NO_DHE_KEX ASN1_STRFLGS_RFC2253
OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION CB_ACCEPT_EXIT
OP_CIPHER_SERVER_PREFERENCE CB_ACCEPT_LOOP OP_CISCO_ANYCONNECT CB_ALERT
OP_COOKIE_EXCHANGE CB_CONNECT_EXIT OP_CRYPTOPRO_TLSEXT_BUG
CB_CONNECT_LOOP OP_DONT_INSERT_EMPTY_FRAGMENTS CB_EXIT
OP_ENABLE_MIDDLEBOX_COMPAT CB_HANDSHAKE_DONE OP_EPHEMERAL_RSA
CB_HANDSHAKE_START OP_LEGACY_SERVER_CONNECT CB_LOOP
OP_MICROSOFT_BIG_SSLV3_BUFFER CB_READ OP_MICROSOFT_SESS_ID_BUG
CB_READ_ALERT OP_MSIE_SSLV2_RSA_PADDING CB_WRITE OP_NETSCAPE_CA_DN_BUG
CB_WRITE_ALERT OP_NETSCAPE_CHALLENGE_BUG ERROR_NONE
OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG ERROR_SSL
OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG ERROR_SYSCALL OP_NON_EXPORT_FIRST
ERROR_WANT_ACCEPT OP_NO_ANTI_REPLAY ERROR_WANT_CONNECT
OP_NO_CLIENT_RENEGOTIATION ERROR_WANT_READ OP_NO_COMPRESSION
ERROR_WANT_WRITE OP_NO_ENCRYPT_THEN_MAC ERROR_WANT_X509_LOOKUP
OP_NO_QUERY_MTU ERROR_ZERO_RETURN OP_NO_RENEGOTIATION EVP_PKS_DSA
OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION EVP_PKS_EC OP_NO_SSL_MASK
EVP_PKS_RSA OP_NO_SSLv2 EVP_PKT_ENC OP_NO_SSLv3 EVP_PKT_EXCH
OP_NO_TICKET EVP_PKT_EXP OP_NO_TLSv1 EVP_PKT_SIGN OP_NO_TLSv1_1
EVP_PK_DH OP_NO_TLSv1_2 EVP_PK_DSA OP_NO_TLSv1_3 EVP_PK_EC
OP_PKCS1_CHECK_1 EVP_PK_RSA OP_PKCS1_CHECK_2 FILETYPE_ASN1
OP_PRIORITIZE_CHACHA FILETYPE_PEM OP_SAFARI_ECDHE_ECDSA_BUG
F_CLIENT_CERTIFICATE OP_SINGLE_DH_USE F_CLIENT_HELLO OP_SINGLE_ECDH_USE
F_CLIENT_MASTER_KEY OP_SSLEAY_080_CLIENT_DH_BUG F_D2I_SSL_SESSION
OP_SSLREF2_REUSE_CERT_TYPE_BUG F_GET_CLIENT_FINISHED OP_TLSEXT_PADDING
F_GET_CLIENT_HELLO OP_TLS_BLOCK_PADDING_BUG F_GET_CLIENT_MASTER_KEY
OP_TLS_D5_BUG F_GET_SERVER_FINISHED OP_TLS_ROLLBACK_BUG
F_GET_SERVER_HELLO READING F_GET_SERVER_VERIFY RECEIVED_SHUTDOWN
F_I2D_SSL_SESSION RSA_3 F_READ_N RSA_F4 F_REQUEST_CERTIFICATE
R_BAD_AUTHENTICATION_TYPE F_SERVER_HELLO R_BAD_CHECKSUM F_SSL_CERT_NEW
R_BAD_MAC_DECODE F_SSL_GET_NEW_SESSION R_BAD_RESPONSE_ARGUMENT F_SSL_NEW
R_BAD_SSL_FILETYPE F_SSL_READ R_BAD_SSL_SESSION_ID_LENGTH
F_SSL_RSA_PRIVATE_DECRYPT R_BAD_STATE F_SSL_RSA_PUBLIC_ENCRYPT
R_BAD_WRITE_RETRY F_SSL_SESSION_NEW R_CHALLENGE_IS_DIFFERENT
F_SSL_SESSION_PRINT_FP R_CIPHER_TABLE_SRC_ERROR F_SSL_SET_FD
R_INVALID_CHALLENGE_LENGTH F_SSL_SET_RFD R_NO_CERTIFICATE_SET
F_SSL_SET_WFD R_NO_CERTIFICATE_SPECIFIED F_SSL_USE_CERTIFICATE
R_NO_CIPHER_LIST F_SSL_USE_CERTIFICATE_ASN1 R_NO_CIPHER_MATCH
F_SSL_USE_CERTIFICATE_FILE R_NO_PRIVATEKEY F_SSL_USE_PRIVATEKEY
R_NO_PUBLICKEY F_SSL_USE_PRIVATEKEY_ASN1 R_NULL_SSL_CTX
F_SSL_USE_PRIVATEKEY_FILE R_PEER_DID_NOT_RETURN_A_CERTIFICATE
F_SSL_USE_RSAPRIVATEKEY R_PEER_ERROR F_SSL_USE_RSAPRIVATEKEY_ASN1
R_PEER_ERROR_CERTIFICATE F_SSL_USE_RSAPRIVATEKEY_FILE
R_PEER_ERROR_NO_CIPHER F_WRITE_PENDING
R_PEER_ERROR_UNSUPPORTED_CERTIFICATE_TYPE GEN_DIRNAME
R_PUBLIC_KEY_ENCRYPT_ERROR GEN_DNS R_PUBLIC_KEY_IS_NOT_RSA GEN_EDIPARTY
R_READ_WRONG_PACKET_TYPE GEN_EMAIL R_SHORT_READ GEN_IPADD
R_SSL_SESSION_ID_IS_DIFFERENT GEN_OTHERNAME
R_UNABLE_TO_EXTRACT_PUBLIC_KEY GEN_RID R_UNKNOWN_REMOTE_ERROR_TYPE
GEN_URI R_UNKNOWN_STATE GEN_X400 R_X509_LIB LIBRESSL_VERSION_NUMBER
SENT_SHUTDOWN MBSTRING_ASC SESSION_ASN1_VERSION MBSTRING_BMP
SESS_CACHE_BOTH MBSTRING_FLAG SESS_CACHE_CLIENT MBSTRING_UNIV
SESS_CACHE_NO_AUTO_CLEAR MBSTRING_UTF8 SESS_CACHE_NO_INTERNAL
MIN_RSA_MODULUS_LENGTH_IN_BYTES SESS_CACHE_NO_INTERNAL_LOOKUP
MODE_ACCEPT_MOVING_WRITE_BUFFER SESS_CACHE_NO_INTERNAL_STORE
MODE_AUTO_RETRY SESS_CACHE_OFF MODE_ENABLE_PARTIAL_WRITE
SESS_CACHE_SERVER MODE_RELEASE_BUFFERS SSL2_MT_CLIENT_CERTIFICATE
NID_OCSP_sign SSL2_MT_CLIENT_FINISHED NID_SMIMECapabilities
SSL2_MT_CLIENT_HELLO NID_X500 SSL2_MT_CLIENT_MASTER_KEY NID_X509
SSL2_MT_ERROR NID_ad_OCSP SSL2_MT_REQUEST_CERTIFICATE NID_ad_ca_issuers
SSL2_MT_SERVER_FINISHED NID_algorithm SSL2_MT_SERVER_HELLO
NID_authority_key_identifier SSL2_MT_SERVER_VERIFY NID_basic_constraints
SSL2_VERSION NID_bf_cbc SSL3_MT_CCS NID_bf_cfb64 SSL3_MT_CERTIFICATE
NID_bf_ecb SSL3_MT_CERTIFICATE_REQUEST NID_bf_ofb64
SSL3_MT_CERTIFICATE_STATUS NID_cast5_cbc SSL3_MT_CERTIFICATE_URL
NID_cast5_cfb64 SSL3_MT_CERTIFICATE_VERIFY NID_cast5_ecb
SSL3_MT_CHANGE_CIPHER_SPEC NID_cast5_ofb64 SSL3_MT_CLIENT_HELLO
NID_certBag SSL3_MT_CLIENT_KEY_EXCHANGE NID_certificate_policies
SSL3_MT_ENCRYPTED_EXTENSIONS NID_client_auth SSL3_MT_END_OF_EARLY_DATA
NID_code_sign SSL3_MT_FINISHED NID_commonName SSL3_MT_HELLO_REQUEST
NID_countryName SSL3_MT_KEY_UPDATE NID_crlBag SSL3_MT_MESSAGE_HASH
NID_crl_distribution_points SSL3_MT_NEWSESSION_TICKET NID_crl_number
SSL3_MT_NEXT_PROTO NID_crl_reason SSL3_MT_SERVER_DONE NID_delta_crl
SSL3_MT_SERVER_HELLO NID_des_cbc SSL3_MT_SERVER_KEY_EXCHANGE
NID_des_cfb64 SSL3_MT_SUPPLEMENTAL_DATA NID_des_ecb SSL3_RT_ALERT
NID_des_ede SSL3_RT_APPLICATION_DATA NID_des_ede3
SSL3_RT_CHANGE_CIPHER_SPEC NID_des_ede3_cbc SSL3_RT_HANDSHAKE
NID_des_ede3_cfb64 SSL3_RT_HEADER NID_des_ede3_ofb64
SSL3_RT_INNER_CONTENT_TYPE NID_des_ede_cbc SSL3_VERSION
NID_des_ede_cfb64 SSLEAY_BUILT_ON NID_des_ede_ofb64 SSLEAY_CFLAGS
NID_des_ofb64 SSLEAY_DIR NID_description SSLEAY_PLATFORM NID_desx_cbc
SSLEAY_VERSION NID_dhKeyAgreement ST_ACCEPT NID_dnQualifier ST_BEFORE
NID_dsa ST_CONNECT NID_dsaWithSHA ST_INIT NID_dsaWithSHA1 ST_OK
NID_dsaWithSHA1_2 ST_READ_BODY NID_dsa_2 ST_READ_HEADER
NID_email_protect TLS1_1_VERSION NID_ext_key_usage TLS1_2_VERSION
NID_ext_req TLS1_3_VERSION NID_friendlyName TLS1_VERSION NID_givenName
TLSEXT_STATUSTYPE_ocsp NID_hmacWithSHA1 VERIFY_CLIENT_ONCE NID_id_ad
VERIFY_FAIL_IF_NO_PEER_CERT NID_id_ce VERIFY_NONE NID_id_kp VERIFY_PEER
NID_id_pbkdf2 VERIFY_POST_HANDSHAKE NID_id_pe V_OCSP_CERTSTATUS_GOOD
NID_id_pkix V_OCSP_CERTSTATUS_REVOKED NID_id_qt_cps
V_OCSP_CERTSTATUS_UNKNOWN NID_id_qt_unotice WRITING NID_idea_cbc
X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT NID_idea_cfb64
X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS NID_idea_ecb
X509_CHECK_FLAG_NEVER_CHECK_SUBJECT NID_idea_ofb64
X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS NID_info_access
X509_CHECK_FLAG_NO_WILDCARDS NID_initials
X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS NID_invalidity_date
X509_FILETYPE_ASN1 NID_issuer_alt_name X509_FILETYPE_DEFAULT NID_keyBag
X509_FILETYPE_PEM NID_key_usage X509_LOOKUP NID_localKeyID
X509_PURPOSE_ANY NID_localityName X509_PURPOSE_CRL_SIGN NID_md2
X509_PURPOSE_NS_SSL_SERVER NID_md2WithRSAEncryption
X509_PURPOSE_OCSP_HELPER NID_md5 X509_PURPOSE_SMIME_ENCRYPT
NID_md5WithRSA X509_PURPOSE_SMIME_SIGN NID_md5WithRSAEncryption
X509_PURPOSE_SSL_CLIENT NID_md5_sha1 X509_PURPOSE_SSL_SERVER NID_mdc2
X509_PURPOSE_TIMESTAMP_SIGN NID_mdc2WithRSA X509_TRUST_COMPAT
NID_ms_code_com X509_TRUST_EMAIL NID_ms_code_ind X509_TRUST_OBJECT_SIGN
NID_ms_ctl_sign X509_TRUST_OCSP_REQUEST NID_ms_efs X509_TRUST_OCSP_SIGN
NID_ms_ext_req X509_TRUST_SSL_CLIENT NID_ms_sgc X509_TRUST_SSL_SERVER
NID_name X509_TRUST_TSA NID_netscape
X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH NID_netscape_base_url
X509_V_ERR_AKID_SKID_MISMATCH NID_netscape_ca_policy_url
X509_V_ERR_APPLICATION_VERIFICATION NID_netscape_ca_revocation_url
X509_V_ERR_CA_KEY_TOO_SMALL NID_netscape_cert_extension
X509_V_ERR_CA_MD_TOO_WEAK NID_netscape_cert_sequence
X509_V_ERR_CERT_CHAIN_TOO_LONG NID_netscape_cert_type
X509_V_ERR_CERT_HAS_EXPIRED NID_netscape_comment
X509_V_ERR_CERT_NOT_YET_VALID NID_netscape_data_type
X509_V_ERR_CERT_REJECTED NID_netscape_renewal_url
X509_V_ERR_CERT_REVOKED NID_netscape_revocation_url
X509_V_ERR_CERT_SIGNATURE_FAILURE NID_netscape_ssl_server_name
X509_V_ERR_CERT_UNTRUSTED NID_ns_sgc X509_V_ERR_CRL_HAS_EXPIRED
NID_organizationName X509_V_ERR_CRL_NOT_YET_VALID
NID_organizationalUnitName X509_V_ERR_CRL_PATH_VALIDATION_ERROR
NID_pbeWithMD2AndDES_CBC X509_V_ERR_CRL_SIGNATURE_FAILURE
NID_pbeWithMD2AndRC2_CBC X509_V_ERR_DANE_NO_MATCH
NID_pbeWithMD5AndCast5_CBC X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT
NID_pbeWithMD5AndDES_CBC X509_V_ERR_DIFFERENT_CRL_SCOPE
NID_pbeWithMD5AndRC2_CBC X509_V_ERR_EE_KEY_TOO_SMALL
NID_pbeWithSHA1AndDES_CBC X509_V_ERR_EMAIL_MISMATCH
NID_pbeWithSHA1AndRC2_CBC X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD
NID_pbe_WithSHA1And128BitRC2_CBC
X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD NID_pbe_WithSHA1And128BitRC4
X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD
NID_pbe_WithSHA1And2_Key_TripleDES_CBC
X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD
NID_pbe_WithSHA1And3_Key_TripleDES_CBC X509_V_ERR_EXCLUDED_VIOLATION
NID_pbe_WithSHA1And40BitRC2_CBC X509_V_ERR_HOSTNAME_MISMATCH
NID_pbe_WithSHA1And40BitRC4 X509_V_ERR_INVALID_CA NID_pbes2
X509_V_ERR_INVALID_CALL NID_pbmac1 X509_V_ERR_INVALID_EXTENSION NID_pkcs
X509_V_ERR_INVALID_NON_CA NID_pkcs3 X509_V_ERR_INVALID_POLICY_EXTENSION
NID_pkcs7 X509_V_ERR_INVALID_PURPOSE NID_pkcs7_data
X509_V_ERR_IP_ADDRESS_MISMATCH NID_pkcs7_digest
X509_V_ERR_KEYUSAGE_NO_CERTSIGN NID_pkcs7_encrypted
X509_V_ERR_KEYUSAGE_NO_CRL_SIGN NID_pkcs7_enveloped
X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE NID_pkcs7_signed
X509_V_ERR_NO_EXPLICIT_POLICY NID_pkcs7_signedAndEnveloped
X509_V_ERR_NO_VALID_SCTS NID_pkcs8ShroudedKeyBag
X509_V_ERR_OCSP_CERT_UNKNOWN NID_pkcs9 X509_V_ERR_OCSP_VERIFY_FAILED
NID_pkcs9_challengePassword X509_V_ERR_OCSP_VERIFY_NEEDED
NID_pkcs9_contentType X509_V_ERR_OUT_OF_MEM NID_pkcs9_countersignature
X509_V_ERR_PATH_LENGTH_EXCEEDED NID_pkcs9_emailAddress
X509_V_ERR_PATH_LOOP NID_pkcs9_extCertAttributes
X509_V_ERR_PERMITTED_VIOLATION NID_pkcs9_messageDigest
X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED NID_pkcs9_signingTime
X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED NID_pkcs9_unstructuredAddress
X509_V_ERR_PROXY_SUBJECT_NAME_VIOLATION NID_pkcs9_unstructuredName
X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN NID_private_key_usage_period
X509_V_ERR_STORE_LOOKUP NID_rc2_40_cbc
X509_V_ERR_SUBJECT_ISSUER_MISMATCH NID_rc2_64_cbc
X509_V_ERR_SUBTREE_MINMAX NID_rc2_cbc
X509_V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 NID_rc2_cfb64
X509_V_ERR_SUITE_B_INVALID_ALGORITHM NID_rc2_ecb
X509_V_ERR_SUITE_B_INVALID_CURVE NID_rc2_ofb64
X509_V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM NID_rc4
X509_V_ERR_SUITE_B_INVALID_VERSION NID_rc4_40
X509_V_ERR_SUITE_B_LOS_NOT_ALLOWED NID_rc5_cbc
X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY NID_rc5_cfb64
X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE NID_rc5_ecb
X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE NID_rc5_ofb64
X509_V_ERR_UNABLE_TO_GET_CRL NID_ripemd160
X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER NID_ripemd160WithRSA
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT NID_rle_compression
X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY NID_rsa
X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE NID_rsaEncryption
X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION NID_rsadsi
X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION NID_safeContentsBag
X509_V_ERR_UNNESTED_RESOURCE NID_sdsiCertificate X509_V_ERR_UNSPECIFIED
NID_secretBag X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX NID_serialNumber
X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE NID_server_auth
X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE NID_sha
X509_V_ERR_UNSUPPORTED_NAME_SYNTAX NID_sha1
X509_V_FLAG_ALLOW_PROXY_CERTS NID_sha1WithRSA
X509_V_FLAG_CB_ISSUER_CHECK NID_sha1WithRSAEncryption
X509_V_FLAG_CHECK_SS_SIGNATURE NID_shaWithRSAEncryption
X509_V_FLAG_CRL_CHECK NID_stateOrProvinceName X509_V_FLAG_CRL_CHECK_ALL
NID_subject_alt_name X509_V_FLAG_EXPLICIT_POLICY
NID_subject_key_identifier X509_V_FLAG_EXTENDED_CRL_SUPPORT NID_surname
X509_V_FLAG_IGNORE_CRITICAL NID_sxnet X509_V_FLAG_INHIBIT_ANY
NID_time_stamp X509_V_FLAG_INHIBIT_MAP NID_title
X509_V_FLAG_LEGACY_VERIFY NID_undef X509_V_FLAG_NOTIFY_POLICY
NID_uniqueIdentifier X509_V_FLAG_NO_ALT_CHAINS NID_x509Certificate
X509_V_FLAG_NO_CHECK_TIME NID_x509Crl X509_V_FLAG_PARTIAL_CHAIN
NID_zlib_compression X509_V_FLAG_POLICY_CHECK NOTHING
X509_V_FLAG_POLICY_MASK OCSP_RESPONSE_STATUS_INTERNALERROR
X509_V_FLAG_SUITEB_128_LOS OCSP_RESPONSE_STATUS_MALFORMEDREQUEST
X509_V_FLAG_SUITEB_128_LOS_ONLY OCSP_RESPONSE_STATUS_SIGREQUIRED
X509_V_FLAG_SUITEB_192_LOS OCSP_RESPONSE_STATUS_SUCCESSFUL
X509_V_FLAG_TRUSTED_FIRST OCSP_RESPONSE_STATUS_TRYLATER
X509_V_FLAG_USE_CHECK_TIME OCSP_RESPONSE_STATUS_UNAUTHORIZED
X509_V_FLAG_USE_DELTAS OPENSSL_BUILT_ON X509_V_FLAG_X509_STRICT
OPENSSL_CFLAGS X509_V_OK OPENSSL_CPU_INFO XN_FLAG_COMPAT OPENSSL_DIR
XN_FLAG_DN_REV OPENSSL_ENGINES_DIR XN_FLAG_DUMP_UNKNOWN_FIELDS
OPENSSL_FULL_VERSION_STRING XN_FLAG_FN_ALIGN OPENSSL_INFO_CONFIG_DIR
XN_FLAG_FN_LN OPENSSL_INFO_CPU_SETTINGS XN_FLAG_FN_MASK
OPENSSL_INFO_DIR_FILENAME_SEPARATOR XN_FLAG_FN_NONE
OPENSSL_INFO_DSO_EXTENSION XN_FLAG_FN_OID OPENSSL_INFO_ENGINES_DIR
XN_FLAG_FN_SN OPENSSL_INFO_LIST_SEPARATOR XN_FLAG_MULTILINE
OPENSSL_INFO_MODULES_DIR XN_FLAG_ONELINE OPENSSL_INFO_SEED_SOURCE
XN_FLAG_RFC2253 OPENSSL_MODULES_DIR XN_FLAG_SEP_COMMA_PLUS
OPENSSL_PLATFORM XN_FLAG_SEP_CPLUS_SPC OPENSSL_VERSION XN_FLAG_SEP_MASK
OPENSSL_VERSION_MAJOR XN_FLAG_SEP_MULTILINE OPENSSL_VERSION_MINOR
XN_FLAG_SEP_SPLUS_SPC OPENSSL_VERSION_NUMBER XN_FLAG_SPC_EQ
OPENSSL_VERSION_PATCH</p>
<h2>INTERNAL ONLY functions (do not use these)</h2>
<p>The following functions are not intended for use from outside of
Net::SSLeay module. They might be removed, renamed or changed without
prior notice in future version.</p>
<p>Simply <strong>DO NOT USE THEM</strong>!</p>
<ul>
<li><p>hello</p></li>
<li><p>blength</p></li>
<li><p>constant</p></li>
</ul>
<h1>EXAMPLES</h1>
<p>One very good example to look at is the implementation of
<code>sslcat()</code> in the <code>SSLeay.pm</code> file.</p>
<p>The following is a simple SSLeay client (with too little error
checking :-(</p>
<p>#!/usr/bin/perl use Socket; use Net::SSLeay qw(die_now
die_if_ssl_error) ; Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();
($dest_serv, $port, $msg) = @ARGV; # Read command line $port =
getservbyname ($port, tcp) unless $port =~ /^\d+$/; $dest_ip =
gethostbyname ($dest_serv); $dest_serv_params = sockaddr_in($port,
$dest_ip); socket (S, &amp;AF_INET, &amp;SOCK_STREAM, 0) or die "socket:
$!"; connect (S, $dest_serv_params) or die "connect: $!"; select (S); $|
= 1; select (STDOUT); # Eliminate STDIO buffering # The network
connection is now open, lets fire up SSL $ctx = Net::SSLeay::CTX_new()
or die_now("Failed to create SSL_CTX $!");
Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL) or
die_if_ssl_error("ssl ctx set options"); $ssl = Net::SSLeay::new($ctx)
or die_now("Failed to create SSL $!"); Net::SSLeay::set_fd($ssl,
fileno(S)); # Must use fileno $res = Net::SSLeay::connect($ssl) and
die_if_ssl_error("ssl connect"); print "Cipher `" .
Net::SSLeay::get_cipher($ssl) . "\n"; # Exchange data $res =
Net::SSLeay::write($ssl, $msg); # Perl knows how long $msg is
die_if_ssl_error("ssl write"); CORE::shutdown S, 1; # Half close --&gt;
No more output, sends EOF to server $got = Net::SSLeay::read($ssl); #
Perl returns undef on failure die_if_ssl_error("ssl read"); print $got;
Net::SSLeay::free ($ssl); # Tear down connection Net::SSLeay::CTX_free
($ctx); close S;</p>
<p>The following is a simple SSLeay echo server (non forking):</p>
<p>#!/usr/bin/perl -w use Socket; use Net::SSLeay qw(die_now
die_if_ssl_error); Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();
$our_ip = "\0\0\0\0"; # Bind to all interfaces $port = 1235;
$sockaddr_template = S n a4 x8; $our_serv_params = pack
($sockaddr_template, &amp;AF_INET, $port, $our_ip); socket (S,
&amp;AF_INET, &amp;SOCK_STREAM, 0) or die "socket: $!"; bind (S,
$our_serv_params) or die "bind: $!"; listen (S, 5) or die "listen: $!";
$ctx = Net::SSLeay::CTX_new () or die_now("CTX_new ($ctx): $!");
Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL) or
die_if_ssl_error("ssl ctx set options"); # Following will ask password
unless private key is not encrypted
Net::SSLeay::CTX_use_RSAPrivateKey_file ($ctx, plain-rsa.pem,
&amp;Net::SSLeay::FILETYPE_PEM); die_if_ssl_error("private key");
Net::SSLeay::CTX_use_certificate_file ($ctx, plain-cert.pem,
&amp;Net::SSLeay::FILETYPE_PEM); die_if_ssl_error("certificate"); while
(1) { print "Accepting connections...\n"; ($addr = accept (NS, S)) or
die "accept: $!"; select (NS); $| = 1; select (STDOUT); # Piping hot!
($af,$client_port,$client_ip) = unpack($sockaddr_template,$addr);
@inetaddr = unpack(C4,$client_ip); print "$af connection from " . join
(., @inetaddr) . ":$client_port\n"; # We now have a network connection,
lets fire up SSLeay... $ssl = Net::SSLeay::new($ctx) or die_now("SSL_new
($ssl): $!"); Net::SSLeay::set_fd($ssl, fileno(NS)); $err =
Net::SSLeay::accept($ssl) and die_if_ssl_error(ssl accept); print
"Cipher `" . Net::SSLeay::get_cipher($ssl) . "\n"; # Connected. Exchange
some data. $got = Net::SSLeay::read($ssl); # Returns undef on fail
die_if_ssl_error("ssl read"); print "Got `$got (" . length ($got) . "
chars)\n"; Net::SSLeay::write ($ssl, uc ($got)) or die "write: $!";
die_if_ssl_error("ssl write"); Net::SSLeay::free ($ssl); # Tear down
connection close NS; }</p>
<p>Yet another echo server. This one runs from
<code>/etc/inetd.conf</code> so it avoids all the socket code overhead.
Only caveat is opening an rsa key file - it had better be without any
encryption or else it will not know where to ask for the password. Note
how <code>STDIN</code> and <code>STDOUT</code> are wired to SSL.</p>
<p>#!/usr/bin/perl # /etc/inetd.conf # ssltst stream tcp nowait root
/path/to/server.pl server.pl # /etc/services # ssltst 1234/tcp use
Net::SSLeay qw(die_now die_if_ssl_error);
Net::SSLeay::load_error_strings();
Net::SSLeay::SSLeay_add_ssl_algorithms(); Net::SSLeay::randomize();
chdir /key/dir or die "chdir: $!"; $| = 1; # Piping hot! open LOG,
"&gt;&gt;/dev/console" or die "Cant open log file $!"; select LOG; print
"server.pl started\n"; $ctx = Net::SSLeay::CTX_new() or die_now "CTX_new
($ctx) ($!)"; $ssl = Net::SSLeay::new($ctx) or die_now "new ($ssl)
($!)"; Net::SSLeay::set_options($ssl, &amp;Net::SSLeay::OP_ALL) and
die_if_ssl_error("ssl set options"); # We get already open network
connection from inetd, now we just # need to attach SSLeay to STDIN and
STDOUT Net::SSLeay::set_rfd($ssl, fileno(STDIN));
Net::SSLeay::set_wfd($ssl, fileno(STDOUT));
Net::SSLeay::use_RSAPrivateKey_file ($ssl, plain-rsa.pem,
Net::SSLeay::FILETYPE_PEM); die_if_ssl_error("private key");
Net::SSLeay::use_certificate_file ($ssl, plain-cert.pem,
Net::SSLeay::FILETYPE_PEM); die_if_ssl_error("certificate");
Net::SSLeay::accept($ssl) and die_if_ssl_err("ssl accept: $!"); print
"Cipher `" . Net::SSLeay::get_cipher($ssl) . "\n"; $got =
Net::SSLeay::read($ssl); die_if_ssl_error("ssl read"); print "Got `$got
(" . length ($got) . " chars)\n"; Net::SSLeay::write ($ssl, uc($got)) or
die "write: $!"; die_if_ssl_error("ssl write"); Net::SSLeay::free
($ssl); # Tear down the connection Net::SSLeay::CTX_free ($ctx); close
LOG;</p>
<p>There are also a number of example/test programs in the examples
directory:</p>
<p>sslecho.pl - A simple server, not unlike the one above minicli.pl -
Implements a client using low level SSLeay routines sslcat.pl -
Demonstrates using high level sslcat utility function get_page.pl - Is a
utility for getting html pages from secure servers callback.pl -
Demonstrates certificate verification and callback usage stdio_bulk.pl -
Does SSL over Unix pipes ssl-inetd-serv.pl - SSL server that can be
invoked from inetd.conf httpd-proxy-snif.pl - Utility that allows you to
see how a browser sends https request to given server and what reply it
gets back (very educative :-) makecert.pl - Creates a self signed cert
(does not use this module)</p>
<h1>INSTALLATION</h1>
<p>See README and README.* in the distribution directory for
installation guidance on a variety of platforms.</p>
<h1>LIMITATIONS</h1>
<p><code>Net::SSLeay::read()</code> uses an internal buffer of 32KB,
thus no single read will return more. In practice one read returns much
less, usually as much as fits in one network packet. To work around
this, you should use a loop like this:</p>
<p>$reply = ; while ($got = Net::SSLeay::read($ssl)) { last if
print_errs(SSL_read); $reply .= $got; }</p>
<p>Although there is no built-in limit in
<code>Net::SSLeay::write()</code>, the network packet size limitation
applies here as well, thus use:</p>
<p>$written = 0; while ($written &lt; length($message)) { $written +=
Net::SSLeay::write($ssl, substr($message, $written)); last if
print_errs(SSL_write); }</p>
<p>Or alternatively you can just use the following convenience
functions:</p>
<p>Net::SSLeay::ssl_write_all($ssl, $message) or die "ssl write
failure"; $got = Net::SSLeay::ssl_read_all($ssl) or die "ssl read
failure";</p>
<h1>KNOWN BUGS AND CAVEATS</h1>
<p>LibreSSL versions in the 3.1 - 3.3 series contain a TLS 1.3
implementation that is not fully compatible with the libssl API, but is
still advertised during protocol auto-negotiation. If you encounter
problems or unexpected behaviour with SSL or SSL_CTX objects whose
protocol version was automatically negotiated and libssl is provided by
any of these versions of LibreSSL, it could be because the peers
negotiated to use TLS 1.3 - try setting the maximum protocol version to
TLS 1.2 (via <code>Net::SSLeay::set_max_proto_version()</code> or
<code>Net::SSLeay::CTX_set_max_proto_version()</code>) before
establishing the connection. The first stable LibreSSL version with a
fully libssl-compatible TLS 1.3 implementation is 3.4.1.</p>
<p>An OpenSSL bug CVE-2015-0290 OpenSSL Multiblock Corrupted Pointer
Issue can cause POST requests of over 90kB to fail or crash. This bug is
reported to be fixed in OpenSSL 1.0.2a.</p>
<p>Autoloader emits a</p>
<p>Argument "xxx" isnt numeric in entersub at blib/lib/Net/SSLeay.pm</p>
<p>warning if die_if_ssl_error is made autoloadable. If you figure out
why, drop me a line.</p>
<p>Callback set using <code>SSL_set_verify()</code> does not appear to
work. This may well be an openssl problem (e.g. see
<code>ssl/ssl_lib.c</code> line 1029). Try using
<code>SSL_CTX_set_verify()</code> instead and do not be surprised if
even this stops working in future versions.</p>
<p>Callback and certificate verification stuff is generally too little
tested.</p>
<p>Random numbers are not initialized randomly enough, especially if you
do not have <code>/dev/random</code> and/or <code>/dev/urandom</code>
(such as in Solaris platforms - but it's been suggested that cryptorand
daemon from the SUNski package solves this). In this case you should
investigate third party software that can emulate these devices, e.g. by
way of a named pipe to some program.</p>
<p>Another gotcha with random number initialization is randomness
depletion. This phenomenon, which has been extensively discussed in
OpenSSL, Apache-SSL, and Apache-mod_ssl forums, can cause your script to
block if you use <code>/dev/random</code> or to operate insecurely if
you use <code>/dev/urandom</code>. What happens is that when too much
randomness is drawn from the operating system's randomness pool then
randomness can temporarily be unavailable. <code>/dev/random</code>
solves this problem by waiting until enough randomness can be gathered -
and this can take a long time since blocking reduces activity in the
machine and less activity provides less random events: a vicious circle.
<code>/dev/urandom</code> solves this dilemma more pragmatically by
simply returning predictable random numbers.
Some<code> /dev/urandom</code> emulation software however actually seems
to implement <code>/dev/random</code> semantics. Caveat emptor.</p>
<p>I've been pointed to two such daemons by Mik Firestone
&lt;mik@@speed.stdio._com&gt; who has used them on Solaris 8:</p>
<ol type="1">
<li><p>Entropy Gathering Daemon (EGD) at
&lt;http://www.lothar.com/tech/crypto/&gt;</p></li>
<li><p>Pseudo-random number generating daemon (PRNGD) at
&lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;</p></li>
</ol>
<p>If you are using the low level API functions to communicate with
other SSL implementations, you would do well to call</p>
<p>Net::SSLeay::CTX_set_options($ctx, &amp;Net::SSLeay::OP_ALL) or
die_if_ssl_error("ssl ctx set options");</p>
<p>to cope with some well know bugs in some other SSL implementations.
The high level API functions always set all known compatibility
options.</p>
<p>Sometimes <code>sslcat()</code> (and the high level HTTPS functions
that build on it) is too fast in signaling the EOF to legacy HTTPS
servers. This causes the server to return empty page. To work around
this problem you can set the global variable</p>
<p>$Net::SSLeay::slowly = 1; # Add sleep so broken servers can keep
up</p>
<p>HTTP/1.1 is not supported. Specifically this module does not know to
issue or serve multiple http requests per connection. This is a serious
shortcoming, but using the SSL session cache on your server helps to
alleviate the CPU load somewhat.</p>
<p>As of version 1.09 many newer OpenSSL auxiliary functions were added
(from <code>REM_AUTOMATICALLY_GENERATED_1_09</code> onwards in
<code>SSLeay.xs</code>). Unfortunately I have not had any opportunity to
test these. Some of them are trivial enough that I believe they just
work, but others have rather complex interfaces with function pointers
and all. In these cases you should proceed wit great caution.</p>
<p>This module defaults to using OpenSSL automatic protocol negotiation
code for automatically detecting the version of the SSL/TLS protocol
that the other end talks. With most web servers this works just fine,
but once in a while I get complaints from people that the module does
not work with some web servers. Usually this can be solved by explicitly
setting the protocol version, e.g.</p>
<p>$Net::SSLeay::ssl_version = 2; # Insist on SSLv2
$Net::SSLeay::ssl_version = 3; # Insist on SSLv3
$Net::SSLeay::ssl_version = 10; # Insist on TLSv1
$Net::SSLeay::ssl_version = 11; # Insist on TLSv1.1
$Net::SSLeay::ssl_version = 12; # Insist on TLSv1.2
$Net::SSLeay::ssl_version = 13; # Insist on TLSv1.3</p>
<p>Although the autonegotiation is nice to have, the SSL standards do
not formally specify any such mechanism. Most of the world has accepted
the SSLeay/OpenSSL way of doing it as the de facto standard. But for the
few that think differently, you have to explicitly speak the correct
version. This is not really a bug, but rather a deficiency in the
standards. If a site refuses to respond or sends back some nonsensical
error codes (at the SSL handshake level), try this option before mailing
me.</p>
<p>On some systems, OpenSSL may be compiled without support for SSLv2.
If this is the case, Net::SSLeay will warn if ssl_version has been set
to 2.</p>
<p>The high level API returns the certificate of the peer, thus allowing
one to check what certificate was supplied. However, you will only be
able to check the certificate after the fact, i.e. you already sent your
form data by the time you find out that you did not trust them,
oops.</p>
<p>So, while being able to know the certificate after the fact is surely
useful, the security minded would still choose to do the connection and
certificate verification first and only then exchange data with the
site. Currently none of the high level API functions do this, thus you
would have to program it using the low level API. A good place to start
is to see how the <code>Net::SSLeay::http_cat()</code> function is
implemented.</p>
<p>The high level API functions use a global file handle
<code>SSLCAT_S</code> internally. This really should not be a problem
because there is no way to interleave the high level API functions,
unless you use threads (but threads are not very well supported in perl
anyway). However, you may run into problems if you call undocumented
internal functions in an interleaved fashion. The best solution is to
require Net::SSLeay in one thread after all the threads have been
created.</p>
<h1>DIAGNOSTICS</h1>
<dl>
<dt>Random number generator not seeded!!!</dt>
<dd>
<p><strong>(W)</strong> This warning indicates that
<code>randomize()</code> was not able to read <code>/dev/random</code>
or <code>/dev/urandom</code>, possibly because your system does not have
them or they are differently named. You can still use SSL, but the
encryption will not be as strong.</p>
</dd>
<dt>open_tcp_connection: destination host not found:`server' (port 123)
($!)</dt>
<dd>
<p>Name lookup for host named <code>server</code> failed.</p>
</dd>
<dt>open_tcp_connection: failed `server', 123 ($!)</dt>
<dd>
<p>The name was resolved, but establishing the TCP connection
failed.</p>
</dd>
<dt>msg 123: 1 - error:140770F8:SSL
routines:SSL23_GET_SERVER_HELLO:unknown proto</dt>
<dd>
<p>SSLeay error string. The first number (123) is the PID, the second
number (1) indicates the position of the error message in SSLeay error
stack. You often see a pile of these messages as errors cascade.</p>
</dd>
<dt>msg 123: 1 - error:02001002::lib(2) :func(1) :reason(2)</dt>
<dd>
<p>The same as above, but you didn't call
<strong>load_error_strings()</strong> so SSLeay couldn't verbosely
explain the error. You can still find out what it means with this
command: /usr/local/ssl/bin/ssleay errstr 02001002</p>
</dd>
<dt>Password is being asked for private key</dt>
<dd>
<p>This is normal behaviour if your private key is encrypted. Either you
have to supply the password or you have to use an unencrypted private
key. Scan OpenSSL.org for the FAQ that explains how to do this (or just
study examples/makecert.pl which is used during <code>make test</code>
to do just that).</p>
</dd>
</dl>
<h1>SECURITY</h1>
<p>You can mitigate some of the security vulnerabilities that might be
present in your SSL/TLS application:</p>
<h2>BEAST Attack</h2>
<p>http://blogs.cisco.com/security/beat-the-beast-with-tls/
https://community.qualys.com/blogs/securitylabs/2011/10/17/mitigating-the-beast-attack-on-tls
http://blog.zoller.lu/2011/09/beast-summary-tls-cbc-countermeasures.html</p>
<p>The BEAST attack relies on a weakness in the way CBC mode is used in
SSL/TLS. In OpenSSL versions 0.9.6d and later, the protocol-level
mitigation is enabled by default, thus making it not vulnerable to the
BEAST attack.</p>
<p>Solutions:</p>
<ul>
<li><p>Compile with OpenSSL versions 0.9.6d or later, which enables
SSL_OP_ALL by default</p></li>
<li><p>Ensure SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS is not enabled (its not
enabled by default)</p></li>
<li><p>Don't support SSLv2, SSLv3</p></li>
<li><p>Actively control the ciphers your server supports with
set_cipher_list:</p></li>
</ul>
<p>Net::SSLeay::set_cipher_list($ssl, 'RC4-SHA:HIGH:!ADH');</p>
<h2>Session Resumption</h2>
<p>http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html</p>
<p>The SSL Labs vulnerability test on your SSL server might report in
red:</p>
<p>Session resumption No (IDs assigned but not accepted)</p>
<p>This report is not really bug or a vulnerability, since the server
will not accept session resumption requests. However, you can prevent
this noise in the report by disabling the session cache altogether:
Net::SSLeay::CTX_set_session_cache_mode($ssl_ctx,
<strong>Net::SSLeay::SESS_CACHE_OFF()</strong>); Use 0 if you don't have
SESS_CACHE_OFF constant.</p>
<h2>Secure Renegotiation and DoS Attack</h2>
<p>https://community.qualys.com/blogs/securitylabs/2011/10/31/tls-renegotiation-and-denial-of-service-attacks</p>
<p>This is not a security flaw, it is more of a DoS vulnerability.</p>
<p>Solutions:</p>
<ul>
<li><p>Do not support SSLv2</p></li>
<li><p>Do not set the SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION
option</p></li>
<li><p>Compile with OpenSSL 0.9.8m or later</p></li>
</ul>
<h1>BUGS</h1>
<p>If you encounter a problem with this module that you believe is a
bug, please create a new issue
&lt;https://github.com/radiator-software/p5-net-ssleay/issues/new&gt; in
the Net-SSLeay GitHub repository. Please make sure your bug report
includes the following information:</p>
<ul>
<li><p>the code you are trying to run;</p></li>
<li><p>your operating system name and version;</p></li>
<li><p>the output of <code>perl -V</code>;</p></li>
<li><p>the version of OpenSSL or LibreSSL you are using.</p></li>
</ul>
<h1>AUTHOR</h1>
<p>Originally written by Sampo Kellomki.</p>
<p>Maintained by Florian Ragwitz between November 2005 and January
2010.</p>
<p>Maintained by Mike McCauley between November 2005 and June 2018.</p>
<p>Maintained by Chris Novakovic, Tuure Vartiainen and Heikki Vatiainen
since June 2018.</p>
<h1>COPYRIGHT</h1>
<p>Copyright (c) 1996-2003 Sampo Kellomki &lt;sampo@iki.fi&gt;</p>
<p>Copyright (c) 2005-2010 Florian Ragwitz &lt;rafl@debian.org&gt;</p>
<p>Copyright (c) 2005-2018 Mike McCauley &lt;mikem@airspayce.com&gt;</p>
<p>Copyright (c) 2018- Chris Novakovic &lt;chris@chrisn.me.uk&gt;</p>
<p>Copyright (c) 2018- Tuure Vartiainen
&lt;vartiait@radiatorsoftware.com&gt;</p>
<p>Copyright (c) 2018- Heikki Vatiainen
&lt;hvn@radiatorsoftware.com&gt;</p>
<p>All rights reserved.</p>
<h1>LICENSE</h1>
<p>This module is released under the terms of the Artistic License 2.0.
For details, see the <code>LICENSE</code> file distributed with
Net-SSLeay's source code.</p>
<h1>SEE ALSO</h1>
<p>Net::SSLeay::Handle - File handle interface ./examples - Example
servers and a clients &lt;http://www.openssl.org/&gt; - OpenSSL source,
documentation, etc openssl-users-request@openssl.org - General OpenSSL
mailing list &lt;http://www.ietf.org/rfc/rfc2246.txt&gt; - TLS 1.0
specification &lt;http://www.w3c.org&gt; - HTTP specifications
&lt;http://www.ietf.org/rfc/rfc2617.txt&gt; - How to send password
&lt;http://www.lothar.com/tech/crypto/&gt; - Entropy Gathering Daemon
(EGD)
&lt;http://www.aet.tu-cottbus.de/personen/jaenicke/postfix_tls/prngd.html&gt;
- pseudo-random number generating daemon (PRNGD) perl(1) perlref(1)
perllol(1) perldoc ~openssl/doc/ssl/SSL_CTX_set_verify.pod</p>
