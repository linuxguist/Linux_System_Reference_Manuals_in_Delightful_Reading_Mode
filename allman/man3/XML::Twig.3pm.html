<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>XML::Twig - A perl module for processing huge XML documents in tree
mode.</p>
<h1>SYNOPSIS</h1>
<p>Note that this documentation is intended as a reference to the
module.</p>
<p>Complete docs, including a tutorial, examples, an easier to use HTML
version, a quick reference card and a FAQ are available at
&lt;http://www.xmltwig.org/xmltwig&gt;</p>
<p>Small documents (loaded in memory as a tree):</p>
<p>my $twig=XML::Twig-&gt;new(); # create the twig $twig-&gt;parsefile(
doc.xml); # build it my_process( $twig); # use twig methods to process
it $twig-&gt;print; # output the twig</p>
<p>Huge documents (processed in combined stream/tree mode):</p>
<p># at most one div will be loaded in memory my
$twig=XML::Twig-&gt;new( twig_handlers =&gt; { title =&gt; sub {
$_-&gt;set_tag( h2) }, # change title tags to h2 # $_ is the current
element para =&gt; sub { $_-&gt;set_tag( p) }, # change para to p hidden
=&gt; sub { $_-&gt;delete; }, # remove hidden elements list =&gt;
\&amp;my_list_process, # process list elements div =&gt; sub {
$_[0]-&gt;flush; }, # output and free memory }, pretty_print =&gt;
indented, # output will be nicely formatted empty_tags =&gt; html, #
outputs &lt;empty_tag /&gt; ); $twig-&gt;parsefile( my_big.xml); sub
my_list_process { my( $twig, $list)= @_; # ... }</p>
<p>See XML::Twig 101 for other ways to use the module, as a filter for
example.</p>
<h1>DESCRIPTION</h1>
<p>This module provides a way to process XML documents. It is build on
top of <code>XML::Parser</code>.</p>
<p>The module offers a tree interface to the document, while allowing
you to output the parts of it that have been completely processed.</p>
<p>It allows minimal resource (CPU and memory) usage by building the
tree only for the parts of the documents that need actual processing,
through the use of the <code>twig_roots </code> and
<code>twig_print_outside_roots </code> options. The <code>finish </code>
and <code>finish_print </code> methods also help to increase
performances.</p>
<p>XML::Twig tries to make simple things easy so it tries its best to
takes care of a lot of the (usually) annoying (but sometimes necessary)
features that come with XML and XML::Parser.</p>
<h1>TOOLS</h1>
<p>XML::Twig comes with a few command-line utilities:</p>
<h2>xml_pp - xml pretty-printer</h2>
<p>XML pretty printer using XML::Twig</p>
<h2>xml_grep - grep XML files looking for specific elements</h2>
<p><code>xml_grep</code> does a grep on XML files. Instead of using
regular expressions it uses XPath expressions (in fact the subset of
XPath supported by XML::Twig).</p>
<h2>xml_split - cut a big XML file into smaller chunks</h2>
<p><code>xml_split</code> takes a (presumably big) XML file and split it
in several smaller files, based on various criteria (level in the tree,
size or an XPath expression)</p>
<h2>xml_merge - merge back XML files split with xml_split</h2>
<p><code>xml_merge</code> takes several xml files that have been split
using <code>xml_split</code> and recreates a single file.</p>
<h2>xml_spellcheck - spellcheck XML files</h2>
<p><code>xml_spellcheck</code> lets you spell check the content of an
XML file. It extracts the text (the content of elements and optionally
of attributes), call a spell checker on it and then recreates the XML
document.</p>
<h1>XML::Twig 101</h1>
<p>XML::Twig can be used either on small XML documents (that fit in
memory) or on huge ones, by processing parts of the document and
outputting or discarding them once they are processed.</p>
<h2>Loading an XML document and processing it</h2>
<p>my $t= XML::Twig-&gt;new(); $t-&gt;parse(
&lt;d&gt;&lt;title&gt;title&lt;/title&gt;&lt;para&gt;p
1&lt;/para&gt;&lt;para&gt;p 2&lt;/para&gt;&lt;/d&gt;); my $root=
$t-&gt;root; $root-&gt;set_tag( html); # change doc to html $title=
$root-&gt;first_child( title); # get the title $title-&gt;set_tag( h1);
# turn it into h1 my @para= $root-&gt;children( para); # get the para
children foreach my $para (@para) { $para-&gt;set_tag( p); } # turn them
into p $t-&gt;print; # output the document</p>
<p>Other useful methods include:</p>
<p>att: <code>$elt-&gt;{att}-&gt;{foo}</code> return the
<code>foo</code> attribute for an element,</p>
<p>set_att : <code>$elt-&gt;set_att( foo =&gt; "bar")</code> sets the
<code>foo</code> attribute to the <code>bar</code> value,</p>
<p>next_sibling: <code>$elt-&gt;{next_sibling}</code> return the next
sibling in the document (in the example
<code>$title-&gt;{next_sibling}</code> is the first <code>para</code>,
you can also (and actually should) use
<code>$elt-&gt;next_sibling( para)</code> to get it</p>
<p>The document can also be transformed through the use of the cut,
copy, paste and move methods:
<code>$title-&gt;cut; $title-&gt;paste( after =&gt; $p);</code> for
example</p>
<p>And much, much more, see XML::Twig::Elt.</p>
<h2>Processing an XML document chunk by chunk</h2>
<p>One of the strengths of XML::Twig is that it let you work with files
that do not fit in memory (BTW storing an XML document in memory as a
tree is quite memory-expensive, the expansion factor being often around
10).</p>
<p>To do this you can define handlers, that will be called once a
specific element has been completely parsed. In these handlers you can
access the element and process it as you see fit, using the navigation
and the cut-n-paste methods, plus lots of convenient ones like
<code>prefix </code>. Once the element is completely processed you can
then <code>flush </code> it, which will output it and free the memory.
You can also <code>purge </code> it if you don't need to output it (if
you are just extracting some data from the document for example). The
handler will be called again once the next relevant element has been
parsed.</p>
<p>my $t= XML::Twig-&gt;new( twig_handlers =&gt; { section =&gt;
\&amp;section, para =&gt; sub { $_-&gt;set_tag( p); } }, );
$t-&gt;parsefile( doc.xml); # the handler is called once a section is
completely parsed, ie when # the end tag for section is found, it
receives the twig itself and # the element (including all its
sub-elements) as arguments sub section { my( $t, $section)= @_; #
arguments for all twig_handlers $section-&gt;set_tag( div); # change the
tag name # lets use the attribute nb as a prefix to the title my $title=
$section-&gt;first_child( title); # find the title my $nb=
$title-&gt;{att}-&gt;{nb}; # get the attribute $title-&gt;prefix( "$nb -
"); # easy isnt it? $section-&gt;flush; # outputs the section and frees
memory }</p>
<p>There is of course more to it: you can trigger handlers on more
elaborate conditions than just the name of the element,
<code>section/title</code> for example.</p>
<p>my $t= XML::Twig-&gt;new( twig_handlers =&gt; { section/title =&gt;
sub { $_-&gt;print } } ) -&gt;parsefile( doc.xml);</p>
<p>Here <code>sub { $_-&gt;print }</code> simply prints the current
element (<code>$_</code> is aliased to the element in the handler).</p>
<p>You can also trigger a handler on a test on an attribute:</p>
<p>my $t= XML::Twig-&gt;new( twig_handlers =&gt; { section[@level="1"]
=&gt; sub { $_-&gt;print } } ); -&gt;parsefile( doc.xml);</p>
<p>You can also use <code>start_tag_handlers </code> to process an
element as soon as the start tag is found. Besides <code>prefix </code>
you can also use <code>suffix </code>,</p>
<h2>Processing just parts of an XML document</h2>
<p>The twig_roots mode builds only the required sub-trees from the
document Anything outside of the twig roots will just be ignored:</p>
<p>my $t= XML::Twig-&gt;new( # the twig will include just the root and
selected titles twig_roots =&gt; { section/title =&gt;
\&amp;print_n_purge, annex/title =&gt; \&amp;print_n_purge } );
$t-&gt;parsefile( doc.xml); sub print_n_purge { my( $t, $elt)= @_; print
$elt-&gt;text; # print the text (including sub-element texts)
$t-&gt;purge; # frees the memory }</p>
<p>You can use that mode when you want to process parts of a documents
but are not interested in the rest and you don't want to pay the price,
either in time or memory, to build the tree for the it.</p>
<h2>Building an XML filter</h2>
<p>You can combine the <code>twig_roots</code> and the
<code>twig_print_outside_roots</code> options to build filters, which
let you modify selected elements and will output the rest of the
document as is.</p>
<p>This would convert prices in $ to prices in Euro in a document:</p>
<p>my $t= XML::Twig-&gt;new( twig_roots =&gt; { price =&gt;
\&amp;convert, }, # process prices twig_print_outside_roots =&gt; 1, #
print the rest ); $t-&gt;parsefile( doc.xml); sub convert { my( $t,
$price)= @_; my $currency= $price-&gt;{att}-&gt;{currency}; # get the
currency if( $currency eq USD) { $usd_price= $price-&gt;text; # get the
price # %rate is just a conversion table my $euro_price= $usd_price *
$rate{usd2euro}; $price-&gt;set_text( $euro_price); # set the new price
$price-&gt;set_att( currency =&gt; EUR); # dont forget this! }
$price-&gt;print; # output the price }</p>
<h2>XML::Twig and various versions of Perl, XML::Parser and expat:</h2>
<p>XML::Twig is a lot more sensitive to variations in versions of perl,
XML::Parser and expat than to the OS, so this should cover some
reasonable configurations.</p>
<p>The recommended configuration is perl 5.8.3+ (for good Unicode
support), XML::Parser 2.31+ and expat 1.95.5+</p>
<p>See
&lt;http://testers.cpan.org/search?request=dist&amp;dist=XML-Twig&gt;
for the CPAN testers reports on XML::Twig, which list all tested
configurations.</p>
<p>An Atom feed of the CPAN Testers results is available at
&lt;http://xmltwig.org/rss/twig_testers.rss&gt;</p>
<p>Finally:</p>
<dl>
<dt>XML::Twig does NOT work with expat 1.95.4</dt>
<dd>

</dd>
</dl>
<dl>
<dt>XML::Twig only works with XML::Parser 2.27 in perl 5.6.*</dt>
<dd>

</dd>
</dl>
<p>Note that I can't compile XML::Parser 2.27 anymore, so I can't
guarantee that it still works</p>
<dl>
<dt>XML::Parser 2.28 does not really work</dt>
<dd>

</dd>
</dl>
<p>When in doubt, upgrade expat, XML::Parser and Scalar::Util</p>
<p>Finally, for some optional features, XML::Twig depends on some
additional modules. The complete list, which depends somewhat on the
version of Perl that you are running, is given by running
<code>t/zz_dump_config.t</code></p>
<h1>Simplifying XML processing</h1>
<dl>
<dt>Whitespaces</dt>
<dd>
<p>Whitespaces that look non-significant are discarded, this behaviour
can be controlled using the <code>keep_spaces </code>,
<code>keep_spaces_in </code> and <code>discard_spaces_in </code>
options.</p>
</dd>
<dt>Encoding</dt>
<dd>
<p>You can specify that you want the output in the same encoding as the
input (provided you have valid XML, which means you have to specify the
encoding either in the document or when you create the Twig object)
using the <code>keep_encoding </code> option You can also use
<code>output_encoding</code> to convert the internal UTF-8 format to the
required encoding.</p>
</dd>
<dt>Comments and Processing Instructions (PI)</dt>
<dd>
<p>Comments and PI's can be hidden from the processing, but still appear
in the output (they are carried by the real element closer to them)</p>
</dd>
<dt>Pretty Printing</dt>
<dd>
<p>XML::Twig can output the document pretty printed so it is easier to
read for us humans.</p>
</dd>
<dt>Surviving an untimely death</dt>
<dd>
<p>XML parsers are supposed to react violently when fed improper XML.
XML::Parser just dies. XML::Twig provides the <code>safe_parse </code>
and the <code>safe_parsefile </code> methods which wrap the parse in an
eval and return either the parsed twig or 0 in case of failure.</p>
</dd>
<dt>Private attributes</dt>
<dd>
<p>Attributes with a name starting with # (illegal in XML) will not be
output, so you can safely use them to store temporary values during
processing. Note that you can store anything in a private attribute, not
just text, it's just a regular Perl variable, so a reference to an
object or a huge data structure is perfectly fine.</p>
</dd>
</dl>
<h1>CLASSES</h1>
<p>XML::Twig uses a very limited number of classes. The ones you are
most likely to use are <code>XML::Twig</code> of course, which
represents a complete XML document, including the document itself (the
root of the document itself is <code>root</code>), its handlers, its
input or output filters... The other main class is
<code>XML::Twig::Elt</code>, which models an XML element. Element here
has a very wide definition: it can be a regular element, or but also
text, with an element <code>tag</code> of <code>#PCDATA</code> (or
<code>#CDATA</code>), an entity (tag is <code>#ENT</code>), a Processing
Instruction (<code>#PI</code>), a comment (<code>#COMMENT</code>).</p>
<p>Those are the 2 commonly used classes.</p>
<p>You might want to look the <code>elt_class</code> option if you want
to subclass <code>XML::Twig::Elt</code>.</p>
<p>Attributes are just attached to their parent element, they are not
objects per se. (Please use the provided methods <code>att</code> and
<code>set_att</code> to access them, if you access them as a hash, then
your code becomes implementation dependent and might break in the
future).</p>
<p>Other classes that are seldom used are
<code>XML::Twig::Entity_list</code> and
<code>XML::Twig::Entity</code>.</p>
<p>If you use <code>XML::Twig::XPath</code> instead of
<code>XML::Twig</code>, elements are then created as
<code>XML::Twig::XPath::Elt</code></p>
<h1>METHODS</h1>
<h2>XML::Twig</h2>
<p>A twig is a subclass of XML::Parser, so all XML::Parser methods can
be called on a twig object, including parse and parsefile.
<code>setHandlers</code> on the other hand cannot be used, see
<code>BUGS </code></p>
<dl>
<dt>new</dt>
<dd>
<p>This is a class method, the constructor for XML::Twig. Options are
passed as keyword value pairs. Recognized options are the same as
XML::Parser, plus some (in fact a lot!) XML::Twig specifics. New
Options:</p>
<dl>
<dt>twig_handlers</dt>
<dd>
<p>This argument consists of a hash <code>{ expression =</code>
\&amp;handler}&gt; where expression is a an <em>XPath-like
expression</em> (+ some others). XPath expressions are limited to using
the child and descendant axis (indeed you can't specify an axis), and
predicates cannot be nested. You can use the <code>string</code>, or
<code>string(&lt;tag&gt;)</code> function (except in
<code>twig_roots</code> triggers). Additionally you can use regexps (/
delimited) to match attribute and string values. Examples: foo foo/bar
foo//bar /foo/bar /foo//bar /foo/bar[@att1 = "val1" and @att2 =
"val2"]/baz[@a &gt;= 1] foo[string()=~ /^duh!+/] /foo[string(bar)=~
/\d+/]/baz[@att != 3] #CDATA can be used to call a handler for a CDATA
section. #COMMENT can be used to call a handler for comments Some
additional (non-XPath) expressions are also provided for
convenience:</p>
<dl>
<dt>processing instructions</dt>
<dd>
<p><code>?</code> or <code>#PI</code> triggers the handler for any
processing instruction, and <code>?&lt;target&gt;</code> or
<code>#PI &lt;target&gt;</code> triggers a handler for processing
instruction with the given target( ex:
<code>#PI xml-stylesheet</code>).</p>
</dd>
<dt>level(&lt;level&gt;)</dt>
<dd>
<p>Triggers the handler on any element at that level in the tree (root
is level 1)</p>
</dd>
<dt>_all_</dt>
<dd>
<p>Triggers the handler for <strong>all</strong> elements in the
tree</p>
</dd>
<dt>_default_</dt>
<dd>
<p>Triggers the handler for each element that does NOT have any other
handler.</p>
</dd>
</dl>
<p>Expressions are evaluated against the input document. Which means
that even if you have changed the tag of an element (changing the tag of
a parent element from a handler for example) the change will not impact
the expression evaluation. There is an exception to this: private
attributes (which name start with a '#', and can only be created during
the parsing, as they are not valid XML) are checked against the current
twig. Handlers are triggered in fixed order, sorted by their type (xpath
expressions first, then regexps, then level), then by whether they
specify a full path (starting at the root element) or not, then by
number of steps in the expression, then number of predicates, then
number of tests in predicates. Handlers where the last step does not
specify a step (<code>foo/bar/*</code>) are triggered after other XPath
handlers. Finally <code>_all_</code> handlers are triggered last.
<strong>Important</strong>: once a handler has been triggered if it
returns 0 then no other handler is called, except a <code>_all_</code>
handler which will be called anyway. If a handler returns a true value
and other handlers apply, then the next applicable handler will be
called. Repeat, rinse, lather..; The exception to that rule is when the
<code>do_not_chain_handlers</code> option is set, in which case only the
first handler will be called. Note that it might be a good idea to
explicitly return a short true value (like 1) from handlers: this
ensures that other applicable handlers are called even if the last
statement for the handler happens to evaluate to false. This might also
speedup the code by avoiding the result of the last statement of the
code to be copied and passed to the code managing handlers. It can
really pay to have 1 instead of a long string returned. When the closing
tag for an element is parsed the corresponding handler is called, with 2
arguments: the twig and the <code>Element </code>. The twig includes the
document tree that has been built so far, the element is the complete
sub-tree for the element. <strong>The fact that the handler is called
only when the</strong> closing tag for the element is found means that
handlers for inner elements are called before handlers for outer
elements. <code>$_</code> is also set to the element, so it is easy to
write inline handlers like para =&gt; sub { $_-&gt;set_tag( p); } Text
is stored in elements whose tag name is #PCDATA (due to mixed content,
text and sub-element in an element there is no way to store the text as
just an attribute of the enclosing element, this is similar to the DOM
model). <strong>Warning</strong>: if you have used purge or flush on the
twig the element might not be complete, some of its children might have
been entirely flushed or purged, and the start tag might even have been
printed (by <code>flush</code>) already, so changing its tag might not
give the expected result.</p>
</dd>
<dt>twig_roots</dt>
<dd>
<p>This argument lets you build the tree only for those elements you are
interested in. Example: my $t= XML::Twig-&gt;new( twig_roots =&gt; {
title =&gt; 1, subtitle =&gt; 1}); $t-&gt;parsefile( file); my $t=
XML::Twig-&gt;new( twig_roots =&gt; { section/title =&gt; 1});
$t-&gt;parsefile( file); return a twig containing a document including
only <code>title</code> and <code>subtitle</code> elements, as children
of the root element. You can use <em>generic_attribute_condition</em>,
<em>attribute_condition</em>, <em>full_path</em>, <em>partial_path</em>,
<em>tag</em>, <em>tag_regexp</em>, <em>_default_</em> and <em>_all_</em>
to trigger the building of the twig. <em>string_condition</em> and
<em>regexp_condition</em> cannot be used as the content of the element,
and the string, have not yet been parsed when the condition is checked.
<strong>WARNING</strong>: path are checked for the document. Even if the
<code>twig_roots</code> option is used they will be checked against the
full document tree, not the virtual tree created by XML::Twig
<strong>WARNING</strong>: twig_roots elements should NOT be nested, that
would hopelessly confuse XML::Twig ;--( Note: you can set handlers
(twig_handlers) using twig_roots Example: my <code>$t</code>=
XML::Twig-&gt;new( twig_roots =&gt; { title =&gt; sub {
<code>$_</code>[1]-&gt;print;}, subtitle =&gt; \&amp;process_subtitle }
); <code>$t</code>-&gt;parsefile( file);</p>
</dd>
<dt>twig_print_outside_roots</dt>
<dd>
<p>To be used in conjunction with the <code>twig_roots</code> argument.
When set to a true value this will print the document outside of the
<code>twig_roots</code> elements. Example: my $t= XML::Twig-&gt;new(
twig_roots =&gt; { title =&gt; \&amp;number_title },
twig_print_outside_roots =&gt; 1, ); $t-&gt;parsefile( file); { my $nb;
sub number_title { my( $twig, $title); $nb++; $title-&gt;prefix( "$nb
"); $title-&gt;print; } } This example prints the document outside of
the title element, calls <code>number_title</code> for each
<code>title</code> element, prints it, and then resumes printing the
document. The twig is built only for the <code>title</code> elements. If
the value is a reference to a file handle then the document outside the
<code>twig_roots</code> elements will be output to this file handle:
open( my $out, &gt;, out_file.xml) or die "cannot open out file.xml
out_file:$!"; my $t= XML::Twig-&gt;new( twig_roots =&gt; { title =&gt;
\&amp;number_title }, # default output to $out twig_print_outside_roots
=&gt; $out, ); { my $nb; sub number_title { my( $twig, $title); $nb++;
$title-&gt;prefix( "$nb "); $title-&gt;print( $out); # you have to print
to \*OUT here } }</p>
</dd>
<dt>start_tag_handlers</dt>
<dd>
<p>A hash <code>{ expression =</code> \&amp;handler}&gt;. Sets element
handlers that are called when the element is open (at the end of the
XML::Parser <code>Start</code> handler). The handlers are called with 2
params: the twig and the element. The element is empty at that point,
its attributes are created though. You can use
<em>generic_attribute_condition</em>, <em>attribute_condition</em>,
<em>full_path</em>, <em>partial_path</em>, <em>tag</em>,
<em>tag_regexp</em>, <em>_default_</em> and <em>_all_</em> to trigger
the handler. <em>string_condition</em> and <em>regexp_condition</em>
cannot be used as the content of the element, and the string, have not
yet been parsed when the condition is checked. The main uses for those
handlers are to change the tag name (you might have to do it as soon as
you find the open tag if you plan to <code>flush</code> the twig at some
point in the element, and to create temporary attributes that will be
used when processing sub-element with <code>twig_hanlders</code>.
<strong>Note</strong>: <code>start_tag</code> handlers can be called
outside of <code>twig_roots</code> if this argument is used. Since the
element object is not built, in this case handlers are called with the
following arguments: <code>$t</code> (the twig), <code>$tag</code> (the
tag of the element) and <code>%att</code> (a hash of the attributes of
the element). If the <code>twig_print_outside_roots</code> argument is
also used, if the last handler called returns a <code>true</code> value,
then the start tag will be output as it appeared in the original
document, if the handler returns a <code>false</code> value then the
start tag will <strong>not</strong> be printed (so you can print a
modified string yourself for example). Note that you can use the ignore
method in <code>start_tag_handlers</code> (and only there).</p>
</dd>
<dt>end_tag_handlers</dt>
<dd>
<p>A hash <code>{ expression =</code> \&amp;handler}&gt;. Sets element
handlers that are called when the element is closed (at the end of the
XML::Parser <code>End</code> handler). The handlers are called with 2
params: the twig and the tag of the element. <em>twig_handlers</em> are
called when an element is completely parsed, so why have this redundant
option? There is only one use for <code>end_tag_handlers</code>: when
using the <code>twig_roots</code> option, to trigger a handler for an
element <strong>outside</strong> the roots. It is for example very
useful to number titles in a document using nested sections: my @no=
(0); my $no; my $t= XML::Twig-&gt;new( start_tag_handlers =&gt; {
section =&gt; sub { $no[$#no]++; $no= join ., @no; push @no, 0; } },
twig_roots =&gt; { title =&gt; sub { $_-&gt;prefix( $no); $_-&gt;print;
} }, end_tag_handlers =&gt; { section =&gt; sub { pop @no; } },
twig_print_outside_roots =&gt; 1 ); $t-&gt;parsefile( $file); Using the
<code>end_tag_handlers</code> argument without <code>twig_roots</code>
will result in an error.</p>
</dd>
<dt>do_not_chain_handlers</dt>
<dd>
<p>If this option is set to a true value, then only one handler will be
called for each element, even if several satisfy the condition Note that
the <code>_all_</code> handler will still be called regardless</p>
</dd>
<dt>ignore_elts</dt>
<dd>
<p>This option lets you ignore elements when building the twig. This is
useful in cases where you cannot use <code>twig_roots</code> to ignore
elements, for example if the element to ignore is a sibling of elements
you are interested in. Example: my $twig= XML::Twig-&gt;new( ignore_elts
=&gt; { elt =&gt; discard }); $twig-&gt;parsefile( doc.xml); This will
build the complete twig for the document, except that all
<code>elt</code> elements (and their children) will be left out. The
keys in the hash are triggers, limited to the same subset as
<code>start_tag_handlers</code>. The values can be <code>discard</code>,
to discard the element, <code>print</code>, to output the element as-is,
<code>string</code> to store the text of the ignored element(s),
including markup, in a field of the twig:
<code>$t-&gt;{twig_buffered_string}</code> or a reference to a scalar,
in which case the text of the ignored element(s), including markup, will
be stored in the scalar. Any other value will be treated as
<code>discard</code>.</p>
</dd>
<dt>char_handler</dt>
<dd>
<p>A reference to a subroutine that will be called every time
<code>PCDATA</code> is found. The subroutine receives the string as
argument, and returns the modified string: # WE WANT ALL STRINGS IN
UPPER CASE sub my_char_handler { my( $text)= @_; $text= uc( $text);
return $text; }</p>
</dd>
<dt>elt_class</dt>
<dd>
<p>The name of a class used to store elements. this class should inherit
from <code>XML::Twig::Elt</code> (and by default it is
<code>XML::Twig::Elt</code>). This option is used to subclass the
element class and extend it with new methods. This option is needed
because during the parsing of the XML, elements are created by
<code>XML::Twig</code>, without any control from the user code.</p>
</dd>
<dt>keep_atts_order</dt>
<dd>
<p>Setting this option to a true value causes the attribute hash to be
tied to a <code>Tie::IxHash</code> object. This means that
<code>Tie::IxHash</code> needs to be installed for this option to be
available. It also means that the hash keeps its order, so you will get
the attributes in order. This allows outputting the attributes in the
same order as they were in the original document.</p>
</dd>
<dt>keep_encoding</dt>
<dd>
<p>This is a (slightly?) evil option: if the XML document is not UTF-8
encoded and you want to keep it that way, then setting keep_encoding
will use the<code>Expat</code> original_string method for character,
thus keeping the original encoding, as well as the original entities in
the strings. See the <code>t/test6.t</code> test file to see what
results you can expect from the various encoding options.
<strong>WARNING</strong>: if the original encoding is multi-byte then
attribute parsing will be EXTREMELY unsafe under any Perl before 5.6, as
it uses regular expressions which do not deal properly with multi-byte
characters. You can specify an alternate function to parse the start
tags with the <code>parse_start_tag</code> option (see below)
<strong>WARNING</strong>: this option is NOT used when parsing with
XML::Parser non-blocking parser (<code>parse_start</code>,
<code>parse_more</code>, <code>parse_done</code> methods) which you
probably should not use with XML::Twig anyway as they are totally
untested!</p>
</dd>
<dt>output_encoding</dt>
<dd>
<p>This option generates an output_filter using <code>Encode</code>,
<code>Text::Iconv</code> or <code>Unicode::Map8</code> and
<code>Unicode::Strings</code>, and sets the encoding in the XML
declaration. This is the easiest way to deal with encodings, if you need
more sophisticated features, look at <code>output_filter</code>
below</p>
</dd>
<dt>output_filter</dt>
<dd>
<p>This option is used to convert the character encoding of the output
document. It is passed either a string corresponding to a predefined
filter or a subroutine reference. The filter will be called every time a
document or element is processed by the print functions
(<code>print</code>, <code>sprint</code>, <code>flush</code>).
Pre-defined filters:</p>
<dl>
<dt>latin1</dt>
<dd>
<p>uses either <code>Encode</code>, <code>Text::Iconv</code> or
<code>Unicode::Map8</code> and <code>Unicode::String</code> or a regexp
(which works only with XML::Parser 2.27), in this order, to convert all
characters to ISO-8859-15 (usually latin1 is synonym to ISO-8859-1, but
in practice it seems that ISO-8859-15, which includes the euro sign, is
more useful and probably what most people want).</p>
</dd>
<dt>html</dt>
<dd>
<p>does the same conversion as <code>latin1</code>, plus encodes
entities using <code>HTML::Entities</code> (oddly enough you will need
to have HTML::Entities installed for it to be available). This should
only be used if the tags and attribute names themselves are in US-ASCII,
or they will be converted and the output will not be valid XML any
more</p>
</dd>
<dt>safe</dt>
<dd>
<p>converts the output to ASCII (US) only plus <em>character
entities</em> (<code>&amp;#nnn;</code>) this should be used only if the
tags and attribute names themselves are in US-ASCII, or they will be
converted and the output will not be valid XML any more</p>
</dd>
<dt>safe_hex</dt>
<dd>
<p>same as <code>safe</code> except that the character entities are in
hex (<code>&amp;#xnnn;</code>)</p>
</dd>
<dt>encode_convert ($encoding)</dt>
<dd>
<p>Return a subref that can be used to convert utf8 strings to
<code>$encoding</code>). Uses <code>Encode</code>. my $conv =
XML::Twig::encode_convert( latin1); my $t =
XML::Twig-&gt;new(output_filter =&gt; $conv);</p>
</dd>
<dt>iconv_convert ($encoding)</dt>
<dd>
<p>this function is used to create a filter subroutine that will be used
to convert the characters to the target encoding using
<code>Text::Iconv</code> (which needs to be installed, look at the
documentation for the module and for the <code>iconv</code> library to
find out which encodings are available on your system,
<code>iconv -l</code> should give you a list of available encodings) my
$conv = XML::Twig::iconv_convert( latin1); my $t =
XML::Twig-&gt;new(output_filter =&gt; $conv);</p>
</dd>
<dt>unicode_convert ($encoding)</dt>
<dd>
<p>this function is used to create a filter subroutine that will be used
to convert the characters to the target encoding using
<code>Unicode::Strings</code> and <code>Unicode::Map8</code> (which need
to be installed, look at the documentation for the modules to find out
which encodings are available on your system) my $conv =
XML::Twig::unicode_convert( latin1); my $t =
XML::Twig-&gt;new(output_filter =&gt; $conv);</p>
</dd>
</dl>
<p>The <code>text</code> and <code>att</code> methods do not use the
filter, so their result are always in unicode. Those predeclared filters
are based on subroutines that can be used by themselves (as
<code>XML::Twig::foo</code>).</p>
<dl>
<dt>html_encode ($string)</dt>
<dd>
<p>Use <code>HTML::Entities</code> to encode a utf8 string</p>
</dd>
<dt>safe_encode ($string)</dt>
<dd>
<p>Use either a regexp (perl &lt; 5.8) or <code>Encode</code> to encode
non-ascii characters in the string in <code>&amp;#&lt;nnnn&gt;;</code>
format</p>
</dd>
<dt>safe_encode_hex ($string)</dt>
<dd>
<p>Use either a regexp (perl &lt; 5.8) or <code>Encode</code> to encode
non-ascii characters in the string in <code>&amp;#x&lt;nnnn&gt;;</code>
format</p>
</dd>
<dt>regexp2latin1 ($string)</dt>
<dd>
<p>Use a regexp to encode a utf8 string into latin 1 (ISO-8859-1). Does
not work with Perl 5.8.0!</p>
</dd>
</dl>
</dd>
<dt>output_text_filter</dt>
<dd>
<p>same as output_filter, except it doesn't apply to the brackets and
quotes around attribute values. This is useful for all filters that
could change the tagging, basically anything that does not just change
the encoding of the output. <code>html</code>, <code>safe</code> and
<code>safe_hex</code> are better used with this option.</p>
</dd>
<dt>input_filter</dt>
<dd>
<p>This option is similar to <code>output_filter</code> except the
filter is applied to the characters before they are stored in the twig,
at parsing time.</p>
</dd>
<dt>remove_cdata</dt>
<dd>
<p>Setting this option to a true value will force the twig to output
CDATA sections as regular (escaped) PCDATA</p>
</dd>
<dt>parse_start_tag</dt>
<dd>
<p>If you use the <code>keep_encoding</code> option then this option can
be used to replace the default parsing function. You should provide a
coderef (a reference to a subroutine) as the argument, this subroutine
takes the original tag (given by XML::Parser::Expat
<code>original_string()</code> method) and returns a tag and the
attributes in a hash (or in a list attribute_name/attribute value).</p>
</dd>
<dt>no_xxe</dt>
<dd>
<p>prevents external entities to be parsed. This is a security feature,
in case the input XML cannot be trusted. With this option set to a true
value defining external entities in the document will cause the parse to
fail. This prevents an entity like
<code>&lt;!ENTITY xxe PUBLIC "bar" "/etc/passwd"&gt;</code> to make the
password fiel available in the document.</p>
</dd>
<dt>expand_external_ents</dt>
<dd>
<p>When this option is used external entities (that are defined) are
expanded when the document is output using print functions such as
<code>print </code>, <code>sprint </code>, <code>flush </code> and
<code>xml_string </code>. Note that in the twig the entity will be
stored as an element with a tag '<code>#ENT</code>', the entity will not
be expanded there, so you might want to process the entities before
outputting it. If an external entity is not available, then the parse
will fail. A special case is when the value of this option is -1. In
that case a missing entity will not cause the parser to die, but its
<code>name</code>, <code>sysid</code> and <code>pubid</code> will be
stored in the twig as
<code>$twig-&gt;{twig_missing_system_entities}</code> (a reference to an
array of hashes { name =&gt; &lt;name&gt;, sysid =&gt; &lt;sysid&gt;,
pubid =&gt; &lt;pubid&gt; }). Yes, this is a bit of a hack, but it's
useful in some cases. <strong>WARNING</strong>: setting
expand_external_ents to 0 or -1 currently doesn't work as expected; cf.
&lt;https://rt.cpan.org/Public/Bug/Display.html?id=118097&gt;. To
completelty turn off expanding external entities use
<code>no_xxe</code>.</p>
</dd>
<dt>no_xxe</dt>
<dd>
<p>If this argument is set to a true value, expanding of external
entities is turned off.</p>
</dd>
<dt>load_DTD</dt>
<dd>
<p>If this argument is set to a true value, <code>parse</code> or
<code>parsefile</code> on the twig will load the DTD information. This
information can then be accessed through the twig, in a
<code>DTD_handler</code> for example. This will load even an external
DTD. Default and fixed values for attributes will also be filled, based
on the DTD. Note that to do this the module will generate a temporary
file in the current directory. If this is a problem let me know and I
will add an option to specify an alternate directory. See DTD Handling
for more information</p>
</dd>
<dt>DTD_base &lt;path_to_DTD_directory&gt;</dt>
<dd>
<p>If the DTD is in a different directory, looks for it there, useful to
make up somewhat for the lack of catalog support in <code>expat</code>.
You still need a SYSTEM declaration</p>
</dd>
<dt>DTD_handler</dt>
<dd>
<p>Set a handler that will be called once the doctype (and the DTD) have
been loaded, with 2 arguments, the twig and the DTD.</p>
</dd>
<dt>no_prolog</dt>
<dd>
<p>Does not output a prolog (XML declaration and DTD)</p>
</dd>
<dt>id</dt>
<dd>
<p>This optional argument gives the name of an attribute that can be
used as an ID in the document. Elements whose ID is known can be
accessed through the elt_id method. id defaults to 'id'. See
<code>BUGS </code></p>
</dd>
<dt>discard_spaces</dt>
<dd>
<p>If this optional argument is set to a true value then spaces are
discarded when they look non-significant: strings containing only spaces
and at least one line feed are discarded. This argument is set to true
by default. The exact algorithm to drop spaces is: strings including
only spaces (perl \s) and at least one \n right before an open or close
tag are dropped.</p>
</dd>
<dt>discard_all_spaces</dt>
<dd>
<p>If this argument is set to a true value, spaces are discarded more
aggressively than with <code>discard_spaces</code>: strings not
including a \n are also dropped. This option is appropriate for
data-oriented XML.</p>
</dd>
<dt>keep_spaces</dt>
<dd>
<p>If this optional argument is set to a true value then all spaces in
the document are kept, and stored as <code>PCDATA</code>.
<strong>Warning</strong>: adding this option can result in changes in
the twig generated: space that was previously discarded might end up in
a new text element. see the difference by calling the following code
with 0 and 1 as arguments: perl -MXML::Twig -eprint XML::Twig-&gt;new(
keep_spaces =&gt; shift)-&gt;parse( "&lt;d&gt;
\n&lt;e/&gt;&lt;/d&gt;")-&gt;_dump <code>keep_spaces</code> and
<code>discard_spaces</code> cannot be both set.</p>
</dd>
<dt>discard_spaces_in</dt>
<dd>
<p>This argument sets <code>keep_spaces</code> to true but will cause
the twig builder to discard spaces in the elements listed. The syntax
for using this argument is: XML::Twig-&gt;new( discard_spaces_in =&gt; [
elt1, elt2]);</p>
</dd>
<dt>keep_spaces_in</dt>
<dd>
<p>This argument sets <code>discard_spaces</code> to true but will cause
the twig builder to keep spaces in the elements listed. The syntax for
using this argument is: XML::Twig-&gt;new( keep_spaces_in =&gt; [ elt1,
elt2]); <strong>Warning</strong>: adding this option can result in
changes in the twig generated: space that was previously discarded might
end up in a new text element.</p>
</dd>
<dt>pretty_print</dt>
<dd>
<p>Set the pretty print method, amongst '<code>none</code>' (default),
'<code>nsgmls</code>', '<code>nice</code>', '<code>indented</code>',
'<code>indented_c</code>', '<code>indented_a</code>',
'<code>indented_close_tag</code>', '<code>cvs</code>',
'<code>wrapped</code>', '<code>record</code>' and
'<code>record_c</code>' pretty_print formats:</p>
<dl>
<dt>none</dt>
<dd>
<p>The document is output as one ling string, with no line breaks except
those found within text elements</p>
</dd>
<dt>nsgmls</dt>
<dd>
<p>Line breaks are inserted in safe places: that is within tags, between
a tag and an attribute, between attributes and before the &gt; at the
end of a tag. This is quite ugly but better than <code>none</code>, and
it is very safe, the document will still be valid (conforming to its
DTD). This is how the SGML parser <code>sgmls</code> splits documents,
hence the name.</p>
</dd>
<dt>nice</dt>
<dd>
<p>This option inserts line breaks before any tag that does not contain
text (so element with textual content are not broken as the \n is the
significant). <strong>WARNING</strong>: this option leaves the document
well-formed but might make it invalid (not conformant to its DTD). If
you have elements declared as &lt;!ELEMENT foo (#PCDATA|bar)&gt; then a
<code>foo</code> element including a <code>bar</code> one will be
printed as &lt;foo&gt; &lt;bar&gt;bar is just pcdata&lt;/bar&gt;
&lt;/foo&gt; This is invalid, as the parser will take the line break
after the <code>foo</code> tag as a sign that the element contains
PCDATA, it will then die when it finds the <code>bar</code> tag. This
may or may not be important for you, but be aware of it!</p>
</dd>
<dt>indented</dt>
<dd>
<p>Same as <code>nice</code> (and with the same warning) but indents
elements according to their level</p>
</dd>
<dt>indented_c</dt>
<dd>
<p>Same as <code>indented</code> but a little more compact: the closing
tags are on the same line as the preceding text</p>
</dd>
<dt>indented_close_tag</dt>
<dd>
<p>Same as <code>indented</code> except that the closing tag is also
indented, to line up with the tags within the element</p>
</dd>
<dt>idented_a</dt>
<dd>
<p>This formats XML files in a line-oriented version control friendly
way. The format is described in &lt;http://tinyurl.com/2kwscq&gt;
(that's an Oracle document with an insanely long URL). Note that to be
totaly conformant to the spec, the order of attributes should not be
changed, so if they are not already in alphabetical order you will need
to use the <code>keep_atts_order</code> option.</p>
</dd>
<dt>cvs</dt>
<dd>
<p>Same as <code>idented_a</code>.</p>
</dd>
<dt>wrapped</dt>
<dd>
<p>Same as <code>indented_c</code> but lines are wrapped using
Text::Wrap::wrap. The default length for lines is the default for
<code>$Text::Wrap::columns</code>, and can be changed by changing that
variable.</p>
</dd>
<dt>record</dt>
<dd>
<p>This is a record-oriented pretty print, that display data in records,
one field per line (which looks a LOT like <code>indented</code>)</p>
</dd>
<dt>record_c</dt>
<dd>
<p>Stands for record compact, one record per line</p>
</dd>
</dl>
</dd>
<dt>empty_tags</dt>
<dd>
<p>Set the empty tag display style ('<code>normal</code>',
'<code>html</code>' or '<code>expand</code>'). <code>normal</code>
outputs an empty tag '<code>&lt;tag/&gt;</code>', <code>html</code> adds
a space '<code>&lt;tag /&gt;</code>' for elements that can be empty in
XHTML and <code>expand</code> outputs
'<code>&lt;tag&gt;&lt;/tag&gt;</code>'</p>
</dd>
<dt>quote</dt>
<dd>
<p>Set the quote character for attributes ('<code>single</code>' or
'<code>double</code>').</p>
</dd>
<dt>escape_gt</dt>
<dd>
<p>By default XML::Twig does not escape the character &gt; in its
output, as it is not mandated by the XML spec. With this option on, &gt;
will be replaced by <code>&amp;gt;</code></p>
</dd>
<dt>comments</dt>
<dd>
<p>Set the way comments are processed: '<code>drop</code>' (default),
'<code>keep</code>' or '<code>process</code>' Comments processing
options:</p>
<dl>
<dt>drop</dt>
<dd>
<p>drops the comments, they are not read, nor printed to the output</p>
</dd>
<dt>keep</dt>
<dd>
<p>comments are loaded and will appear on the output, they are not
accessible within the twig and will not interfere with processing though
<strong>Note</strong>: comments in the middle of a text element such as
&lt;p&gt;text &lt;!-- comment --&gt; more text --&gt;&lt;/p&gt; are kept
at their original position in the text. Using print methods like
<code>print</code> or <code>sprint</code> will return the comments in
the text. Using <code>text</code> or <code>field</code> on the other
hand will not. Any use of <code>set_pcdata</code> on the
<code>#PCDATA</code> element (directly or through other methods like
<code>set_content</code>) will delete the comment(s).</p>
</dd>
<dt>process</dt>
<dd>
<p>comments are loaded in the twig and will be treated as regular
elements (their <code>tag</code> is <code>#COMMENT</code>) this can
interfere with processing if you expect
<code>$elt-&gt;{first_child}</code> to be an element but find a comment
there. Validation will not protect you from this as comments can happen
anywhere. You can use <code>$elt-&gt;first_child( tag)</code> (which is
a good habit anyway) to get where you want. Consider using
<code>process</code> if you are outputting SAX events from
XML::Twig.</p>
</dd>
</dl>
</dd>
<dt>pi</dt>
<dd>
<p>Set the way processing instructions are processed:
'<code>drop</code>', '<code>keep</code>' (default) or
'<code>process</code>' Note that you can also set PI handlers in the
<code>twig_handlers</code> option: ? =&gt; \&amp;handler ?target =&gt;
\&amp;handler 2 The handlers will be called with 2 parameters, the twig
and the PI element if <code>pi</code> is set to <code>process</code>,
and with 3, the twig, the target and the data if <code>pi</code> is set
to <code>keep</code>. Of course they will not be called if
<code>pi</code> is set to <code>drop</code>. If <code>pi</code> is set
to <code>keep</code> the handler should return a string that will be
used as-is as the PI text (it should look like
"<code> &lt;?target data?</code> &gt;" or '' if you want to remove the
PI), Only one handler will be called, <code>?target</code> or
<code>?</code> if no specific handler for that target is available.</p>
</dd>
<dt>map_xmlns</dt>
<dd>
<p>This option is passed a hashref that maps uri's to prefixes. The
prefixes in the document will be replaced by the ones in the map. The
mapped prefixes can (actually have to) be used to trigger handlers,
navigate or query the document. Here is an example: my $t=
XML::Twig-&gt;new( map_xmlns =&gt; {http://www.w3.org/2000/svg =&gt;
"svg"}, twig_handlers =&gt; { svg:circle =&gt; sub { $_-&gt;set_att( r
=&gt; 20) } }, pretty_print =&gt; indented, ) -&gt;parse( &lt;doc
xmlns:gr="http://www.w3.org/2000/svg"&gt; &lt;gr:circle cx="10" cy="90"
r="10"/&gt; &lt;/doc&gt; ) -&gt;print; This will output: &lt;doc
xmlns:svg="http://www.w3.org/2000/svg"&gt; &lt;svg:circle cx="10"
cy="90" r="20"/&gt; &lt;/doc&gt;</p>
</dd>
<dt>keep_original_prefix</dt>
<dd>
<p>When used with <code>map_xmlns</code> this option will make
<code>XML::Twig</code> use the original namespace prefixes when
outputting a document. The mapped prefix will still be used for
triggering handlers and in navigation and query methods. my $t=
XML::Twig-&gt;new( map_xmlns =&gt; {http://www.w3.org/2000/svg =&gt;
"svg"}, twig_handlers =&gt; { svg:circle =&gt; sub { $_-&gt;set_att( r
=&gt; 20) } }, keep_original_prefix =&gt; 1, pretty_print =&gt;
indented, ) -&gt;parse( &lt;doc
xmlns:gr="http://www.w3.org/2000/svg"&gt; &lt;gr:circle cx="10" cy="90"
r="10"/&gt; &lt;/doc&gt; ) -&gt;print; This will output: &lt;doc
xmlns:gr="http://www.w3.org/2000/svg"&gt; &lt;gr:circle cx="10" cy="90"
r="20"/&gt; &lt;/doc&gt;</p>
</dd>
<dt>original_uri ($prefix)</dt>
<dd>
<p>called within a handler, this will return the uri bound to the
namespace prefix in the original document.</p>
</dd>
<dt>index ($arrayref or $hashref)</dt>
<dd>
<p>This option creates lists of specific elements during the parsing of
the XML. It takes a reference to either a list of triggering expressions
or to a hash name =&gt; expression, and for each one generates the list
of elements that match the expression. The list can be accessed through
the <code>index</code> method. example: # using an array ref my $t=
XML::Twig-&gt;new( index =&gt; [ div, table ]) -&gt;parsefile(
"foo.xml"); my $divs= $t-&gt;index( div); my $first_div= $divs-&gt;[0];
my $last_table= $t-&gt;index( table =&gt; -1); # using a hashref to name
the indexes my $t= XML::Twig-&gt;new( index =&gt; { email =&gt;
a[@href=~/^ \s*mailto:/]}) -&gt;parsefile( "foo.xml"); my $last_emails=
$t-&gt;index( email =&gt; -1); Note that the index is not maintained
after the parsing. If elements are deleted, renamed or otherwise hurt
during processing, the index is NOT updated. (changing the id element
OTOH will update the index)</p>
</dd>
<dt>att_accessors &lt;list of attribute names&gt;</dt>
<dd>
<p>creates methods that give direct access to attribute: my $t=
XML::Twig-&gt;new( att_accessors =&gt; [ href, src]) -&gt;parsefile(
$file); my $first_href= $t-&gt;first_elt( img)-&gt;src; # same as
-&gt;att( src) $t-&gt;first_elt( img)-&gt;src( new_logo.png) # changes
the attribute value</p>
</dd>
<dt>elt_accessors</dt>
<dd>
<p>creates methods that give direct access to the first child element
(in scalar context) or the list of elements (in list context): the list
of accessors to create can be given 1 2 different ways: in an array, or
in a hash alias =&gt; expression my <code>$t</code>= XML::Twig-&gt;new(
elt_accessors =&gt; [ 'head']) -&gt;parsefile( <code>$file</code>); my
<code>$title_text</code>= <code>$t</code>-&gt;root-&gt;head-&gt;field(
'title'); # same as <code>$title_text</code>=
<code>$t</code>-&gt;root-&gt;first_child( 'head')-&gt;field( 'title');
my $t= XML::Twig-&gt;new( elt_accessors =&gt; { warnings =&gt;
p[@class="warning"], d2 =&gt; div[2]}, ) -&gt;parsefile( $file); my
$body= $t-&gt;first_elt( body); my @warnings= $body-&gt;warnings; # same
as $body-&gt;children( p[@class="warning"]); my $s2= $body-&gt;d2; #
same as $body-&gt;first_child( div[2])</p>
</dd>
<dt>field_accessors</dt>
<dd>
<p>creates methods that give direct access to the first child element
text: my $t= XML::Twig-&gt;new( field_accessors =&gt; [ h1])
-&gt;parsefile( $file); my $div_title_text= $t-&gt;first_elt(
div)-&gt;title; # same as $title_text= $t-&gt;first_elt( div)-&gt;field(
title);</p>
</dd>
<dt>use_tidy</dt>
<dd>
<p>set this option to use HTML::Tidy instead of HTML::TreeBuilder to
convert HTML to XML. HTML, especially real (real crap) HTML found in the
wild, so depending on the data, one module or the other does a better
job at the conversion. Also, HTML::Tidy can be a bit difficult to
install, so XML::Twig offers both option. TIMTOWTDI</p>
</dd>
<dt>output_html_doctype</dt>
<dd>
<p>when using HTML::TreeBuilder to convert HTML, this option causes the
DOCTYPE declaration to be output, which may be important for some legacy
browsers. Without that option the DOCTYPE definition is NOT output. Also
if the definition is completely wrong (ie not easily parsable), it is
not output either.</p>
</dd>
</dl>
<p><strong>Note</strong>: I _HATE_ the Java-like name of arguments used
by most XML modules. So in pure TIMTOWTDI fashion all arguments can be
written either as <code>UglyJavaLikeName</code> or as
<code>readable_perl_name</code>: <code>twig_print_outside_roots</code>
or <code>TwigPrintOutsideRoots</code> (or even
<code>twigPrintOutsideRoots</code> {shudder}). XML::Twig normalizes them
before processing them.</p>
</dd>
<dt>parse ( $source)</dt>
<dd>
<p>The <code>$source</code> parameter should either be a string
containing the whole XML document, or it should be an open
<code>IO::Handle</code> (aka a filehandle). A die call is thrown if a
parse error occurs. Otherwise it will return the twig built by the
parse. Use <code>safe_parse</code> if you want the parsing to return
even when an error occurs. If this method is called as a class method
(<code>XML::Twig-&gt;parse( $some_xml_or_html)</code>) then an XML::Twig
object is created, using the parameters except the last one (eg
<code>XML::Twig-&gt;parse( pretty_print =&gt; indented, $some_xml_or_html)</code>)
and <code>xparse</code> is called on it. Note that when parsing a
filehandle, the handle should NOT be open with an encoding (ie open with
<code>open( my $in, &lt;, $filename)</code>. The file will be parsed by
<code>expat</code>, so specifying the encoding actually causes problems
for the parser (as in: it can crash it, see
https://rt.cpan.org/Ticket/Display.html?id=78877). For parsing a file it
is actually recommended to use <code>parsefile</code> on the file name,
instead of &lt;parse&gt; on the open file.</p>
</dd>
<dt>parsestring</dt>
<dd>
<p>This is just an alias for <code>parse</code> for backwards
compatibility.</p>
</dd>
<dt>parsefile (FILE [, OPT =&gt; OPT_VALUE [...]])</dt>
<dd>
<p>Open <code>FILE</code> for reading, then call <code>parse</code> with
the open handle. The file is closed no matter how <code>parse</code>
returns. A <code>die</code> call is thrown if a parse error occurs.
Otherwise it will return the twig built by the parse. Use
<code>safe_parsefile</code> if you want the parsing to return even when
an error occurs.</p>
</dd>
<dt>parsefile_inplace ( $file, $optional_extension)</dt>
<dd>
<p>Parse and update a file in place. It does this by creating a temp
file, selecting it as the default for <strong>print()</strong>
statements (and methods), then parsing the input file. If the parsing is
successful, then the temp file is moved to replace the input file. If an
extension is given then the original file is backed-up (the rules for
the extension are the same as the rule for the -i option in perl).</p>
</dd>
<dt>parsefile_html_inplace ( $file, $optional_extension)</dt>
<dd>
<p>Same as parsefile_inplace, except that it parses HTML instead of
XML</p>
</dd>
<dt>parseurl ($url $optional_user_agent)</dt>
<dd>
<p>Gets the data from <code>$url</code> and parse it. The data is piped
to the parser in chunks the size of the XML::Parser::Expat buffer, so
memory consumption and hopefully speed are optimal. For most (read
small) XML it is probably as efficient (and easier to debug) to just
<code>get</code> the XML file and then parse it as a string. use
XML::Twig; use LWP::Simple; my $twig= XML::Twig-&gt;new();
$twig-&gt;parse( LWP::Simple::get( $URL )); or use XML::Twig; my $twig=
XML::Twig-&gt;nparse( $URL); If the <code>$optional_user_agent</code>
argument is used then it is used, otherwise a new one is created.</p>
</dd>
<dt>safe_parse ( SOURCE [, OPT =&gt; OPT_VALUE [...]])</dt>
<dd>
<p>This method is similar to <code>parse</code> except that it wraps the
parsing in an <code>eval</code> block. It returns the twig on success
and 0 on failure (the twig object also contains the parsed twig).
<code>$@</code> contains the error message on failure. Note that the
parsing still stops as soon as an error is detected, there is no way to
keep going after an error.</p>
</dd>
<dt>safe_parsefile (FILE [, OPT =&gt; OPT_VALUE [...]])</dt>
<dd>
<p>This method is similar to <code>parsefile</code> except that it wraps
the parsing in an <code>eval</code> block. It returns the twig on
success and 0 on failure (the twig object also contains the parsed twig)
. <code>$@</code> contains the error message on failure Note that the
parsing still stops as soon as an error is detected, there is no way to
keep going after an error.</p>
</dd>
<dt>safe_parseurl ($url $optional_user_agent)</dt>
<dd>
<p>Same as <code>parseurl</code> except that it wraps the parsing in an
<code>eval</code> block. It returns the twig on success and 0 on failure
(the twig object also contains the parsed twig) . <code>$@</code>
contains the error message on failure</p>
</dd>
<dt>parse_html ($string_or_fh)</dt>
<dd>
<p>parse an HTML string or file handle (by converting it to XML using
HTML::TreeBuilder, which needs to be available). This works nicely, but
some information gets lost in the process: newlines are removed, and (at
least on the version I use), comments get an extra CDATA section inside
( &lt;!-- foo --&gt; becomes &lt;!-- &lt;![CDATA[ foo ]]&gt; --&gt;</p>
</dd>
<dt>parsefile_html ($file)</dt>
<dd>
<p>parse an HTML file (by converting it to XML using HTML::TreeBuilder,
which needs to be available, or HTML::Tidy if the <code>use_tidy</code>
option was used). The file is loaded completely in memory and converted
to XML before being parsed. this method is to be used with caution
though, as it doesn't know about the file encoding, it is usually better
to use <code>parse_html</code>, which gives you a chance to open the
file with the proper encoding layer.</p>
</dd>
<dt>parseurl_html ($url $optional_user_agent)</dt>
<dd>
<p>parse an URL as html the same way <code>parse_html</code> does</p>
</dd>
<dt>safe_parseurl_html ($url $optional_user_agent)</dt>
<dd>
<p>Same as <code>parseurl_html</code>&gt; except that it wraps the
parsing in an <code>eval</code> block. It returns the twig on success
and 0 on failure (the twig object also contains the parsed twig) .
<code>$@</code> contains the error message on failure</p>
</dd>
<dt>safe_parsefile_html ($file $optional_user_agent)</dt>
<dd>
<p>Same as <code>parsefile_html</code>&gt; except that it wraps the
parsing in an <code>eval</code> block. It returns the twig on success
and 0 on failure (the twig object also contains the parsed twig) .
<code>$@</code> contains the error message on failure</p>
</dd>
<dt>safe_parse_html ($string_or_fh)</dt>
<dd>
<p>Same as <code>parse_html</code> except that it wraps the parsing in
an <code>eval</code> block. It returns the twig on success and 0 on
failure (the twig object also contains the parsed twig) .
<code>$@</code> contains the error message on failure</p>
</dd>
<dt>xparse ($thing_to_parse)</dt>
<dd>
<p>parse the <code>$thing_to_parse</code>, whether it is a filehandle, a
string, an HTML file, an HTML URL, an URL or a file. Note that this is
mostly a convenience method for one-off scripts. For example files that
end in '.htm' or '.html' are parsed first as XML, and if this fails as
HTML. This is certainly not the most efficient way to do this in
general.</p>
</dd>
<dt>nparse ($optional_twig_options, $thing_to_parse)</dt>
<dd>
<p>create a twig with the <code>$optional_options</code>, and parse the
<code>$thing_to_parse</code>, whether it is a filehandle, a string, an
HTML file, an HTML URL, an URL or a file. Examples:
XML::Twig-&gt;nparse( "file.xml"); XML::Twig-&gt;nparse( error_context
=&gt; 1, "file://file.xml");</p>
</dd>
<dt>nparse_pp ($optional_twig_options, $thing_to_parse)</dt>
<dd>
<p>same as <code>nparse</code> but also sets the
<code>pretty_print</code> option to <code>indented</code>.</p>
</dd>
<dt>nparse_e ($optional_twig_options, $thing_to_parse)</dt>
<dd>
<p>same as <code>nparse</code> but also sets the
<code>error_context</code> option to 1.</p>
</dd>
<dt>nparse_ppe ($optional_twig_options, $thing_to_parse)</dt>
<dd>
<p>same as <code>nparse</code> but also sets the
<code>pretty_print</code> option to <code>indented</code> and the
<code>error_context</code> option to 1.</p>
</dd>
<dt>parser</dt>
<dd>
<p>This method returns the <code>expat</code> object (actually the
XML::Parser::Expat object) used during parsing. It is useful for example
to call XML::Parser::Expat methods on it. To get the line of a tag for
example use <code>$t-&gt;parser-&gt;current_line</code>.</p>
</dd>
<dt>setTwigHandlers ($handlers)</dt>
<dd>
<p>Set the twig_handlers. <code>$handlers</code> is a reference to a
hash similar to the one in the <code>twig_handlers</code> option of new.
All previous handlers are unset. The method returns the reference to the
previous handlers.</p>
</dd>
<dt>setTwigHandler ($exp $handler)</dt>
<dd>
<p>Set a single twig_handler for elements matching <code>$exp</code>.
<code>$handler</code> is a reference to a subroutine. If the handler was
previously set then the reference to the previous handler is
returned.</p>
</dd>
<dt>setStartTagHandlers ($handlers)</dt>
<dd>
<p>Set the start_tag handlers. <code>$handlers</code> is a reference to
a hash similar to the one in the <code>start_tag_handlers</code> option
of new. All previous handlers are unset. The method returns the
reference to the previous handlers.</p>
</dd>
<dt>setStartTagHandler ($exp $handler)</dt>
<dd>
<p>Set a single start_tag handlers for elements matching
<code>$exp</code>. <code>$handler</code> is a reference to a subroutine.
If the handler was previously set then the reference to the previous
handler is returned.</p>
</dd>
<dt>setEndTagHandlers ($handlers)</dt>
<dd>
<p>Set the end_tag handlers. <code>$handlers</code> is a reference to a
hash similar to the one in the <code>end_tag_handlers</code> option of
new. All previous handlers are unset. The method returns the reference
to the previous handlers.</p>
</dd>
<dt>setEndTagHandler ($exp $handler)</dt>
<dd>
<p>Set a single end_tag handlers for elements matching
<code>$exp</code>. <code>$handler</code> is a reference to a subroutine.
If the handler was previously set then the reference to the previous
handler is returned.</p>
</dd>
<dt>setTwigRoots ($handlers)</dt>
<dd>
<p>Same as using the <code>twig_roots</code> option when creating the
twig</p>
</dd>
<dt>setCharHandler ($exp $handler)</dt>
<dd>
<p>Set a <code>char_handler</code></p>
</dd>
<dt>setIgnoreEltsHandler ($exp)</dt>
<dd>
<p>Set a <code>ignore_elt</code> handler (elements that match
<code>$exp</code> will be ignored</p>
</dd>
<dt>setIgnoreEltsHandlers ($exp)</dt>
<dd>
<p>Set all <code>ignore_elt</code> handlers (previous handlers are
replaced)</p>
</dd>
<dt>dtd</dt>
<dd>
<p>Return the dtd (an XML::Twig::DTD object) of a twig</p>
</dd>
<dt>xmldecl</dt>
<dd>
<p>Return the XML declaration for the document, or a default one if it
doesn't have one</p>
</dd>
<dt>doctype</dt>
<dd>
<p>Return the doctype for the document</p>
</dd>
<dt>doctype_name</dt>
<dd>
<p>returns the doctype of the document from the doctype declaration</p>
</dd>
<dt>system_id</dt>
<dd>
<p>returns the system value of the DTD of the document from the doctype
declaration</p>
</dd>
<dt>public_id</dt>
<dd>
<p>returns the public doctype of the document from the doctype
declaration</p>
</dd>
<dt>internal_subset</dt>
<dd>
<p>returns the internal subset of the DTD</p>
</dd>
<dt>dtd_text</dt>
<dd>
<p>Return the DTD text</p>
</dd>
<dt>dtd_print</dt>
<dd>
<p>Print the DTD</p>
</dd>
<dt>model ($tag)</dt>
<dd>
<p>Return the model (in the DTD) for the element <code>$tag</code></p>
</dd>
<dt>root</dt>
<dd>
<p>Return the root element of a twig</p>
</dd>
<dt>set_root ($elt)</dt>
<dd>
<p>Set the root of a twig</p>
</dd>
<dt>first_elt ($optional_condition)</dt>
<dd>
<p>Return the first element matching <code>$optional_condition</code> of
a twig, if no condition is given then the root is returned</p>
</dd>
<dt>last_elt ($optional_condition)</dt>
<dd>
<p>Return the last element matching <code>$optional_condition</code> of
a twig, if no condition is given then the last element of the twig is
returned</p>
</dd>
<dt>elt_id ($id)</dt>
<dd>
<p>Return the element whose <code>id</code> attribute is
<code>$id</code></p>
</dd>
<dt>getEltById</dt>
<dd>
<p>Same as <code>elt_id</code></p>
</dd>
<dt>index ($index_name, $optional_index)</dt>
<dd>
<p>If the <code>$optional_index</code> argument is present, return the
corresponding element in the index (created using the <code>index</code>
option for <code>XML::Twig-</code>new&gt;) If the argument is not
present, return an arrayref to the index</p>
</dd>
<dt>normalize</dt>
<dd>
<p>merge together all consecutive pcdata elements in the document (if
for example you have turned some elements into pcdata using
<code>erase</code>, this will give you a clean document in which there
all text elements are as long as possible).</p>
</dd>
<dt>encoding</dt>
<dd>
<p>This method returns the encoding of the XML document, as defined by
the <code>encoding</code> attribute in the XML declaration (ie it is
<code>undef</code> if the attribute is not defined)</p>
</dd>
<dt>set_encoding</dt>
<dd>
<p>This method sets the value of the <code>encoding</code> attribute in
the XML declaration. Note that if the document did not have a
declaration it is generated (with an XML version of 1.0)</p>
</dd>
<dt>xml_version</dt>
<dd>
<p>This method returns the XML version, as defined by the
<code>version</code> attribute in the XML declaration (ie it is
<code>undef</code> if the attribute is not defined)</p>
</dd>
<dt>set_xml_version</dt>
<dd>
<p>This method sets the value of the <code>version</code> attribute in
the XML declaration. If the declaration did not exist it is created.</p>
</dd>
<dt>standalone</dt>
<dd>
<p>This method returns the value of the <code>standalone</code>
declaration for the document</p>
</dd>
<dt>set_standalone</dt>
<dd>
<p>This method sets the value of the <code>standalone</code> attribute
in the XML declaration. Note that if the document did not have a
declaration it is generated (with an XML version of 1.0)</p>
</dd>
<dt>set_output_encoding</dt>
<dd>
<p>Set the <code>encoding</code> attribute in the XML declaration</p>
</dd>
<dt>set_doctype ($name, $system, $public, $internal)</dt>
<dd>
<p>Set the doctype of the element. If an argument is <code>undef</code>
(or not present) then its former value is retained, if a false ('' or 0)
value is passed then the former value is deleted;</p>
</dd>
<dt>entity_list</dt>
<dd>
<p>Return the entity list of a twig</p>
</dd>
<dt>entity_names</dt>
<dd>
<p>Return the list of all defined entities</p>
</dd>
<dt>entity ($entity_name)</dt>
<dd>
<p>Return the entity</p>
</dd>
<dt>notation_list</dt>
<dd>
<p>Return the notation list of a twig</p>
</dd>
<dt>notation_names</dt>
<dd>
<p>Return the list of all defined notations</p>
</dd>
<dt>notation ($notation_name)</dt>
<dd>
<p>Return the notation</p>
</dd>
<dt>change_gi ($old_gi, $new_gi)</dt>
<dd>
<p>Performs a (very fast) global change. All elements
<code>$old_gi</code> are now <code>$new_gi</code>. This is a bit
dangerous though and should be avoided if &lt; possible, as the new tag
might be ignored in subsequent processing. See <code>BUGS </code></p>
</dd>
<dt>flush ($optional_filehandle, %options)</dt>
<dd>
<p>Flushes a twig up to (and including) the current element, then
deletes all unnecessary elements from the tree that's kept in memory.
<code>flush</code> keeps track of which elements need to be open/closed,
so if you flush from handlers you don't have to worry about anything.
Just keep flushing the twig every time you're done with a sub-tree and
it will come out well-formed. After the whole parsing don't forget
to<code>flush</code> one more time to print the end of the document. The
doctype and entity declarations are also printed. flush take an optional
filehandle as an argument. If you use <code>flush</code> at any point
during parsing, the document will be flushed one last time at the end of
the parsing, to the proper filehandle. options: use the
<code>update_DTD</code> option if you have updated the (internal) DTD
and/or the entity list and you want the updated DTD to be output The
<code>pretty_print</code> option sets the pretty printing of the
document. Example: $t-&gt;flush( Update_DTD =&gt; 1); $t-&gt;flush(
$filehandle, pretty_print =&gt; indented); $t-&gt;flush( \*FILE);</p>
</dd>
<dt>flush_up_to ($elt, $optional_filehandle, %options)</dt>
<dd>
<p>Flushes up to the <code>$elt</code> element. This allows you to keep
part of the tree in memory when you <code>flush</code>. options: see
flush.</p>
</dd>
<dt>purge</dt>
<dd>
<p>Does the same as a <code>flush</code> except it does not print the
twig. It just deletes all elements that have been completely parsed so
far.</p>
</dd>
<dt>purge_up_to ($elt)</dt>
<dd>
<p>Purges up to the <code>$elt</code> element. This allows you to keep
part of the tree in memory when you <code>purge</code>.</p>
</dd>
<dt>print ($optional_filehandle, %options)</dt>
<dd>
<p>Prints the whole document associated with the twig. To be used only
AFTER the parse. options: see <code>flush</code>.</p>
</dd>
<dt>print_to_file ($filename, %options)</dt>
<dd>
<p>Prints the whole document associated with the twig to file
<code>$filename</code>. To be used only AFTER the parse. options: see
<code>flush</code>.</p>
</dd>
<dt>safe_print_to_file ($filename, %options)</dt>
<dd>
<p>Prints the whole document associated with the twig to file
<code>$filename</code>. This variant, which probably only works on *nix
prints to a temp file, then move the temp file to overwrite the original
file. This is a bit safer when 2 processes an potentiallywrite the same
file: only the last one will succeed, but the file won't be corruted. I
often use this for cron jobs, so testing the code doesn't interfere with
the cron job running at the same time. options: see
<code>flush</code>.</p>
</dd>
<dt>sprint</dt>
<dd>
<p>Return the text of the whole document associated with the twig. To be
used only AFTER the parse. options: see <code>flush</code>.</p>
</dd>
<dt>trim</dt>
<dd>
<p>Trim the document: gets rid of initial and trailing spaces, and
replaces multiple spaces by a single one.</p>
</dd>
<dt>toSAX1 ($handler)</dt>
<dd>
<p>Send SAX events for the twig to the SAX1 handler
<code>$handler</code></p>
</dd>
<dt>toSAX2 ($handler)</dt>
<dd>
<p>Send SAX events for the twig to the SAX2 handler
<code>$handler</code></p>
</dd>
<dt>flush_toSAX1 ($handler)</dt>
<dd>
<p>Same as flush, except that SAX events are sent to the SAX1 handler
<code>$handler</code> instead of the twig being printed</p>
</dd>
<dt>flush_toSAX2 ($handler)</dt>
<dd>
<p>Same as flush, except that SAX events are sent to the SAX2 handler
<code>$handler</code> instead of the twig being printed</p>
</dd>
<dt>ignore</dt>
<dd>
<p>This method should be called during parsing, usually in
<code>start_tag_handlers</code>. It causes the element to be skipped
during the parsing: the twig is not built for this element, it will not
be accessible during parsing or after it. The element will not take up
any memory and parsing will be faster. Note that this method can also be
called on an element. If the element is a parent of the current element
then this element will be ignored (the twig will not be built any more
for it and what has already been built will be deleted).</p>
</dd>
<dt>set_pretty_print ($style)</dt>
<dd>
<p>Set the pretty print method, amongst '<code>none</code>' (default),
'<code>nsgmls</code>', '<code>nice</code>', '<code>indented</code>',
<code>indented_c</code>, '<code>wrapped</code>', '<code>record</code>'
and '<code>record_c</code>' <strong>WARNING:</strong> the pretty print
style is a <strong>GLOBAL</strong> variable, so once set it's applied to
<strong>ALL</strong> <code>print</code>'s (and <code>sprint</code>'s).
Same goes if you use XML::Twig with <code>mod_perl</code> . This should
not be a problem as the XML that's generated is valid anyway, and XML
processors (as well as HTML processors, including browsers) should not
care. Let me know if this is a big problem, but at the moment the
performance/cleanliness trade-off clearly favors the global
approach.</p>
</dd>
<dt>set_empty_tag_style ($style)</dt>
<dd>
<p>Set the empty tag display style ('<code>normal</code>',
'<code>html</code>' or '<code>expand</code>'). As with
<code>set_pretty_print</code> this sets a global flag.
<code>normal</code> outputs an empty tag '<code>&lt;tag/&gt;</code>',
<code>html</code> adds a space '<code>&lt;tag /&gt;</code>' for elements
that can be empty in XHTML and <code>expand</code> outputs
'<code>&lt;tag&gt;&lt;/tag&gt;</code>'</p>
</dd>
<dt>set_remove_cdata ($flag)</dt>
<dd>
<p>set (or unset) the flag that forces the twig to output CDATA sections
as regular (escaped) PCDATA</p>
</dd>
<dt>print_prolog ($optional_filehandle, %options)</dt>
<dd>
<p>Prints the prolog (XML declaration + DTD + entity declarations) of a
document. options: see <code>flush</code>.</p>
</dd>
<dt>prolog ($optional_filehandle, %options)</dt>
<dd>
<p>Return the prolog (XML declaration + DTD + entity declarations) of a
document. options: see <code>flush</code>.</p>
</dd>
<dt>finish</dt>
<dd>
<p>Call Expat <code>finish</code> method. Unsets all handlers (including
internal ones that set context), but expat continues parsing to the end
of the document or until it finds an error. It should finish up a lot
faster than with the handlers set.</p>
</dd>
<dt>finish_print</dt>
<dd>
<p>Stops twig processing, flush the twig and proceed to finish printing
the document as fast as possible. Use this method when modifying a
document and the modification is done.</p>
</dd>
<dt>finish_now</dt>
<dd>
<p>Stops twig processing, does not finish parsing the document (which
could actually be not well-formed after the point where
<code>finish_now</code> is called). Execution resumes after the
<code>Lparse</code>&gt; or <code>parsefile</code> call. The content of
the twig is what has been parsed so far (all open elements at the time
<code>finish_now</code> is called are considered closed).</p>
</dd>
<dt>set_expand_external_entities</dt>
<dd>
<p>Same as using the <code>expand_external_ents</code> option when
creating the twig</p>
</dd>
<dt>set_input_filter</dt>
<dd>
<p>Same as using the <code>input_filter</code> option when creating the
twig</p>
</dd>
<dt>set_keep_atts_order</dt>
<dd>
<p>Same as using the <code>keep_atts_order</code> option when creating
the twig</p>
</dd>
<dt>set_keep_encoding</dt>
<dd>
<p>Same as using the <code>keep_encoding</code> option when creating the
twig</p>
</dd>
<dt>escape_gt</dt>
<dd>
<p>usually XML::Twig does not escape &gt; in its output. Using this
option makes it replace &gt; by &amp;gt;</p>
</dd>
<dt>do_not_escape_gt</dt>
<dd>
<p>reverts XML::Twig behavior to its default of not escaping &gt; in its
output.</p>
</dd>
<dt>set_output_filter</dt>
<dd>
<p>Same as using the <code>output_filter</code> option when creating the
twig</p>
</dd>
<dt>set_output_text_filter</dt>
<dd>
<p>Same as using the <code>output_text_filter</code> option when
creating the twig</p>
</dd>
<dt>add_stylesheet ($type, @options)</dt>
<dd>
<p>Adds an external stylesheet to an XML document. Supported types and
options:</p>
<dl>
<dt>xsl</dt>
<dd>
<p>option: the url of the stylesheet Example: $t-&gt;add_stylesheet( xsl
=&gt; "xsl_style.xsl"); will generate the following PI at the beginning
of the document: &lt;?xml-stylesheet type="text/xsl"
href="xsl_style.xsl"?&gt;</p>
</dd>
<dt>css</dt>
<dd>
<p>option: the url of the stylesheet</p>
</dd>
<dt>active_twig</dt>
<dd>
<p>a class method that returns the last processed twig, so you don't
necessarily need the object to call methods on it.</p>
</dd>
</dl>
</dd>
<dt>Methods inherited from XML::Parser::Expat</dt>
<dd>
<p>A twig inherits all the relevant methods from XML::Parser::Expat.
These methods can only be used during the parsing phase (they will
generate a fatal error otherwise). Inherited methods are:</p>
<dl>
<dt>depth</dt>
<dd>
<p>Returns the size of the context list.</p>
</dd>
<dt>in_element</dt>
<dd>
<p>Returns true if NAME is equal to the name of the innermost currently
opened element. If namespace processing is being used and you want to
check against a name that may be in a namespace, then use the
generate_ns_name method to create the NAME argument.</p>
</dd>
<dt>within_element</dt>
<dd>
<p>Returns the number of times the given name appears in the context
list. If namespace processing is being used and you want to check
against a name that may be in a namespace, then use the generate_ns_name
method to create the NAME argument.</p>
</dd>
<dt>context</dt>
<dd>
<p>Returns a list of element names that represent open elements, with
the last one being the innermost. Inside start and end tag handlers,
this will be the tag of the parent element.</p>
</dd>
<dt>current_line</dt>
<dd>
<p>Returns the line number of the current position of the parse.</p>
</dd>
<dt>current_column</dt>
<dd>
<p>Returns the column number of the current position of the parse.</p>
</dd>
<dt>current_byte</dt>
<dd>
<p>Returns the current position of the parse.</p>
</dd>
<dt>position_in_context</dt>
<dd>
<p>Returns a string that shows the current parse position. LINES should
be an integer &gt;= 0 that represents the number of lines on either side
of the current parse line to place into the returned string.</p>
</dd>
<dt>base ([NEWBASE])</dt>
<dd>
<p>Returns the current value of the base for resolving relative URIs. If
NEWBASE is supplied, changes the base to that value.</p>
</dd>
<dt>current_element</dt>
<dd>
<p>Returns the name of the innermost currently opened element. Inside
start or end handlers, returns the parent of the element associated with
those tags.</p>
</dd>
<dt>element_index</dt>
<dd>
<p>Returns an integer that is the depth-first visit order of the current
element. This will be zero outside of the root element. For example,
this will return 1 when called from the start handler for the root
element start tag.</p>
</dd>
<dt>recognized_string</dt>
<dd>
<p>Returns the string from the document that was recognized in order to
call the current handler. For instance, when called from a start
handler, it will give us the start-tag string. The string is encoded in
UTF-8. This method doesn't return a meaningful string inside declaration
handlers.</p>
</dd>
<dt>original_string</dt>
<dd>
<p>Returns the verbatim string from the document that was recognized in
order to call the current handler. The string is in the original
document encoding. This method doesn't return a meaningful string inside
declaration handlers.</p>
</dd>
<dt>xpcroak</dt>
<dd>
<p>Concatenate onto the given message the current line number within the
XML document plus the message implied by ErrorContext. Then croak with
the formed message.</p>
</dd>
<dt>xpcarp</dt>
<dd>
<p>Concatenate onto the given message the current line number within the
XML document plus the message implied by ErrorContext. Then carp with
the formed message.</p>
</dd>
<dt>xml_escape(TEXT [, CHAR [, CHAR ...]])</dt>
<dd>
<p>Returns TEXT with markup characters turned into character entities.
Any additional characters provided as arguments are also turned into
character references where found in TEXT. (this method is broken on some
versions of expat/XML::Parser)</p>
</dd>
</dl>
</dd>
<dt>path ( $optional_tag)</dt>
<dd>
<p>Return the element context in a form similar to XPath's short form:
'<code>/root/tag1/../tag</code>'</p>
</dd>
<dt>get_xpath ( $optional_array_ref, $xpath, $optional_offset)</dt>
<dd>
<p>Performs a <code>get_xpath</code> on the document root (see
&lt;Elt|Elt&gt;) If the <code>$optional_array_ref</code> argument is
used the array must contain elements. The <code>$xpath</code> expression
is applied to each element in turn and the result is union of all
results. This way a first query can be refined in further steps.</p>
</dd>
<dt>find_nodes ( $optional_array_ref, $xpath, $optional_offset)</dt>
<dd>
<p>same as <code>get_xpath</code></p>
</dd>
<dt>findnodes ( $optional_array_ref, $xpath, $optional_offset)</dt>
<dd>
<p>same as <code>get_xpath</code> (similar to the XML::LibXML
method)</p>
</dd>
<dt>findvalue ( $optional_array_ref, $xpath, $optional_offset)</dt>
<dd>
<p>Return the <code>join</code> of all texts of the results of applying
<code>get_xpath</code> to the node (similar to the XML::LibXML
method)</p>
</dd>
<dt>findvalues ( $optional_array_ref, $xpath, $optional_offset)</dt>
<dd>
<p>Return an array of all texts of the results of applying
<code>get_xpath</code> to the node</p>
</dd>
<dt>subs_text ($regexp, $replace)</dt>
<dd>
<p>subs_text does text substitution on the whole document, similar to
perl's <code> s///</code> operator.</p>
</dd>
<dt>dispose</dt>
<dd>
<p>Useful only if you don't have <code>Scalar::Util</code> or
<code>WeakRef</code> installed. Reclaims properly the memory used by an
XML::Twig object. As the object has circular references it never goes
out of scope, so if you want to parse lots of XML documents then the
memory leak becomes a problem. Use <code>$twig-&gt;dispose</code> to
clear this problem.</p>
</dd>
<dt>att_accessors (list_of_attribute_names)</dt>
<dd>
<p>A convenience method that creates l-valued accessors for attributes.
So <code>$twig-&gt;create_accessors( foo)</code> will create a
<code>foo</code> method that can be called on elements: $elt-&gt;foo; #
equivalent to $elt-&gt;{att}-&gt;{foo}; $elt-&gt;foo( bar); # equivalent
to $elt-&gt;set_att( foo =&gt; bar); The methods are l-valued only under
those perl's that support this feature (5.6 and above)</p>
</dd>
<dt>create_accessors (list_of_attribute_names)</dt>
<dd>
<p>Same as att_accessors</p>
</dd>
<dt>elt_accessors (list_of_attribute_names)</dt>
<dd>
<p>A convenience method that creates accessors for elements. So
<code>$twig-&gt;create_accessors( foo)</code> will create a
<code>foo</code> method that can be called on elements: $elt-&gt;foo; #
equivalent to $elt-&gt;first_child( foo);</p>
</dd>
<dt>field_accessors (list_of_attribute_names)</dt>
<dd>
<p>A convenience method that creates accessors for element values
(<code>field</code>). So <code>$twig-&gt;create_accessors( foo)</code>
will create a <code>foo</code> method that can be called on elements:
$elt-&gt;foo; # equivalent to $elt-&gt;field( foo);</p>
</dd>
<dt>set_do_not_escape_amp_in_atts</dt>
<dd>
<p>An evil method, that I only document because Test::Pod::Coverage
complaints otherwise, but really, you don't want to know about it.</p>
</dd>
</dl>
<h2>XML::Twig::Elt</h2>
<dl>
<dt>new ($optional_tag, $optional_atts, @optional_content)</dt>
<dd>
<p>The <code>tag</code> is optional (but then you can't have a content
), the <code>$optional_atts</code> argument is a reference to a hash of
attributes, the content can be just a string or a list of strings and
element. A content of '<code>#EMPTY</code>' creates an empty element;
Examples: my $elt= XML::Twig::Elt-&gt;new(); my $elt=
XML::Twig::Elt-&gt;new( para =&gt; { align =&gt; center }); my $elt=
XML::Twig::Elt-&gt;new( para =&gt; { align =&gt; center }, foo); my
$elt= XML::Twig::Elt-&gt;new( br =&gt; #EMPTY); my $elt=
XML::Twig::Elt-&gt;new( para); my $elt= XML::Twig::Elt-&gt;new( para
=&gt; this is a para); my $elt= XML::Twig::Elt-&gt;new( para =&gt;
$elt3, another para); The strings are not parsed, the element is not
attached to any twig. <strong>WARNING</strong>: if you rely on ID's then
you will have to set the id yourself. At this point the element does not
belong to a twig yet, so the ID attribute is not known so it won't be
stored in the ID list. Note that <code>#COMMENT</code>,
<code>#PCDATA</code> or <code>#CDATA</code> are valid tag names, that
will create text elements. To create an element <code>foo</code>
containing a CDATA section: my $foo= XML::Twig::Elt-&gt;new( #CDATA
=&gt; "content of the CDATA section") -&gt;wrap_in( foo); An attribute
of '#CDATA', will create the content of the element as CDATA: my $elt=
XML::Twig::Elt-&gt;new( p =&gt; { #CDATA =&gt; 1}, foo &lt; bar);
creates an element &lt;p&gt;&lt;![CDATA[foo &lt; bar]]&gt;&lt;/&gt;</p>
</dd>
<dt>parse ($string, %args)</dt>
<dd>
<p>Creates an element from an XML string. The string is actually parsed
as a new twig, then the root of that twig is returned. The arguments in
<code>%args</code> are passed to the twig. As always if the parse fails
the parser will die, so use an eval if you want to trap syntax errors.
As obviously the element does not exist beforehand this method has to be
called on the class: my $elt= parse XML::Twig::Elt( "&lt;a&gt; string to
parse, with &lt;sub/&gt; &lt;elements&gt;, actually tons of
&lt;/elements&gt; h&lt;/a&gt;");</p>
</dd>
<dt>set_inner_xml ($string)</dt>
<dd>
<p>Sets the content of the element to be the tree created from the
string</p>
</dd>
<dt>set_inner_html ($string)</dt>
<dd>
<p>Sets the content of the element, after parsing the string with an
HTML parser (HTML::Parser)</p>
</dd>
<dt>set_outer_xml ($string)</dt>
<dd>
<p>Replaces the element with the tree created from the string</p>
</dd>
<dt>print ($optional_filehandle, $optional_pretty_print_style)</dt>
<dd>
<p>Prints an entire element, including the tags, optionally to a
<code>$optional_filehandle</code>, optionally with a
<code>$pretty_print_style</code>. The print outputs XML data so base
entities are escaped.</p>
</dd>
<dt>print_to_file ($filename, %options)</dt>
<dd>
<p>Prints the element to file <code>$filename</code>. options: see
<code>flush</code>. =item sprint ($elt,
<code>$optional_no_enclosing_tag</code>) Return the xml string for an
entire element, including the tags. If the optional second argument is
true then only the string inside the element is returned (the start and
end tag for <code>$elt</code> are not). The text is XML-escaped: base
entities (&amp; and &lt; in text, &amp; &lt; and " in attribute values)
are turned into entities.</p>
</dd>
<dt>gi</dt>
<dd>
<p>Return the gi of the element (the gi is the
<code>generic identifier</code> the tag name in SGML parlance).
<code>tag</code> and <code>name</code> are synonyms of
<code>gi</code>.</p>
</dd>
<dt>tag</dt>
<dd>
<p>Same as <code>gi</code></p>
</dd>
<dt>name</dt>
<dd>
<p>Same as <code>tag</code></p>
</dd>
<dt>set_gi ($tag)</dt>
<dd>
<p>Set the gi (tag) of an element</p>
</dd>
<dt>set_tag ($tag)</dt>
<dd>
<p>Set the tag (=<code>tag</code>) of an element</p>
</dd>
<dt>set_name ($name)</dt>
<dd>
<p>Set the name (=<code>tag</code>) of an element</p>
</dd>
<dt>root</dt>
<dd>
<p>Return the root of the twig in which the element is contained.</p>
</dd>
<dt>twig</dt>
<dd>
<p>Return the twig containing the element.</p>
</dd>
<dt>parent ($optional_condition)</dt>
<dd>
<p>Return the parent of the element, or the first ancestor matching the
<code>$optional_condition</code></p>
</dd>
<dt>first_child ($optional_condition)</dt>
<dd>
<p>Return the first child of the element, or the first child matching
the <code>$optional_condition</code></p>
</dd>
<dt>has_child ($optional_condition)</dt>
<dd>
<p>Return the first child of the element, or the first child matching
the <code>$optional_condition</code> (same as first_child)</p>
</dd>
<dt>has_children ($optional_condition)</dt>
<dd>
<p>Return the first child of the element, or the first child matching
the <code>$optional_condition</code> (same as first_child)</p>
</dd>
<dt>first_child_text ($optional_condition)</dt>
<dd>
<p>Return the text of the first child of the element, or the first child
matching the <code>$optional_condition</code> If there is no first_child
then returns ''. This avoids getting the child, checking for its
existence then getting the text for trivial cases. Similar methods are
available for the other navigation methods:</p>
<dl>
<dt>last_child_text</dt>
<dd>

</dd>
</dl>
<dl>
<dt>prev_sibling_text</dt>
<dd>

</dd>
<dt>next_sibling_text</dt>
<dd>

</dd>
<dt>prev_elt_text</dt>
<dd>

</dd>
<dt>next_elt_text</dt>
<dd>

</dd>
<dt>child_text</dt>
<dd>

</dd>
<dt>parent_text</dt>
<dd>

</dd>
</dl>
<p>All this methods also exist in trimmed variant:</p>
<dl>
<dt>first_child_trimmed_text</dt>
<dd>

</dd>
</dl>
<dl>
<dt>last_child_trimmed_text</dt>
<dd>

</dd>
<dt>prev_sibling_trimmed_text</dt>
<dd>

</dd>
<dt>next_sibling_trimmed_text</dt>
<dd>

</dd>
<dt>prev_elt_trimmed_text</dt>
<dd>

</dd>
<dt>next_elt_trimmed_text</dt>
<dd>

</dd>
<dt>child_trimmed_text</dt>
<dd>

</dd>
<dt>parent_trimmed_text</dt>
<dd>

</dd>
</dl>
</dd>
<dt>field ($condition)</dt>
<dd>

</dd>
</dl>
<p>Same method as <code>first_child_text</code> with a different
name</p>
<dl>
<dt>fields ($condition_list)</dt>
<dd>
<p>Return the list of field (text of first child matching the
conditions), missing fields are returned as the empty string. Same
method as <code>first_child_text</code> with a different name</p>
</dd>
<dt>trimmed_field ($optional_condition)</dt>
<dd>
<p>Same method as <code>first_child_trimmed_text</code> with a different
name</p>
</dd>
<dt>set_field ($condition, $optional_atts,
@list_of_elt_and_strings)</dt>
<dd>
<p>Set the content of the first child of the element that matches
<code>$condition</code>, the rest of the arguments is the same as for
<code>set_content</code> If no child matches <code>$condition</code>
_and_ if <code>$condition</code> is a valid XML element name, then a new
element by that name is created and inserted as the last child.</p>
</dd>
<dt>first_child_matches ($optional_condition)</dt>
<dd>
<p>Return the element if the first child of the element (if it exists)
passes the <code>$optional_condition</code> <code>undef</code> otherwise
if( $elt-&gt;first_child_matches( title)) ... is equivalent to if(
$elt-&gt;{first_child} &amp;&amp; $elt-&gt;{first_child}-&gt;passes(
title)) <code>first_child_is</code> is another name for this method
Similar methods are available for the other navigation methods:</p>
<dl>
<dt>last_child_matches</dt>
<dd>

</dd>
</dl>
<dl>
<dt>prev_sibling_matches</dt>
<dd>

</dd>
<dt>next_sibling_matches</dt>
<dd>

</dd>
<dt>prev_elt_matches</dt>
<dd>

</dd>
<dt>next_elt_matches</dt>
<dd>

</dd>
<dt>child_matches</dt>
<dd>

</dd>
<dt>parent_matches</dt>
<dd>

</dd>
</dl>
</dd>
<dt>is_first_child ($optional_condition)</dt>
<dd>

</dd>
</dl>
<p>returns true (the element) if the element is the first child of its
parent (optionally that satisfies the
<code>$optional_condition</code>)</p>
<dl>
<dt>is_last_child ($optional_condition)</dt>
<dd>
<p>returns true (the element) if the element is the last child of its
parent (optionally that satisfies the
<code>$optional_condition</code>)</p>
</dd>
<dt>prev_sibling ($optional_condition)</dt>
<dd>
<p>Return the previous sibling of the element, or the previous sibling
matching <code>$optional_condition</code></p>
</dd>
<dt>next_sibling ($optional_condition)</dt>
<dd>
<p>Return the next sibling of the element, or the first one matching
<code>$optional_condition</code>.</p>
</dd>
<dt>next_elt ($optional_elt, $optional_condition)</dt>
<dd>
<p>Return the next elt (optionally matching
<code>$optional_condition</code>) of the element. This is defined as the
next element which opens after the current element opens. Which usually
means the first child of the element. Counter-intuitive as it might look
this allows you to loop through the whole document by starting from the
root. The <code>$optional_elt</code> is the root of a subtree. When the
<code>next_elt</code> is out of the subtree then the method returns
undef. You can then walk a sub-tree with: my $elt= $subtree_root; while(
$elt= $elt-&gt;next_elt( $subtree_root)) { # insert processing code here
}</p>
</dd>
<dt>prev_elt ($optional_condition)</dt>
<dd>
<p>Return the previous elt (optionally matching
<code>$optional_condition</code>) of the element. This is the first
element which opens before the current one. It is usually either the
last descendant of the previous sibling or simply the parent</p>
</dd>
<dt>next_n_elt ($offset, $optional_condition)</dt>
<dd>
<p>Return the <code>$offset</code>-th element that matches the
<code>$optional_condition</code></p>
</dd>
<dt>following_elt</dt>
<dd>
<p>Return the following element (as per the XPath following axis)</p>
</dd>
<dt>preceding_elt</dt>
<dd>
<p>Return the preceding element (as per the XPath preceding axis)</p>
</dd>
<dt>following_elts</dt>
<dd>
<p>Return the list of following elements (as per the XPath following
axis)</p>
</dd>
<dt>preceding_elts</dt>
<dd>
<p>Return the list of preceding elements (as per the XPath preceding
axis)</p>
</dd>
<dt>children ($optional_condition)</dt>
<dd>
<p>Return the list of children (optionally which matches
<code>$optional_condition</code>) of the element. The list is in
document order.</p>
</dd>
<dt>children_count ($optional_condition)</dt>
<dd>
<p>Return the number of children of the element (optionally which
matches <code>$optional_condition</code>)</p>
</dd>
<dt>children_text ($optional_condition)</dt>
<dd>
<p>In array context, returns an array containing the text of children of
the element (optionally which matches <code>$optional_condition</code>)
In scalar context, returns the concatenation of the text of children of
the element</p>
</dd>
<dt>children_trimmed_text ($optional_condition)</dt>
<dd>
<p>In array context, returns an array containing the trimmed text of
children of the element (optionally which matches
<code>$optional_condition</code>) In scalar context, returns the
concatenation of the trimmed text of children of the element</p>
</dd>
<dt>children_copy ($optional_condition)</dt>
<dd>
<p>Return a list of elements that are copies of the children of the
element, optionally which matches <code>$optional_condition</code></p>
</dd>
<dt>descendants ($optional_condition)</dt>
<dd>
<p>Return the list of all descendants (optionally which matches
<code>$optional_condition</code>) of the element. This is the equivalent
of the <code>getElementsByTagName</code> of the DOM (by the way, if you
are really a DOM addict, you can use <code>getElementsByTagName</code>
instead)</p>
</dd>
<dt>getElementsByTagName ($optional_condition)</dt>
<dd>
<p>Same as <code>descendants</code></p>
</dd>
<dt>find_by_tag_name ($optional_condition)</dt>
<dd>
<p>Same as <code>descendants</code></p>
</dd>
<dt>descendants_or_self ($optional_condition)</dt>
<dd>
<p>Same as <code>descendants</code> except that the element itself is
included in the list if it matches the
<code>$optional_condition</code></p>
</dd>
<dt>first_descendant ($optional_condition)</dt>
<dd>
<p>Return the first descendant of the element that matches the
condition</p>
</dd>
<dt>last_descendant ($optional_condition)</dt>
<dd>
<p>Return the last descendant of the element that matches the
condition</p>
</dd>
<dt>ancestors ($optional_condition)</dt>
<dd>
<p>Return the list of ancestors (optionally matching
<code>$optional_condition</code>) of the element. The list is ordered
from the innermost ancestor to the outermost one NOTE: the element
itself is not part of the list, in order to include it you will have to
use ancestors_or_self</p>
</dd>
<dt>ancestors_or_self ($optional_condition)</dt>
<dd>
<p>Return the list of ancestors (optionally matching
<code>$optional_condition</code>) of the element, including the element
(if it matches the condition&gt;). The list is ordered from the
innermost ancestor to the outermost one</p>
</dd>
<dt>passes ($condition)</dt>
<dd>
<p>Return the element if it passes the <code>$condition</code></p>
</dd>
<dt>att ($att)</dt>
<dd>
<p>Return the value of attribute <code>$att</code> or
<code>undef</code></p>
</dd>
<dt>latt ($att)</dt>
<dd>
<p>Return the value of attribute <code>$att</code> or <code>undef</code>
this method is an lvalue, so you can do
<code>$elt-&gt;latt( foo)= bar</code> or
<code>$elt-&gt;latt( foo)++;</code></p>
</dd>
<dt>set_att ($att, $att_value)</dt>
<dd>
<p>Set the attribute of the element to the given value You can actually
set several attributes this way: $elt-&gt;set_att( att1 =&gt; "val1",
att2 =&gt; "val2");</p>
</dd>
<dt>del_att ($att)</dt>
<dd>
<p>Delete the attribute for the element You can actually delete several
attributes at once: $elt-&gt;del_att( att1, att2, att3);</p>
</dd>
<dt>att_exists ($att)</dt>
<dd>
<p>Returns true if the attribute <code>$att</code> exists for the
element, false otherwise</p>
</dd>
<dt>cut</dt>
<dd>
<p>Cut the element from the tree. The element still exists, it can be
copied or pasted somewhere else, it is just not attached to the tree
anymore. Note that the old links to the parent, previous and next
siblings can still be accessed using the former_* methods</p>
</dd>
<dt>former_next_sibling</dt>
<dd>
<p>Returns the former next sibling of a cut node (or undef if the node
has not been cut) This makes it easier to write loops where you cut
elements: my $child= $parent-&gt;first_child( achild); while(
$child-&gt;{att}-&gt;{cut}) { $child-&gt;cut; $child=
($child-&gt;{former} &amp;&amp; $child-&gt;{former}-&gt;{next_sibling});
}</p>
</dd>
<dt>former_prev_sibling</dt>
<dd>
<p>Returns the former previous sibling of a cut node (or undef if the
node has not been cut)</p>
</dd>
<dt>former_parent</dt>
<dd>
<p>Returns the former parent of a cut node (or undef if the node has not
been cut)</p>
</dd>
<dt>cut_children ($optional_condition)</dt>
<dd>
<p>Cut all the children of the element (or all of those which satisfy
the <code>$optional_condition</code>). Return the list of children</p>
</dd>
<dt>cut_descendants ($optional_condition)</dt>
<dd>
<p>Cut all the descendants of the element (or all of those which satisfy
the <code>$optional_condition</code>). Return the list of
descendants</p>
</dd>
<dt>copy ($elt)</dt>
<dd>
<p>Return a copy of the element. The copy is a deep copy: all
sub-elements of the element are duplicated.</p>
</dd>
<dt>paste ($optional_position, $ref)</dt>
<dd>
<p>Paste a (previously <code>cut</code> or newly generated) element. Die
if the element already belongs to a tree. Note that the calling element
is pasted: $child-&gt;paste( first_child =&gt; $existing_parent);
$new_sibling-&gt;paste( after =&gt;
$this_sibling_is_already_in_the_tree); or my $new_elt=
XML::Twig::Elt-&gt;new( tag =&gt; $content); $new_elt-&gt;paste(
$position =&gt; $existing_elt); Example: my $t=
XML::Twig-&gt;new-&gt;parse( doc.xml) my $toc= $t-&gt;root-&gt;new(
toc); $toc-&gt;paste( $t-&gt;root); # $toc is pasted as first child of
the root foreach my $title ($t-&gt;findnodes( /doc/section/title)) { my
$title_toc= $title-&gt;copy; # paste $title_toc as the last child of toc
$title_toc-&gt;paste( last_child =&gt; $toc) } Position options:</p>
<dl>
<dt>first_child (default)</dt>
<dd>
<p>The element is pasted as the first child of <code>$ref</code></p>
</dd>
<dt>last_child</dt>
<dd>
<p>The element is pasted as the last child of <code>$ref</code></p>
</dd>
<dt>before</dt>
<dd>
<p>The element is pasted before <code>$ref</code>, as its previous
sibling.</p>
</dd>
<dt>after</dt>
<dd>
<p>The element is pasted after <code>$ref</code>, as its next
sibling.</p>
</dd>
<dt>within</dt>
<dd>
<p>In this case an extra argument, <code>$offset</code>, should be
supplied. The element will be pasted in the reference element (or in its
first text child) at the given offset. To achieve this the reference
element will be split at the offset.</p>
</dd>
</dl>
<p>Note that you can call directly the underlying method:</p>
<dl>
<dt>paste_before</dt>
<dd>

</dd>
</dl>
<dl>
<dt>paste_after</dt>
<dd>

</dd>
<dt>paste_first_child</dt>
<dd>

</dd>
<dt>paste_last_child</dt>
<dd>

</dd>
<dt>paste_within</dt>
<dd>

</dd>
</dl>
</dd>
<dt>move ($optional_position, $ref)</dt>
<dd>

</dd>
</dl>
<p>Move an element in the tree. This is just a <code>cut</code> then a
<code>paste</code>. The syntax is the same as <code>paste</code>.</p>
<dl>
<dt>replace ($ref)</dt>
<dd>
<p>Replaces an element in the tree. Sometimes it is just not possible
to<code>cut</code> an element then <code>paste</code> another in its
place, so <code>replace</code> comes in handy. The calling element
replaces <code>$ref</code>.</p>
</dd>
<dt>replace_with (@elts)</dt>
<dd>
<p>Replaces the calling element with one or more elements</p>
</dd>
<dt>delete</dt>
<dd>
<p>Cut the element and frees the memory.</p>
</dd>
<dt>prefix ($text, $optional_option)</dt>
<dd>
<p>Add a prefix to an element. If the element is a <code>PCDATA</code>
element the text is added to the pcdata, if the elements first child is
a <code>PCDATA</code> then the text is added to it's pcdata, otherwise a
new <code>PCDATA</code> element is created and pasted as the first child
of the element. If the option is <code>asis</code> then the prefix is
added asis: it is created in a separate <code>PCDATA</code> element with
an <code>asis</code> property. You can then write: $elt1-&gt;prefix(
&lt;b&gt;, asis); to create a <code>&lt;b&gt;</code> in the output of
<code>print</code>.</p>
</dd>
<dt>suffix ($text, $optional_option)</dt>
<dd>
<p>Add a suffix to an element. If the element is a <code>PCDATA</code>
element the text is added to the pcdata, if the elements last child is a
<code>PCDATA</code> then the text is added to it's pcdata, otherwise a
new PCDATA element is created and pasted as the last child of the
element. If the option is <code>asis</code> then the suffix is added
asis: it is created in a separate <code>PCDATA</code> element with an
<code>asis</code> property. You can then write: $elt2-&gt;suffix(
&lt;/b&gt;, asis);</p>
</dd>
<dt>trim</dt>
<dd>
<p>Trim the element in-place: spaces at the beginning and at the end of
the element are discarded and multiple spaces within the element (or its
descendants) are replaced by a single space. Note that in some cases you
can still end up with multiple spaces, if they are split between several
elements: &lt;doc&gt; text &lt;b&gt; hah! &lt;/b&gt; yep&lt;/doc&gt;
gets trimmed to &lt;doc&gt;text &lt;b&gt; hah! &lt;/b&gt;
yep&lt;/doc&gt; This is somewhere in between a bug and a feature.</p>
</dd>
<dt>normalize</dt>
<dd>
<p>merge together all consecutive pcdata elements in the element (if for
example you have turned some elements into pcdata using
<code>erase</code>, this will give you a clean element in which there
all text fragments are as long as possible).</p>
</dd>
<dt>simplify (%options)</dt>
<dd>
<p>Return a data structure suspiciously similar to XML::Simple's.
Options are identical to XMLin options, see XML::Simple doc for more
details (or use DATA::dumper or YAML to dump the data structure)
<strong>Note</strong>: there is no magic here, if you write
<code>$twig-&gt;parsefile( $file )-&gt;simplify();</code> then it will
load the entire document in memory. I am afraid you will have to put
some work into it to get just the bits you want and discard the rest.
Look at the synopsis or the XML::Twig 101 section at the top of the docs
for more information.</p>
<dl>
<dt>content_key</dt>
<dd>

</dd>
</dl>
<dl>
<dt>forcearray</dt>
<dd>

</dd>
<dt>keyattr</dt>
<dd>

</dd>
<dt>noattr</dt>
<dd>

</dd>
<dt>normalize_space</dt>
<dd>

</dd>
</dl>
<p>aka normalise_space</p>
<dl>
<dt>variables (%var_hash)</dt>
<dd>
<p><code>%var_hash</code> is a hash { name =&gt; value } This option
allows variables in the XML to be expanded when the file is read. (there
is no facility for putting the variable names back if you regenerate XML
using XMLout). A 'variable' is any text of the form ${name} (or
<code>$name</code>) which occurs in an attribute value or in the text
content of an element. If 'name' matches a key in the supplied hashref,
${name} will be replaced with the corresponding value from the hashref.
If no matching key is found, the variable will not be replaced.</p>
</dd>
<dt>var_att ($attribute_name)</dt>
<dd>
<p>This option gives the name of an attribute that will be used to
create variables in the XML: &lt;dirs&gt; &lt;dir
name="prefix"&gt;/usr/local&lt;/dir&gt; &lt;dir
name="exec_prefix"&gt;$prefix/bin&lt;/dir&gt; &lt;/dirs&gt; use
<code>var =&gt; name</code> to get <code>$prefix</code> replaced by
/usr/local in the generated data structure By default variables are
captured by the following regexp: /$(\w+)/</p>
</dd>
<dt>var_regexp (regexp)</dt>
<dd>
<p>This option changes the regexp used to capture variables. The
variable name should be in <code>$1</code></p>
</dd>
<dt>group_tags { grouping tag =&gt; grouped tag, grouping tag 2 =&gt;
grouped tag 2...}</dt>
<dd>
<p>Option used to simplify the structure: elements listed will not be
used. Their children will be, they will be considered children of the
element parent. If the element is: &lt;config
host="laptop.xmltwig.org"&gt; &lt;server&gt;localhost&lt;/server&gt;
&lt;dirs&gt; &lt;dir name="base"&gt;/home/mrodrigu/standards&lt;/dir&gt;
&lt;dir name="tools"&gt;$base/tools&lt;/dir&gt; &lt;/dirs&gt;
&lt;templates&gt; &lt;template
name="std_def"&gt;std_def.templ&lt;/template&gt; &lt;template
name="dummy"&gt;dummy&lt;/template&gt; &lt;/templates&gt;
&lt;/config&gt; Then calling simplify with
<code>group_tags =&gt; { dirs =&gt; dir,</code> templates =&gt;
template} makes the data structure be exactly as if the start and end
tags for <code>dirs</code> and <code>templates</code> were not there. A
YAML dump of the structure base: /home/mrodrigu/standards host:
laptop.xmltwig.org server: localhost template: - std_def.templ -
dummy.templ tools: $base/tools</p>
</dd>
</dl>
</dd>
<dt>split_at ($offset)</dt>
<dd>
<p>Split a text (<code>PCDATA</code> or <code>CDATA</code>) element in 2
at <code>$offset</code>, the original element now holds the first part
of the string and a new element holds the right part. The new element is
returned If the element is not a text element then the first text child
of the element is split</p>
</dd>
<dt>split ( $optional_regexp, $tag1, $atts1, $tag2, $atts2...)</dt>
<dd>
<p>Split the text descendants of an element in place, the text is split
using the <code>$regexp</code>, if the regexp includes () then the
matched separators will be wrapped in elements. <code>$1</code> is
wrapped in <code>$tag1</code>, with attributes <code>$atts1</code> if
<code>$atts1</code> is given (as a hashref), <code>$2</code> is wrapped
in <code>$tag2</code>... if <code>$elt</code> is
<code>&lt;p&gt;tati tata &lt;b&gt;tutu tati titi&lt;/b&gt; tata tati tata&lt;/p&gt;</code>
$elt-&gt;split( qr/(ta)ti/, foo, {type =&gt; toto} ) will change
<code>$elt</code> to &lt;p&gt;&lt;foo type="toto"&gt;ta&lt;/foo&gt; tata
&lt;b&gt;tutu &lt;foo type="toto"&gt;ta&lt;/foo&gt; titi&lt;/b&gt; tata
&lt;foo type="toto"&gt;ta&lt;/foo&gt; tata&lt;/p&gt; The regexp can be
passed either as a string or as <code>qr//</code> (perl 5.005 and
later), it defaults to \s+ just as the <code>split</code> built-in (but
this would be quite a useless behaviour without the
<code>$optional_tag</code> parameter) <code>$optional_tag</code>
defaults to PCDATA or CDATA, depending on the initial element type The
list of descendants is returned (including un-touched original elements
and newly created ones)</p>
</dd>
<dt>mark ( $regexp, $optional_tag, $optional_attribute_ref)</dt>
<dd>
<p>This method behaves exactly as split, except only the newly created
elements are returned</p>
</dd>
<dt>wrap_children ( $regexp_string, $tag,
$optional_attribute_hashref)</dt>
<dd>
<p>Wrap the children of the element that match the regexp in an element
<code>$tag</code>. If <code>$optional_attribute_hashref</code> is passed
then the new element will have these attributes. The
<code>$regexp_string</code> includes tags, within pointy brackets, as in
<code>&lt;title&gt;&lt;para&gt;+</code> and the usual Perl modifiers
(+*?...). Tags can be further qualified with attributes:
<code>&lt;para type="warning" classif="cosmic_secret"&gt;+</code>. The
values for attributes should be xml-escaped:
<code>&lt;candy type="M&amp;amp;Ms"&gt;*</code> (<code>&lt;</code>,
<code>&amp;</code> <strong><code>&gt;</code></strong> and <code>"</code>
should be escaped). Note that elements might get extra <code>id</code>
attributes in the process. See add_id. Use strip_att to remove unwanted
id's. Here is an example: If the element <code>$elt</code> has the
following content: &lt;elt&gt; &lt;p&gt;para 1&lt;/p&gt;
&lt;l_l1_1&gt;list 1 item 1 para 1&lt;/l_l1_1&gt; &lt;l_l1&gt;list 1
item 1 para 2&lt;/l_l1&gt; &lt;l_l1_n&gt;list 1 item 2 para 1 (only
para)&lt;/l_l1_n&gt; &lt;l_l1_n&gt;list 1 item 3 para 1&lt;/l_l1_n&gt;
&lt;l_l1&gt;list 1 item 3 para 2&lt;/l_l1&gt; &lt;l_l1&gt;list 1 item 3
para 3&lt;/l_l1&gt; &lt;l_l1_1&gt;list 2 item 1 para 1&lt;/l_l1_1&gt;
&lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt; &lt;l_l1_n&gt;list 2 item
2 para 1 (only para)&lt;/l_l1_n&gt; &lt;l_l1_n&gt;list 2 item 3 para
1&lt;/l_l1_n&gt; &lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt;
&lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt; &lt;/elt&gt; Then the code
$elt-&gt;wrap_children( q{&lt;l_l1_1&gt;&lt;l_l1&gt;*} , li =&gt; { type
=&gt; "ul1" }); $elt-&gt;wrap_children( q{&lt;l_l1_n&gt;&lt;l_l1&gt;*} ,
li =&gt; { type =&gt; "ul" }); $elt-&gt;wrap_children( q{&lt;li
type="ul1"&gt;&lt;li type="ul"&gt;+}, "ul"); $elt-&gt;strip_att( id);
$elt-&gt;strip_att( type); $elt-&gt;print; will output: &lt;elt&gt;
&lt;p&gt;para 1&lt;/p&gt; &lt;ul&gt; &lt;li&gt; &lt;l_l1_1&gt;list 1
item 1 para 1&lt;/l_l1_1&gt; &lt;l_l1&gt;list 1 item 1 para
2&lt;/l_l1&gt; &lt;/li&gt; &lt;li&gt; &lt;l_l1_n&gt;list 1 item 2 para 1
(only para)&lt;/l_l1_n&gt; &lt;/li&gt; &lt;li&gt; &lt;l_l1_n&gt;list 1
item 3 para 1&lt;/l_l1_n&gt; &lt;l_l1&gt;list 1 item 3 para
2&lt;/l_l1&gt; &lt;l_l1&gt;list 1 item 3 para 3&lt;/l_l1&gt; &lt;/li&gt;
&lt;/ul&gt; &lt;ul&gt; &lt;li&gt; &lt;l_l1_1&gt;list 2 item 1 para
1&lt;/l_l1_1&gt; &lt;l_l1&gt;list 2 item 1 para 2&lt;/l_l1&gt;
&lt;/li&gt; &lt;li&gt; &lt;l_l1_n&gt;list 2 item 2 para 1 (only
para)&lt;/l_l1_n&gt; &lt;/li&gt; &lt;li&gt; &lt;l_l1_n&gt;list 2 item 3
para 1&lt;/l_l1_n&gt; &lt;l_l1&gt;list 2 item 3 para 2&lt;/l_l1&gt;
&lt;l_l1&gt;list 2 item 3 para 3&lt;/l_l1&gt; &lt;/li&gt; &lt;/ul&gt;
&lt;/elt&gt;</p>
</dd>
<dt>subs_text ($regexp, $replace)</dt>
<dd>
<p>subs_text does text substitution, similar to perl's
<code> s///</code> operator. <code>$regexp</code> must be a perl regexp,
created with the <code>qr</code> operator. <code>$replace</code> can
include <code>$1, $2</code>... from the <code>$regexp</code>. It can
also be used to create element and entities, by using
<code>&amp;elt( tag =&gt; { att =&gt; val }, text)</code> (similar
syntax as <code>new</code>) and <code>&amp;ent( name)</code>. Here is a
rather complex example: $elt-&gt;subs_text( qr{(?&lt;!do not )link to
(http://([^\s,]*))}, see &amp;elt( a =&gt;{ href =&gt; $1 }, $2) ); This
will replace text like <em>link to http://www.xmltwig.org</em> by
<em>see &lt;a href=www.xmltwig.org&gt;www.xmltwig.org&lt;/a&gt;</em>,
but not <em>do not link to...</em> Generating entities (here replacing
spaces with &amp;nbsp;): $elt-&gt;subs_text( qr{ }, &amp;ent(
"&amp;nbsp;")); or, using a variable: my $ent="&amp;nbsp;";
$elt-&gt;subs_text( qr{ }, "&amp;ent( $ent)"); Note that the
substitution is always global, as in using the <code>g</code> modifier
in a perl substitution, and that it is performed on all text descendants
of the element. <strong>Bug</strong>: in the <code>$regexp</code>, you
can only use <code>\1</code>, <code>\2</code>... if the replacement
expression does not include elements or attributes. eg $t-&gt;subs_text(
qr/((t[aiou])\2)/, $2); # ok, replaces toto, tata, titi, tutu by to, ta,
ti, tu $t-&gt;subs_text( qr/((t[aiou])\2)/, &amp;elt(p =&gt; $1) ); #
NOK, does not find toto...</p>
</dd>
<dt>add_id ($optional_coderef)</dt>
<dd>
<p>Add an id to the element. The id is an attribute, <code>id</code> by
default, see the <code>id</code> option for XML::Twig <code>new</code>
to change it. Use an id starting with <code>#</code> to get an id that's
not output by print, flush or sprint, yet that allows you to use the
elt_id method to get the element easily. If the element already has an
id, no new id is generated. By default the method create an id of the
form <code>twig_id_&lt;nnnn&gt;</code>, where <code>&lt;nnnn&gt;</code>
is a number, incremented each time the method is called
successfully.</p>
</dd>
<dt>set_id_seed ($prefix)</dt>
<dd>
<p>by default the id generated by <code>add_id</code> is
<code>twig_id_&lt;nnnn&gt;</code>, <code>set_id_seed</code> changes the
prefix to <code>$prefix</code> and resets the number to 1</p>
</dd>
<dt>strip_att ($att)</dt>
<dd>
<p>Remove the attribute <code>$att</code> from all descendants of the
element (including the element) Return the element</p>
</dd>
<dt>change_att_name ($old_name, $new_name)</dt>
<dd>
<p>Change the name of the attribute from <code>$old_name</code> to
<code>$new_name</code>. If there is no attribute <code>$old_name</code>
nothing happens.</p>
</dd>
<dt>lc_attnames</dt>
<dd>
<p>Lower cases the name all the attributes of the element.</p>
</dd>
<dt>sort_children_on_value( %options)</dt>
<dd>
<p>Sort the children of the element in place according to their text.
All children are sorted. Return the element, with its children sorted.
<code>%options</code> are type : numeric | alpha (default: alpha) order
: normal | reverse (default: normal) Return the element, with its
children sorted</p>
</dd>
<dt>sort_children_on_att ($att, %options)</dt>
<dd>
<p>Sort the children of the element in place according to attribute
<code>$att</code>. <code>%options</code> are the same as for
<code>sort_children_on_value</code> Return the element.</p>
</dd>
<dt>sort_children_on_field ($tag, %options)</dt>
<dd>
<p>Sort the children of the element in place, according to the field
<code>$tag</code> (the text of the first child of the child with this
tag). <code>%options</code> are the same as for
<code>sort_children_on_value</code>. Return the element, with its
children sorted</p>
</dd>
<dt>sort_children( $get_key, %options)</dt>
<dd>
<p>Sort the children of the element in place. The <code>$get_key</code>
argument is a reference to a function that returns the sort key when
passed an element. For example: $elt-&gt;sort_children( sub {
$_[0]-&gt;{att}-&gt;{"nb"} + $_[0]-&gt;text }, type =&gt; numeric, order
=&gt; reverse );</p>
</dd>
<dt>field_to_att ($cond, $att)</dt>
<dd>
<p>Turn the text of the first sub-element matched by <code>$cond</code>
into the value of attribute <code>$att</code> of the element. If
<code>$att</code> is omitted then <code>$cond</code> is used as the name
of the attribute, which makes sense only if <code>$cond</code> is a
valid element (and attribute) name. The sub-element is then cut.</p>
</dd>
<dt>att_to_field ($att, $tag)</dt>
<dd>
<p>Take the value of attribute <code>$att</code> and create a
sub-element <code>$tag</code> as first child of the element. If
<code>$tag</code> is omitted then <code>$att</code> is used as the name
of the sub-element.</p>
</dd>
<dt>get_xpath ($xpath, $optional_offset)</dt>
<dd>
<p>Return a list of elements satisfying the <code>$xpath</code>.
<code>$xpath</code> is an XPATH-like expression. A subset of the XPATH
abbreviated syntax is covered: tag tag[1] (or any other positive number)
tag[last()] tag[@att] (the attribute exists for the element)
tag[@att="val"] tag[@att=~ /regexp/] tag[att1="val1" and att2="val2"]
tag[att1="val1" or att2="val2"] tag[string()="toto"] (returns tag
elements which text (as per the text method) is toto)
tag[string()=~/regexp/] (returns tag elements which text (as per the
text method) matches regexp) expressions can start with / (search starts
at the document root) expressions can start with . (search starts at the
current element) // can be used to get all descendants instead of just
direct children * matches any tag So the following examples from the
<em>XPath
recommendation&lt;http://www.w3.org/TR/xpath.html#path-abbrev&gt;</em>
work: para selects the para element children of the context node *
selects all element children of the context node para[1] selects the
first para child of the context node para[last()] selects the last para
child of the context node */para selects all para grandchildren of the
context node /doc/chapter[5]/section[2] selects the second section of
the fifth chapter of the doc chapter//para selects the para element
descendants of the chapter element children of the context node //para
selects all the para descendants of the document root and thus selects
all para elements in the same document as the context node //olist/item
selects all the item elements in the same document as the context node
that have an olist parent .//para selects the para element descendants
of the context node .. selects the parent of the context node
para[@type="warning"] selects all para children of the context node that
have a type attribute with value warning employee[@secretary and
@assistant] selects all the employee children of the context node that
have both a secretary attribute and an assistant attribute The elements
will be returned in the document order. If <code>$optional_offset</code>
is used then only one element will be returned, the one with the
appropriate offset in the list, starting at 0 Quoting and interpolating
variables can be a pain when the Perl syntax and the XPATH syntax
collide, so use alternate quoting mechanisms like q or qq (I like q{}
and qq{} myself). Here are some more examples to get you started: my
$p1= "p1"; my $p2= "p2"; my @res= $t-&gt;get_xpath( qq{p[string( "$p1")
or string( "$p2")]}); my $a= "a1"; my @res= $t-&gt;get_xpath(
qq{//*[@att="$a"]}); my $val= "a1"; my $exp= qq{//p[ \@att=$val]}; # you
need to use \@ or you will get a warning my @res= $t-&gt;get_xpath(
$exp); Note that the only supported regexps delimiters are / and that
you must backslash all / in regexps AND in regular strings. XML::Twig
does not provide natively full XPATH support, but you can use
<code>XML::Twig::XPath</code> to get <code>findnodes</code> to use
<code>XML::XPath</code> as the XPath engine, with full coverage of the
spec. <code>XML::Twig::XPath</code> to get <code>findnodes</code> to use
<code>XML::XPath</code> as the XPath engine, with full coverage of the
spec.</p>
</dd>
<dt>find_nodes</dt>
<dd>
<p>same as<code>get_xpath</code></p>
</dd>
<dt>findnodes</dt>
<dd>
<p>same as <code>get_xpath</code></p>
</dd>
<dt>text @optional_options</dt>
<dd>
<p>Return a string consisting of all the <code>PCDATA</code> and
<code>CDATA</code> in an element, without any tags. The text is not
XML-escaped: base entities such as <code>&amp;</code> and
<code>&lt;</code> are not escaped. The '<code>no_recurse</code>' option
will only return the text of the element, not of any included
sub-elements (same as <code>text_only</code>).</p>
</dd>
<dt>text_only</dt>
<dd>
<p>Same as <code>text</code> except that the text returned doesn't
include the text of sub-elements.</p>
</dd>
<dt>trimmed_text</dt>
<dd>
<p>Same as <code>text</code> except that the text is trimmed: leading
and trailing spaces are discarded, consecutive spaces are collapsed</p>
</dd>
<dt>set_text ($string)</dt>
<dd>
<p>Set the text for the element: if the element is a
<code>PCDATA</code>, just set its text, otherwise cut all the children
of the element and create a single <code>PCDATA</code> child for it,
which holds the text.</p>
</dd>
<dt>merge ($elt2)</dt>
<dd>
<p>Move the content of <code>$elt2</code> within the element</p>
</dd>
<dt>insert ($tag1, [$optional_atts1], $tag2, [$optional_atts2],...)</dt>
<dd>
<p>For each tag in the list inserts an element <code>$tag</code> as the
only child of the element. The element gets the optional attributes
in<code>$optional_atts&lt;n&gt;.</code> All children of the element are
set as children of the new element. The upper level element is returned.
$p-&gt;insert( table =&gt; { border=&gt; 1}, tr, td) put <code>$p</code>
in a table with a visible border, a single <code>tr</code> and a single
<code>td</code> and return the <code>table</code> element:
&lt;p&gt;&lt;table border="1"&gt;&lt;tr&gt;&lt;td&gt;original content of
p&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/p&gt;</p>
</dd>
<dt>wrap_in (@tag)</dt>
<dd>
<p>Wrap elements in <code>@tag</code> as the successive ancestors of the
element, returns the new element.
<code>$elt-&gt;wrap_in( td, tr, table)</code> wraps the element as a
single cell in a table for example. Optionally each tag can be followed
by a hashref of attributes, that will be set on the wrapping element:
$elt-&gt;wrap_in( p =&gt; { class =&gt; "advisory" }, div =&gt; { class
=&gt; "intro", id =&gt; "div_intro" });</p>
</dd>
<dt>insert_new_elt ($opt_position, $tag, $opt_atts_hashref,
@opt_content)</dt>
<dd>
<p>Combines a <code>new </code> and a <code>paste </code>: creates a new
element using <code>$tag</code>, <code>$opt_atts_hashref </code>and
<code>@opt_content</code> which are arguments similar to those for
<code>new</code>, then paste it, using <code>$opt_position</code> or
<code>first_child</code>, relative to <code>$elt</code>. Return the
newly created element</p>
</dd>
<dt>erase</dt>
<dd>
<p>Erase the element: the element is deleted and all of its children are
pasted in its place.</p>
</dd>
<dt>set_content ( $optional_atts, @list_of_elt_and_strings) (
$optional_atts, '#EMPTY')</dt>
<dd>
<p>Set the content for the element, from a list of strings and elements.
Cuts all the element children, then pastes the list elements as the
children. This method will create a <code>PCDATA</code> element for any
strings in the list. The <code>$optional_atts</code> argument is the ref
of a hash of attributes. If this argument is used then the previous
attributes are deleted, otherwise they are left untouched.
<strong>WARNING</strong>: if you rely on ID's then you will have to set
the id yourself. At this point the element does not belong to a twig
yet, so the ID attribute is not known so it won't be stored in the ID
list. A content of '<code>#EMPTY</code>' creates an empty element;</p>
</dd>
<dt>namespace ($optional_prefix)</dt>
<dd>
<p>Return the URI of the namespace that <code>$optional_prefix</code> or
the element name belongs to. If the name doesn't belong to any
namespace, <code>undef</code> is returned.</p>
</dd>
<dt>local_name</dt>
<dd>
<p>Return the local name (without the prefix) for the element</p>
</dd>
<dt>ns_prefix</dt>
<dd>
<p>Return the namespace prefix for the element</p>
</dd>
<dt>current_ns_prefixes</dt>
<dd>
<p>Return a list of namespace prefixes valid for the element. The order
of the prefixes in the list has no meaning. If the default namespace is
currently bound, '' appears in the list.</p>
</dd>
<dt>inherit_att ($att, @optional_tag_list)</dt>
<dd>
<p>Return the value of an attribute inherited from parent tags. The
value returned is found by looking for the attribute in the element then
in turn in each of its ancestors. If the <code>@optional_tag_list</code>
is supplied only those ancestors whose tag is in the list will be
checked.</p>
</dd>
<dt>all_children_are ($optional_condition)</dt>
<dd>
<p>return 1 if all children of the element pass the
<code>$optional_condition</code>, 0 otherwise</p>
</dd>
<dt>level ($optional_condition)</dt>
<dd>
<p>Return the depth of the element in the twig (root is 0). If
<code>$optional_condition</code> is given then only ancestors that match
the condition are counted. <strong>WARNING</strong>: in a tree created
using the <code>twig_roots</code> option this will not return the level
in the document tree, level 0 will be the document root, level 1 will be
the <code>twig_roots</code> elements. During the parsing (in a
<code>twig_handler</code>) you can use the <code>depth</code> method on
the twig object to get the real parsing depth.</p>
</dd>
<dt>in ($potential_parent)</dt>
<dd>
<p>Return true if the element is in the potential_parent
(<code>$potential_parent</code> is an element)</p>
</dd>
<dt>in_context ($cond, $optional_level)</dt>
<dd>
<p>Return true if the element is included in an element which passes
<code>$cond</code> optionally within <code>$optional_level</code>
levels. The returned value is the including element.</p>
</dd>
<dt>pcdata</dt>
<dd>
<p>Return the text of a <code>PCDATA</code> element or
<code>undef</code> if the element is not <code>PCDATA</code>.</p>
</dd>
<dt>pcdata_xml_string</dt>
<dd>
<p>Return the text of a <code>PCDATA</code> element or undef if the
element is not <code>PCDATA</code>. The text is XML-escaped ('&amp;' and
'&lt;' are replaced by '&amp;amp;' and '&amp;lt;')</p>
</dd>
<dt>set_pcdata ($text)</dt>
<dd>
<p>Set the text of a <code>PCDATA</code> element. This method does not
check that the element is indeed a <code>PCDATA</code> so usually you
should use <code>set_text</code> instead.</p>
</dd>
<dt>append_pcdata ($text)</dt>
<dd>
<p>Add the text at the end of a <code>PCDATA</code> element.</p>
</dd>
<dt>is_cdata</dt>
<dd>
<p>Return 1 if the element is a <code>CDATA</code> element, returns 0
otherwise.</p>
</dd>
<dt>is_text</dt>
<dd>
<p>Return 1 if the element is a <code>CDATA</code> or
<code>PCDATA</code> element, returns 0 otherwise.</p>
</dd>
<dt>cdata</dt>
<dd>
<p>Return the text of a <code>CDATA</code> element or <code>undef</code>
if the element is not <code>CDATA</code>.</p>
</dd>
<dt>cdata_string</dt>
<dd>
<p>Return the XML string of a <code>CDATA</code> element, including the
opening and closing markers.</p>
</dd>
<dt>set_cdata ($text)</dt>
<dd>
<p>Set the text of a <code>CDATA</code> element.</p>
</dd>
<dt>append_cdata ($text)</dt>
<dd>
<p>Add the text at the end of a <code>CDATA</code> element.</p>
</dd>
<dt>remove_cdata</dt>
<dd>
<p>Turns all <code>CDATA</code> sections in the element into regular
<code>PCDATA</code> elements. This is useful when converting XML to
HTML, as browsers do not support CDATA sections.</p>
</dd>
<dt>extra_data</dt>
<dd>
<p>Return the extra_data (comments and PI's) attached to an element</p>
</dd>
<dt>set_extra_data ($extra_data)</dt>
<dd>
<p>Set the extra_data (comments and PI's) attached to an element</p>
</dd>
<dt>append_extra_data ($extra_data)</dt>
<dd>
<p>Append extra_data to the existing extra_data before the element (if
no previous extra_data exists then it is created)</p>
</dd>
<dt>set_asis</dt>
<dd>
<p>Set a property of the element that causes it to be output without
being XML escaped by the print functions: if it contains
<code>a &lt; b</code> it will be output as such and not as
<code>a &amp;lt; b</code>. This can be useful to create text elements
that will be output as markup. Note that all <code>PCDATA</code>
descendants of the element are also marked as having the property (they
are the ones that are actually impacted by the change). If the element
is a <code>CDATA</code> element it will also be output asis, without the
<code>CDATA</code> markers. The same goes for any <code>CDATA</code>
descendant of the element</p>
</dd>
<dt>set_not_asis</dt>
<dd>
<p>Unsets the <code>asis</code> property for the element and its text
descendants.</p>
</dd>
<dt>is_asis</dt>
<dd>
<p>Return the <code>asis</code> property status of the element ( 1 or
<code>undef</code>)</p>
</dd>
<dt>closed</dt>
<dd>
<p>Return true if the element has been closed. Might be useful if you
are somewhere in the tree, during the parse, and have no idea whether a
parent element is completely loaded or not.</p>
</dd>
<dt>get_type</dt>
<dd>
<p>Return the type of the element: '<code>#ELT</code>' for real
elements, or '<code>#PCDATA</code>', '<code>#CDATA</code>',
'<code>#COMMENT</code>', '<code>#ENT</code>', '<code>#PI</code>'</p>
</dd>
<dt>is_elt</dt>
<dd>
<p>Return the tag if the element is a real element, or 0 if it is
<code>PCDATA</code>, <code>CDATA</code>...</p>
</dd>
<dt>contains_only_text</dt>
<dd>
<p>Return 1 if the element does not contain any other real element</p>
</dd>
<dt>contains_only ($exp)</dt>
<dd>
<p>Return the list of children if all children of the element match the
expression <code>$exp</code> if( $para-&gt;contains_only( tt)) { ...
}</p>
</dd>
<dt>contains_a_single ($exp)</dt>
<dd>
<p>If the element contains a single child that matches the expression
<code>$exp</code> returns that element. Otherwise returns 0.</p>
</dd>
<dt>is_field</dt>
<dd>
<p>same as <code>contains_only_text</code></p>
</dd>
<dt>is_pcdata</dt>
<dd>
<p>Return 1 if the element is a <code>PCDATA</code> element, returns 0
otherwise.</p>
</dd>
<dt>is_ent</dt>
<dd>
<p>Return 1 if the element is an entity (an unexpanded entity) element,
return 0 otherwise.</p>
</dd>
<dt>is_empty</dt>
<dd>
<p>Return 1 if the element is empty, 0 otherwise</p>
</dd>
<dt>set_empty</dt>
<dd>
<p>Flags the element as empty. No further check is made, so if the
element is actually not empty the output will be messed. The only effect
of this method is that the output will be
<code>&lt;tag att="value""/&gt;</code>.</p>
</dd>
<dt>set_not_empty</dt>
<dd>
<p>Flags the element as not empty. if it is actually empty then the
element will be output as
<code>&lt;tag att="value""&gt;&lt;/tag&gt;</code></p>
</dd>
<dt>is_pi</dt>
<dd>
<p>Return 1 if the element is a processing instruction
(<code>#PI</code>) element, return 0 otherwise.</p>
</dd>
<dt>target</dt>
<dd>
<p>Return the target of a processing instruction</p>
</dd>
<dt>set_target ($target)</dt>
<dd>
<p>Set the target of a processing instruction</p>
</dd>
<dt>data</dt>
<dd>
<p>Return the data part of a processing instruction</p>
</dd>
<dt>set_data ($data)</dt>
<dd>
<p>Set the data of a processing instruction</p>
</dd>
<dt>set_pi ($target, $data)</dt>
<dd>
<p>Set the target and data of a processing instruction</p>
</dd>
<dt>pi_string</dt>
<dd>
<p>Return the string form of a processing instruction
(<code>&lt;?target data?&gt;</code>)</p>
</dd>
<dt>is_comment</dt>
<dd>
<p>Return 1 if the element is a comment (<code>#COMMENT</code>) element,
return 0 otherwise.</p>
</dd>
<dt>set_comment ($comment_text)</dt>
<dd>
<p>Set the text for a comment</p>
</dd>
<dt>comment</dt>
<dd>
<p>Return the content of a comment (just the text, not the
<code>&lt;!--</code> and <code>--&gt;</code>)</p>
</dd>
<dt>comment_string</dt>
<dd>
<p>Return the XML string for a comment
(<code>&lt;!-- comment --&gt;</code>) Note that an XML comment cannot
start or end with a '-', or include '--'
(http://www.w3.org/TR/2008/REC-xml-20081126/#sec-comments), if that is
the case (because you have created the comment yourself presumably, as
it could not be in the input XML), then a space will be inserted before
an initial '-', after a trailing one or between two '-' in the comment
(which could presumably mangle javascript hidden in an XHTML
comment);</p>
</dd>
<dt>set_ent ($entity)</dt>
<dd>
<p>Set an (non-expanded) entity (<code>#ENT</code>).
<code>$entity</code>) is the entity text (<code>&amp;ent;</code>)</p>
</dd>
<dt>ent</dt>
<dd>
<p>Return the entity for an entity (<code>#ENT</code>) element
(<code>&amp;ent;</code>)</p>
</dd>
<dt>ent_name</dt>
<dd>
<p>Return the entity name for an entity (<code>#ENT</code>) element
(<code>ent</code>)</p>
</dd>
<dt>ent_string</dt>
<dd>
<p>Return the entity, either expanded if the expanded version is
available, or non-expanded (<code>&amp;ent;</code>) otherwise</p>
</dd>
<dt>child ($offset, $optional_condition)</dt>
<dd>
<p>Return the <code>$offset</code>-th child of the element, optionally
the <code>$offset</code>-th child that matches
<code>$optional_condition</code>. The children are treated as a list, so
<code>$elt-&gt;child( 0)</code> is the first child, while
<code>$elt-&gt;child( -1)</code> is the last child.</p>
</dd>
<dt>child_text ($offset, $optional_condition)</dt>
<dd>
<p>Return the text of a child or <code>undef</code> if the sibling does
not exist. Arguments are the same as child.</p>
</dd>
<dt>last_child ($optional_condition)</dt>
<dd>
<p>Return the last child of the element, or the last child matching
<code>$optional_condition</code> (ie the last of the element children
matching the condition).</p>
</dd>
<dt>last_child_text ($optional_condition)</dt>
<dd>
<p>Same as <code>first_child_text</code> but for the last child.</p>
</dd>
<dt>sibling ($offset, $optional_condition)</dt>
<dd>
<p>Return the next or previous <code>$offset</code>-th sibling of the
element, or the <code>$offset</code>-th one matching
<code>$optional_condition</code>. If <code>$offset</code> is negative
then a previous sibling is returned, if <code>$offset</code> is positive
then a next sibling is returned. <code>$offset=0</code> returns the
element if there is no condition or if the element matches the
condition&gt;, <code>undef</code> otherwise.</p>
</dd>
<dt>sibling_text ($offset, $optional_condition)</dt>
<dd>
<p>Return the text of a sibling or <code>undef</code> if the sibling
does not exist. Arguments are the same as <code>sibling</code>.</p>
</dd>
<dt>prev_siblings ($optional_condition)</dt>
<dd>
<p>Return the list of previous siblings (optionally matching
<code>$optional_condition</code>) for the element. The elements are
ordered in document order.</p>
</dd>
<dt>next_siblings ($optional_condition)</dt>
<dd>
<p>Return the list of siblings (optionally matching
<code>$optional_condition</code>) following the element. The elements
are ordered in document order.</p>
</dd>
<dt>siblings ($optional_condition)</dt>
<dd>
<p>Return the list of siblings (optionally matching
<code>$optional_condition</code>) of the element (excluding the element
itself). The elements are ordered in document order.</p>
</dd>
<dt>pos ($optional_condition)</dt>
<dd>
<p>Return the position of the element in the children list. The first
child has a position of 1 (as in XPath). If the
<code>$optional_condition</code> is given then only siblings that match
the condition are counted. If the element itself does not match the
condition then 0 is returned.</p>
</dd>
<dt>atts</dt>
<dd>
<p>Return a hash ref containing the element attributes</p>
</dd>
<dt>set_atts ({ att1=&gt;$att1_val, att2=&gt; $att2_val... })</dt>
<dd>
<p>Set the element attributes with the hash ref supplied as the
argument. The previous attributes are lost (ie the attributes set by
<code>set_atts</code> replace all of the attributes of the element). You
can also pass a list instead of a hashref:
<code>$elt-&gt;set_atts( att1 =&gt; val1,...)</code></p>
</dd>
<dt>del_atts</dt>
<dd>
<p>Deletes all the element attributes.</p>
</dd>
<dt>att_nb</dt>
<dd>
<p>Return the number of attributes for the element</p>
</dd>
<dt>has_atts</dt>
<dd>
<p>Return true if the element has attributes (in fact return the number
of attributes, thus being an alias to <code>att_nb</code></p>
</dd>
<dt>has_no_atts</dt>
<dd>
<p>Return true if the element has no attributes, false (0) otherwise</p>
</dd>
<dt>att_names</dt>
<dd>
<p>return a list of the attribute names for the element</p>
</dd>
<dt>att_xml_string ($att, $options)</dt>
<dd>
<p>Return the attribute value, where '&amp;', '&lt;' and quote (" or the
value of the quote option at twig creation) are XML-escaped. The options
are passed as a hashref, setting <code>escape_gt</code> to a true value
will also escape '&gt;' ($elt( 'myatt', { escape_gt =&gt; 1 });</p>
</dd>
<dt>set_id ($id)</dt>
<dd>
<p>Set the <code>id</code> attribute of the element to the value. See
<code>elt_id </code> to change the id attribute name</p>
</dd>
<dt>id</dt>
<dd>
<p>Gets the id attribute value</p>
</dd>
<dt>del_id ($id)</dt>
<dd>
<p>Deletes the <code>id</code> attribute of the element and remove it
from the id list for the document</p>
</dd>
<dt>class</dt>
<dd>
<p>Return the <code>class</code> attribute for the element (methods on
the <code>class</code> attribute are quite convenient when dealing with
XHTML, or plain XML that will eventually be displayed using CSS)</p>
</dd>
<dt>lclass</dt>
<dd>
<p>same as class, except that this method is an lvalue, so you can do
<code>$elt-&gt;lclass= "foo"</code></p>
</dd>
<dt>set_class ($class)</dt>
<dd>
<p>Set the <code>class</code> attribute for the element to
<code>$class</code></p>
</dd>
<dt>add_class ($class)</dt>
<dd>
<p>Add <code>$class</code> to the element <code>class</code> attribute:
the new class is added only if it is not already present. Note that
classes are then sorted alphabetically, so the <code>class</code>
attribute can be changed even if the class is already there</p>
</dd>
<dt>remove_class ($class)</dt>
<dd>
<p>Remove <code>$class</code> from the element <code>class</code>
attribute. Note that classes are then sorted alphabetically, so the
<code>class</code> attribute can be changed even if the class is already
there</p>
</dd>
<dt>add_to_class ($class)</dt>
<dd>
<p>alias for add_class</p>
</dd>
<dt>att_to_class ($att)</dt>
<dd>
<p>Set the <code>class</code> attribute to the value of attribute
<code>$att</code></p>
</dd>
<dt>add_att_to_class ($att)</dt>
<dd>
<p>Add the value of attribute <code>$att</code> to the
<code>class</code> attribute of the element</p>
</dd>
<dt>move_att_to_class ($att)</dt>
<dd>
<p>Add the value of attribute <code>$att</code> to the
<code>class</code> attribute of the element and delete the attribute</p>
</dd>
<dt>tag_to_class</dt>
<dd>
<p>Set the <code>class</code> attribute of the element to the element
tag</p>
</dd>
<dt>add_tag_to_class</dt>
<dd>
<p>Add the element tag to its <code>class</code> attribute</p>
</dd>
<dt>set_tag_class ($new_tag)</dt>
<dd>
<p>Add the element tag to its <code>class</code> attribute and sets the
tag to <code>$new_tag</code></p>
</dd>
<dt>in_class ($class)</dt>
<dd>
<p>Return true (<code>1</code>) if the element is in the class
<code>$class</code> (if <code>$class</code> is one of the tokens in the
element <code>class</code> attribute)</p>
</dd>
<dt>tag_to_span</dt>
<dd>
<p>Change the element tag tp <code>span</code> and set its class to the
old tag</p>
</dd>
<dt>tag_to_div</dt>
<dd>
<p>Change the element tag tp <code>div</code> and set its class to the
old tag</p>
</dd>
<dt>DESTROY</dt>
<dd>
<p>Frees the element from memory.</p>
</dd>
<dt>start_tag</dt>
<dd>
<p>Return the string for the start tag for the element, including the
<code>/&gt;</code> at the end of an empty element tag</p>
</dd>
<dt>end_tag</dt>
<dd>
<p>Return the string for the end tag of an element. For an empty
element, this returns the empty string ('').</p>
</dd>
<dt>xml_string @optional_options</dt>
<dd>
<p>Equivalent to <code>$elt-&gt;sprint( 1)</code>, returns the string
for the entire element, excluding the element's tags (but nested element
tags are present) The '<code>no_recurse</code>' option will only return
the text of the element, not of any included sub-elements (same as
<code>xml_text_only</code>).</p>
</dd>
<dt>inner_xml</dt>
<dd>
<p>Another synonym for xml_string</p>
</dd>
<dt>outer_xml</dt>
<dd>
<p>Another synonym for sprint</p>
</dd>
<dt>xml_text</dt>
<dd>
<p>Return the text of the element, encoded (and processed by the current
<code>output_filter</code> or <code>output_encoding</code> options,
without any tag.</p>
</dd>
<dt>xml_text_only</dt>
<dd>
<p>Same as <code>xml_text</code> except that the text returned doesn't
include the text of sub-elements.</p>
</dd>
<dt>set_pretty_print ($style)</dt>
<dd>
<p>Set the pretty print method, amongst '<code>none</code>' (default),
'<code>nsgmls</code>', '<code>nice</code>', '<code>indented</code>',
'<code>record</code>' and '<code>record_c</code>' pretty_print
styles:</p>
<dl>
<dt>none</dt>
<dd>
<p>the default, no <code>\n</code> is used</p>
</dd>
<dt>nsgmls</dt>
<dd>
<p>nsgmls style, with <code>\n</code> added within tags</p>
</dd>
<dt>nice</dt>
<dd>
<p>adds <code>\n</code> wherever possible (NOT SAFE, can lead to invalid
XML)</p>
</dd>
<dt>indented</dt>
<dd>
<p>same as <code>nice</code> plus indents elements (NOT SAFE, can lead
to invalid XML)</p>
</dd>
<dt>record</dt>
<dd>
<p>table-oriented pretty print, one field per line</p>
</dd>
<dt>record_c</dt>
<dd>
<p>table-oriented pretty print, more compact than <code>record</code>,
one record per line</p>
</dd>
</dl>
</dd>
<dt>set_empty_tag_style ($style)</dt>
<dd>
<p>Set the method to output empty tags, amongst '<code>normal</code>'
(default), '<code>html</code>', and '<code>expand</code>',
<code>normal</code> outputs an empty tag '<code>&lt;tag/&gt;</code>',
<code>html</code> adds a space '<code>&lt;tag /&gt;</code>' for elements
that can be empty in XHTML and <code>expand</code> outputs
'<code>&lt;tag&gt;&lt;/tag&gt;</code>'</p>
</dd>
<dt>set_remove_cdata ($flag)</dt>
<dd>
<p>set (or unset) the flag that forces the twig to output CDATA sections
as regular (escaped) PCDATA</p>
</dd>
<dt>set_indent ($string)</dt>
<dd>
<p>Set the indentation for the indented pretty print style (default is 2
spaces)</p>
</dd>
<dt>set_quote ($quote)</dt>
<dd>
<p>Set the quotes used for attributes. can be '<code>double</code>'
(default) or '<code>single</code>'</p>
</dd>
<dt>cmp ($elt)</dt>
<dd>
<p> Compare the order of the 2 elements in a twig. C&lt;$a&gt; is the
&lt;A&gt;..&lt;/A&gt; element, C&lt;$b&gt; is the &lt;B&gt;...&lt;/B&gt;
element document $a-&gt;cmp( $b) &lt;A&gt; ... &lt;/A&gt; ... &lt;B&gt;
... &lt;/B&gt; -1 &lt;A&gt; ... &lt;B&gt; ... &lt;/B&gt; ... &lt;/A&gt;
-1 &lt;B&gt; ... &lt;/B&gt; ... &lt;A&gt; ... &lt;/A&gt; 1 &lt;B&gt; ...
&lt;A&gt; ... &lt;/A&gt; ... &lt;/B&gt; 1 $a == $b 0 $a and $b not in
the same tree undef</p>
</dd>
<dt>before ($elt)</dt>
<dd>
<p>Return 1 if <code>$elt</code> starts before the element, 0 otherwise.
If the 2 elements are not in the same twig then return
<code>undef</code>. if( $a-&gt;cmp( $b) == -1) { return 1; } else {
return 0; }</p>
</dd>
<dt>after ($elt)</dt>
<dd>
<p>Return 1 if <code>$elt</code> starts after the element, 0 otherwise.
If the 2 elements are not in the same twig then return
<code>undef</code>. if( $a-&gt;cmp( $b) == -1) { return 1; } else {
return 0; }</p>
</dd>
<dt>other comparison methods</dt>
<dd>
<dl>
<dt>lt</dt>
<dd>

</dd>
<dt>le</dt>
<dd>

</dd>
<dt>gt</dt>
<dd>

</dd>
<dt>ge</dt>
<dd>

</dd>
</dl>
</dd>
<dt>path</dt>
<dd>

</dd>
</dl>
<p>Return the element context in a form similar to XPath's short form:
'<code>/root/tag1/../tag</code>'</p>
<dl>
<dt>xpath</dt>
<dd>
<p>Return a unique XPath expression that can be used to find the element
again. It looks like <code>/doc/sect[3]/title</code>: unique elements do
not have an index, the others do.</p>
</dd>
<dt>flush</dt>
<dd>
<p>flushes the twig up to the current element (strictly equivalent to
<code>$elt-&gt;root-&gt;flush</code>)</p>
</dd>
<dt>private methods</dt>
<dd>
<p>Low-level methods on the twig:</p>
<dl>
<dt>set_parent ($parent)</dt>
<dd>

</dd>
</dl>
<dl>
<dt>set_first_child ($first_child)</dt>
<dd>

</dd>
<dt>set_last_child ($last_child)</dt>
<dd>

</dd>
<dt>set_prev_sibling ($prev_sibling)</dt>
<dd>

</dd>
<dt>set_next_sibling ($next_sibling)</dt>
<dd>

</dd>
<dt>set_twig_current</dt>
<dd>

</dd>
<dt>del_twig_current</dt>
<dd>

</dd>
<dt>twig_current</dt>
<dd>

</dd>
<dt>contains_text</dt>
<dd>

</dd>
</dl>
<p>Those methods should not be used, unless of course you find some
creative and interesting, not to mention useful, ways to do it.</p>
</dd>
</dl>
<h2>cond</h2>
<p>Most of the navigation functions accept a condition as an optional
argument The first element (or all elements for <code>children </code>
or <code>ancestors </code>) that passes the condition is returned.</p>
<p>The condition is a single step of an XPath expression using the XPath
subset defined by <code>get_xpath</code>. Additional conditions are:</p>
<p>The condition can be</p>
<dl>
<dt>#ELT</dt>
<dd>
<p>return a real element (not a PCDATA, CDATA, comment or pi
element)</p>
</dd>
<dt>#TEXT</dt>
<dd>
<p>return a PCDATA or CDATA element</p>
</dd>
<dt>regular expression</dt>
<dd>
<p>return an element whose tag matches the regexp. The regexp has to be
created with <code>qr//</code> (hence this is available only on perl
5.005 and above)</p>
</dd>
<dt>code reference</dt>
<dd>
<p>applies the code, passing the current element as argument, if the
code returns true then the element is returned, if it returns false then
the code is applied to the next candidate.</p>
</dd>
</dl>
<h2>XML::Twig::XPath</h2>
<p>XML::Twig implements a subset of XPath through the
<code>get_xpath</code> method.</p>
<p>If you want to use the whole XPath power, then you can use
<code>XML::Twig::XPath</code> instead. In this case
<code>XML::Twig</code> uses <code>XML::XPath</code> to execute XPath
queries. You will of course need <code>XML::XPath</code> installed to be
able to use <code>XML::Twig::XPath</code>.</p>
<p>See XML::XPath for more information.</p>
<p>The methods you can use are:</p>
<dl>
<dt>findnodes ($path)</dt>
<dd>
<p>return a list of nodes found by <code>$path</code>.</p>
</dd>
<dt>findnodes_as_string ($path)</dt>
<dd>
<p>return the nodes found reproduced as XML. The result is not
guaranteed to be valid XML though.</p>
</dd>
<dt>findvalue ($path)</dt>
<dd>
<p>return the concatenation of the text content of the result nodes</p>
</dd>
</dl>
<p>In order for <code>XML::XPath</code> to be used as the XPath engine
the following methods are included in <code>XML::Twig</code>:</p>
<p>in XML::Twig</p>
<dl>
<dt>getRootNode</dt>
<dd>

</dd>
</dl>
<dl>
<dt>getParentNode</dt>
<dd>

</dd>
<dt>getChildNodes</dt>
<dd>

</dd>
</dl>
<p>in XML::Twig::Elt</p>
<dl>
<dt>string_value</dt>
<dd>

</dd>
</dl>
<dl>
<dt>toString</dt>
<dd>

</dd>
<dt>getName</dt>
<dd>

</dd>
<dt>getRootNode</dt>
<dd>

</dd>
<dt>getNextSibling</dt>
<dd>

</dd>
<dt>getPreviousSibling</dt>
<dd>

</dd>
<dt>isElementNode</dt>
<dd>

</dd>
<dt>isTextNode</dt>
<dd>

</dd>
<dt>isPI</dt>
<dd>

</dd>
<dt>isPINode</dt>
<dd>

</dd>
<dt>isProcessingInstructionNode</dt>
<dd>

</dd>
<dt>isComment</dt>
<dd>

</dd>
<dt>isCommentNode</dt>
<dd>

</dd>
<dt>getTarget</dt>
<dd>

</dd>
<dt>getChildNodes</dt>
<dd>

</dd>
<dt>getElementById</dt>
<dd>

</dd>
</dl>
<h2>XML::Twig::XPath::Elt</h2>
<p>The methods you can use are the same as on
<code>XML::Twig::XPath</code> elements:</p>
<dl>
<dt>findnodes ($path)</dt>
<dd>
<p>return a list of nodes found by <code>$path</code>.</p>
</dd>
<dt>findnodes_as_string ($path)</dt>
<dd>
<p>return the nodes found reproduced as XML. The result is not
guaranteed to be valid XML though.</p>
</dd>
<dt>findvalue ($path)</dt>
<dd>
<p>return the concatenation of the text content of the result nodes</p>
</dd>
</dl>
<h2>XML::Twig::Entity_list</h2>
<dl>
<dt>new</dt>
<dd>
<p>Create an entity list.</p>
</dd>
<dt>add ($ent)</dt>
<dd>
<p>Add an entity to an entity list.</p>
</dd>
<dt>add_new_ent ($name, $val, $sysid, $pubid, $ndata, $param)</dt>
<dd>
<p>Create a new entity and add it to the entity list</p>
</dd>
<dt>delete ($ent or $tag).</dt>
<dd>
<p>Delete an entity (defined by its name or by the Entity object) from
the list.</p>
</dd>
<dt>print ($optional_filehandle)</dt>
<dd>
<p>Print the entity list.</p>
</dd>
<dt>list</dt>
<dd>
<p>Return the list as an array</p>
</dd>
</dl>
<h2>XML::Twig::Entity</h2>
<dl>
<dt>new ($name, $val, $sysid, $pubid, $ndata, $param)</dt>
<dd>
<p>Same arguments as the Entity handler for XML::Parser.</p>
</dd>
<dt>print ($optional_filehandle)</dt>
<dd>
<p>Print an entity declaration.</p>
</dd>
<dt>name</dt>
<dd>
<p>Return the name of the entity</p>
</dd>
<dt>val</dt>
<dd>
<p>Return the value of the entity</p>
</dd>
<dt>sysid</dt>
<dd>
<p>Return the system id for the entity (for NDATA entities)</p>
</dd>
<dt>pubid</dt>
<dd>
<p>Return the public id for the entity (for NDATA entities)</p>
</dd>
<dt>ndata</dt>
<dd>
<p>Return true if the entity is an NDATA entity</p>
</dd>
<dt>param</dt>
<dd>
<p>Return true if the entity is a parameter entity</p>
</dd>
<dt>text</dt>
<dd>
<p>Return the entity declaration text.</p>
</dd>
</dl>
<h2>XML::Twig::Notation_list</h2>
<dl>
<dt>new</dt>
<dd>
<p>Create an notation list.</p>
</dd>
<dt>add ($notation)</dt>
<dd>
<p>Add an notation to an notation list.</p>
</dd>
<dt>add_new_notation ($name, $base, $sysid, $pubid)</dt>
<dd>
<p>Create a new notation and add it to the notation list</p>
</dd>
<dt>delete ($notation or $tag).</dt>
<dd>
<p>Delete an notation (defined by its name or by the Notation object)
from the list.</p>
</dd>
<dt>print ($optional_filehandle)</dt>
<dd>
<p>Print the notation list.</p>
</dd>
<dt>list</dt>
<dd>
<p>Return the list as an array</p>
</dd>
</dl>
<h2>XML::Twig::Notation</h2>
<dl>
<dt>new ($name, $base, $sysid, $pubid)</dt>
<dd>
<p>Same argumnotations as the Notation handler for XML::Parser.</p>
</dd>
<dt>print ($optional_filehandle)</dt>
<dd>
<p>Print an notation declaration.</p>
</dd>
<dt>name</dt>
<dd>
<p>Return the name of the notation</p>
</dd>
<dt>base</dt>
<dd>
<p>Return the base to be used for resolving a relative URI</p>
</dd>
<dt>sysid</dt>
<dd>
<p>Return the system id for the notation</p>
</dd>
<dt>pubid</dt>
<dd>
<p>Return the public id for the notation</p>
</dd>
<dt>text</dt>
<dd>
<p>Return the notation declaration text.</p>
</dd>
</dl>
<h1>EXAMPLES</h1>
<p>Additional examples (and a complete tutorial) can be found on the
<em>XML::Twig Page&lt;http://www.xmltwig.org/xmltwig/&gt;</em></p>
<p>To figure out what flush does call the following script with an XML
file and an element name as arguments</p>
<p>use XML::Twig; my ($file, $elt)= @ARGV; my $t= XML::Twig-&gt;new(
twig_handlers =&gt; { $elt =&gt; sub {$_[0]-&gt;flush; print "\n[flushed
here]\n";} }); $t-&gt;parsefile( $file, ErrorContext =&gt; 2);
$t-&gt;flush; print "\n";</p>
<h1>NOTES</h1>
<h2>Subclassing XML::Twig</h2>
<p>Useful methods:</p>
<dl>
<dt>elt_class</dt>
<dd>
<p>In order to subclass <code>XML::Twig</code> you will probably need to
subclass also <code>XML::Twig::Elt</code>. Use the
<code>elt_class</code> option when you create the <code>XML::Twig</code>
object to get the elements created in a different class (which should be
a subclass of <code>XML::Twig::Elt</code>.</p>
</dd>
<dt>add_options</dt>
<dd>
<p>If you inherit <code>XML::Twig</code> new method but want to add more
options to it you can use this method to prevent XML::Twig to issue
warnings for those additional options.</p>
</dd>
</dl>
<h2>DTD Handling</h2>
<p>There are 3 possibilities here. They are:</p>
<dl>
<dt>No DTD</dt>
<dd>
<p>No doctype, no DTD information, no entity information, the world is
simple...</p>
</dd>
<dt>Internal DTD</dt>
<dd>
<p>The XML document includes an internal DTD, and maybe entity
declarations. If you use the load_DTD option when creating the twig the
DTD information and the entity declarations can be accessed. The DTD and
the entity declarations will be <code>flush</code>'ed (or
<code>print</code>'ed) either as is (if they have not been modified) or
as reconstructed (poorly, comments are lost, order is not kept, due to
it's content this DTD should not be viewed by anyone) if they have been
modified. You can also modify them directly by changing the
<code>$twig-&gt;{twig_doctype}-&gt;{internal}</code> field (straight
from XML::Parser, see the <code>Doctype</code> handler doc)</p>
</dd>
<dt>External DTD</dt>
<dd>
<p>The XML document includes a reference to an external DTD, and maybe
entity declarations. If you use the <code>load_DTD</code> when creating
the twig the DTD information and the entity declarations can be
accessed. The entity declarations will be <code>flush</code>'ed (or
<code>print</code>'ed) either as is (if they have not been modified) or
as reconstructed (badly, comments are lost, order is not kept). You can
change the doctype through the <code>$twig-&gt;set_doctype</code> method
and print the dtd through the <code>$twig-&gt;dtd_text</code> or
<code>$twig-&gt;dtd_print</code> methods. If you need to modify the
entity list this is probably the easiest way to do it.</p>
</dd>
</dl>
<h2>Flush</h2>
<p>Remember that element handlers are called when the element is CLOSED,
so if you have handlers for nested elements the inner handlers will be
called first. It makes it for example trickier than it would seem to
number nested sections (or clauses, or divs), as the titles in the inner
sections are handled before the outer sections.</p>
<h1>BUGS</h1>
<dl>
<dt>segfault during parsing</dt>
<dd>
<p>This happens when parsing huge documents, or lots of small ones, with
a version of Perl before 5.16. This is due to a bug in the way weak
references are handled in Perl itself. The fix is either to upgrade to
Perl 5.16 or later (<code>perlbrew</code> is a great tool to manage
several installations of perl on the same machine). Another, NOT
RECOMMENDED, way of fixing the problem, is to switch off weak references
by writing <code>XML::Twig::_set_weakrefs( 0);</code> at the top of the
code. This is totally unsupported, and may lead to other problems
though,</p>
</dd>
<dt>entity handling</dt>
<dd>
<p>Due to XML::Parser behaviour, non-base entities in attribute values
disappear if they are not declared in the document:
<code>att="val&amp;ent;"</code> will be turned into
<code>att =&gt; val</code>, unless you use the
<code>keep_encoding</code> argument to
<code>XML::Twig-&gt;new</code></p>
</dd>
<dt>DTD handling</dt>
<dd>
<p>The DTD handling methods are quite bugged. No one uses them and it
seems very difficult to get them to work in all cases, including with
several slightly incompatible versions of XML::Parser and of libexpat.
Basically you can read the DTD, output it back properly, and update
entities, but not much more. So use XML::Twig with standalone documents,
or with documents referring to an external DTD, but don't expect it to
properly parse and even output back the DTD.</p>
</dd>
<dt>memory leak</dt>
<dd>
<p>If you use a REALLY old Perl (5.005!) and a lot of twigs you might
find that you leak quite a lot of memory (about 2Ks per twig). You can
use the <code>dispose </code> method to free that memory after you are
done. If you create elements the same thing might happen, use the
<code>delete</code> method to get rid of them. Alternatively installing
the <code>Scalar::Util</code> (or <code>WeakRef</code>) module on a
version of Perl that supports it (&gt;5.6.0) will get rid of the memory
leaks automagically.</p>
</dd>
<dt>ID list</dt>
<dd>
<p>The ID list is NOT updated when elements are cut or deleted.</p>
</dd>
<dt>change_gi</dt>
<dd>
<p>This method will not function properly if you do:
$twig-&gt;change_gi( $old1, $new); $twig-&gt;change_gi( $old2, $new);
$twig-&gt;change_gi( $new, $even_newer);</p>
</dd>
<dt>sanity check on XML::Parser method calls</dt>
<dd>
<p>XML::Twig should really prevent calls to some XML::Parser methods,
especially the <code>setHandlers</code> method.</p>
</dd>
<dt>pretty printing</dt>
<dd>
<p>Pretty printing (at least using the '<code>indented</code>' style) is
hard to get right! Only elements that belong to the document will be
properly indented. Printing elements that do not belong to the twig
makes it impossible for XML::Twig to figure out their depth, and thus
their indentation level. Also there is an unavoidable bug when using
<code>flush</code> and pretty printing for elements with mixed content
that start with an embedded element:
&lt;elt&gt;&lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt;
will be output as &lt;elt&gt;
&lt;b&gt;b&lt;/b&gt;toto&lt;b&gt;bold&lt;/b&gt;&lt;/elt&gt; if you flush
the twig when you find the <code>&lt;b&gt;</code> element</p>
</dd>
</dl>
<h1>Globals</h1>
<p>These are the things that can mess up calling code, especially if
threaded. They might also cause problem under mod_perl.</p>
<dl>
<dt>Exported constants</dt>
<dd>
<p>Whether you want them or not you get them! These are subroutines to
use as constant when creating or testing elements PCDATA return #PCDATA
CDATA return #CDATA PI return #PI, I had the choice between PROC and PI
:--(</p>
</dd>
<dt>Module scoped values: constants</dt>
<dd>
<p>these should cause no trouble: %base_ent= ( &gt; =&gt; &amp;gt;, &lt;
=&gt; &amp;lt;, &amp; =&gt; &amp;amp;, "" =&gt; &amp;apos;, " =&gt;
&amp;quot;, ); CDATA_START = "&lt;![CDATA["; CDATA_END = "]]&gt;";
PI_START = "&lt;?"; PI_END = "?&gt;"; COMMENT_START = "&lt;!--";
COMMENT_END = "--&gt;"; pretty print styles ( $NSGMLS, $NICE, $INDENTED,
$INDENTED_C, $WRAPPED, $RECORD1, $RECORD2)= (1..7); empty tag output
style ( $HTML, $EXPAND)= (1..2);</p>
</dd>
<dt>Module scoped values: might be changed</dt>
<dd>
<p>Most of these deal with pretty printing, so the worst that can happen
is probably that XML output does not look right, but is still valid and
processed identically by XML processors. <code>$empty_tag_style</code>
can mess up HTML bowsers though and changing <code>$ID</code> would most
likely create problems. $pretty=0; # pretty print style $quote="; #
quote for attributes $INDENT= ; # indent for indented pretty print
$empty_tag_style= 0; # how to display empty tags $ID # attribute used as
an id (id by default)</p>
</dd>
<dt>Module scoped values: definitely changed</dt>
<dd>
<p>These 2 variables are used to replace tags by an index, thus saving
some space when creating a twig. If they really cause you too much
trouble, let me know, it is probably possible to create either a switch
or at least a version of XML::Twig that does not perform this
optimization. %gi2index; # tag =&gt; index @index2gi; # list of tags</p>
</dd>
</dl>
<p>If you need to manipulate all those values, you can use the following
methods on the XML::Twig object:</p>
<dl>
<dt>global_state</dt>
<dd>
<p>Return a hashref with all the global variables used by XML::Twig The
hash has the following fields: <code>pretty</code>, <code>quote</code>,
<code>indent</code>, <code>empty_tag_style</code>,
<code>keep_encoding</code>, <code>expand_external_entities</code>,
<code>output_filter</code>, <code>output_text_filter</code>,
<code>keep_atts_order</code></p>
</dd>
<dt>set_global_state ($state)</dt>
<dd>
<p>Set the global state, <code>$state</code> is a hashref</p>
</dd>
<dt>save_global_state</dt>
<dd>
<p>Save the current global state</p>
</dd>
<dt>restore_global_state</dt>
<dd>
<p>Restore the previously saved (using
<code>Lsave_global_state</code>&gt; state</p>
</dd>
</dl>
<h1>TODO</h1>
<dl>
<dt>SAX handlers</dt>
<dd>
<p>Allowing XML::Twig to work on top of any SAX parser</p>
</dd>
<dt>multiple twigs are not well supported</dt>
<dd>
<p>A number of twig features are just global at the moment. These
include the ID list and the tag pool (if you use <code>change_gi</code>
then you change the tag for ALL twigs). A future version will try to
support this while trying not to be to hard on performance (at least
when a single twig is used!).</p>
</dd>
</dl>
<h1>AUTHOR</h1>
<p>Michel Rodriguez &lt;mirod@cpan.org&gt;</p>
<h1>LICENSE</h1>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
<p>Bug reports should be sent using: <em>RT
&lt;http://rt.cpan.org/NoAuth/Bugs.html?Dist=XML-Twig&gt;</em></p>
<p>Comments can be sent to mirod@cpan.org</p>
<p>The XML::Twig page is at &lt;http://www.xmltwig.org/xmltwig/&gt; It
includes the development version of the module, a slightly better
version of the documentation, examples, a tutorial and a: <em>Processing
XML efficiently with Perl and XML::Twig:</em>
&lt;http://www.xmltwig.org/xmltwig/tutorial/index.html&gt;</p>
<h1>SEE ALSO</h1>
<p>Complete docs, including a tutorial, examples, an easier to use HTML
version of the docs, a quick reference card and a FAQ are available at
&lt;http://www.xmltwig.org/xmltwig/&gt;</p>
<p>git repository at &lt;http://github.com/mirod/xmltwig&gt;</p>
<p>XML::Parser, XML::Parser::Expat, XML::XPath, Encode, Text::Iconv,
Scalar::Utils</p>
<h2>Alternative Modules</h2>
<p>XML::Twig is not the only XML::Processing module available on CPAN
(far from it!).</p>
<p>The main alternative I would recommend is XML::LibXML.</p>
<p>Here is a quick comparison of the 2 modules:</p>
<p>XML::LibXML, actually <code>libxml2</code> on which it is based,
sticks to the standards, and implements a good number of them in a
rather strict way: XML, XPath, DOM, RelaxNG, I must be forgetting a
couple (XInclude?). It is fast and rather frugal memory-wise.</p>
<p>XML::Twig is older: when I started writing it XML::Parser/expat was
the only game in town. It implements XML and that's about it (plus a
subset of XPath, and you can use XML::Twig::XPath if you have
XML::XPathEngine installed for full support). It is slower and requires
more memory for a full tree than XML::LibXML. On the plus side (yes,
there is a plus side!) it lets you process a big document in chunks, and
thus let you tackle documents that couldn't be loaded in memory by
XML::LibXML, and it offers a lot (and I mean a LOT!) of higher-level
methods, for everything, from adding structure to low-level XML, to
shortcuts for XHTML conversions and more. It also DWIMs quite a bit,
getting comments and non-significant whitespaces out of the way but
preserving them in the output for example. As it does not stick to the
DOM, is also usually leads to shorter code than in XML::LibXML.</p>
<p>Beyond the pure features of the 2 modules, XML::LibXML seems to be
preferred by XML-purists, while XML::Twig seems to be more used by Perl
Hackers who have to deal with XML. As you have noted, XML::Twig also
comes with quite a lot of docs, but I am sure if you ask for help about
XML::LibXML here or on Perlmonks you will get answers.</p>
<p>Note that it is actually quite hard for me to compare the 2 modules:
on one hand I know XML::Twig inside-out and I can get it to do pretty
much anything I need to (or I improve it ;--), while I have a very basic
knowledge of XML::LibXML. So feature-wise, I'd rather use XML::Twig
;--). On the other hand, I am painfully aware of some of the
deficiencies, potential bugs and plain ugly code that lurk in XML::Twig,
even though you are unlikely to be affected by them (unless for example
you need to change the DTD of a document programmatically), while I
haven't looked much into XML::LibXML so it still looks shinny and clean
to me.</p>
<p>That said, if you need to process a document that is too big to fit
memory and XML::Twig is too slow for you, my reluctant advice would be
to use bare XML::Parser. It won't be as easy to use as XML::Twig:
basically with XML::Twig you trade some speed (depending on what you do
from a factor 3 to... none) for ease-of-use, but it will be easier IMHO
than using SAX (albeit not standard), and at this point a LOT faster
(see the last test in
&lt;http://www.xmltwig.org/article/simple_benchmark/&gt;).</p>
