<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>Net::DBus::BaseObject - base class for exporting objects to the
bus</p>
<h1>SYNOPSIS</h1>
<p># Were going to be a DBus object use base qw(Net::DBus::BaseObject);
# Export a Greeting signal taking a stringl string parameter
dbus_signal("Greeting", ["string"]); # Export Hello as a method
accepting a single string # parameter, and returning a single string
value dbus_method("Hello", ["string"], ["string"]); sub new { my $class
= shift; my $service = shift; my $self = $class-&gt;SUPER::new($service,
"/org/demo/HelloWorld"); bless $self, $class; return $self; } sub
_dispatch_object { my $self = shift; my $connection = shift; my $message
= shift; if (....$message refers to a objects method ... ) { ...dispatch
this objects interfaces/methods... return $reply; } }</p>
<h1>DESCRIPTION</h1>
<p>This the base of all objects which are exported to the message bus.
It provides the core support for type introspection required for objects
exported to the message. When sub-classing this object, the
<code>_dispatch</code> object should be implemented to handle processing
of incoming messages. The Net::DBus::Exporter module is used to declare
which methods (and signals) are being exported to the message bus.</p>
<p>All packages inheriting from this, will automatically have the
interface <code>org.freedesktop.DBus.Introspectable</code> registered
with Net::DBus::Exporter, and the <code>Introspect</code> method within
this exported.</p>
<p>Application developers will rarely want to use this class directly,
instead either Net::DBus::Object or <code>Net::DBus::ProxyObject</code>
are the common choices. This class will only be used if wanting to write
a new approach to dispatching incoming method calls.</p>
<h1>METHODS</h1>
<dl>
<dt>my $object = Net::DBus::BaseObject-&gt;new($service, $path)</dt>
<dd>
<p>This creates a new DBus object with an path of <code>$path</code>
registered within the service <code>$service</code>. The
<code>$path</code> parameter should be a string complying with the usual
DBus requirements for object paths, while the <code>$service</code>
parameter should be an instance of Net::DBus::Service. The latter is
typically obtained by calling the <code>export_service</code> method on
the Net::DBus object.</p>
</dd>
<dt>my $object = Net::DBus::BaseObject-&gt;new($parentobj,
$subpath)</dt>
<dd>
<p>This creates a new DBus child object with an path of
<code>$subpath</code> relative to its parent <code>$parentobj</code>.
The <code>$subpath</code> parameter should be a string complying with
the usual DBus requirements for object paths, while the
<code>$parentobj</code> parameter should be an instance of
Net::DBus::BaseObject.</p>
</dd>
<dt>$object-&gt;disconnect();</dt>
<dd>
<p>This method disconnects the object from the bus, such that it will no
longer receive messages sent by other clients. Any child objects will be
recursively disconnected too. After an object has been disconnected, it
is possible for Perl to garbage collect the object instance. It will
also make it possible to connect a newly created object to the same
path.</p>
</dd>
<dt>my $bool = $object-&gt;is_connected</dt>
<dd>
<p>Returns a true value if the object is connected to the bus, and thus
capable of being accessed by remote clients. Returns false if the object
is disconnected &amp; thus ready for garbage collection. All objects
start off in the connected state, and will only transition if the
<code>disconnect</code> method is called.</p>
</dd>
<dt>my $service = $object-&gt;get_service</dt>
<dd>
<p>Retrieves the Net::DBus::Service object within which this object is
exported.</p>
</dd>
<dt>my $path = $object-&gt;get_object_path</dt>
<dd>
<p>Retrieves the path under which this object is exported</p>
</dd>
<dt>$object-&gt;emit_signal_in($name, $interface, $client, @args);</dt>
<dd>
<p>Emits a signal from the object, with a name of <code>$name</code>. If
the <code>$interface</code> parameter is defined, the signal will be
scoped within that interface. If the <code>$client</code> parameter is
defined, the signal will be unicast to that client on the bus. The
signal and the data types of the arguments <code>@args</code> must have
been registered with Net::DBus::Exporter by calling the
<code>dbus_signal</code> method.</p>
</dd>
<dt>$self-&gt;emit_signal_to($name, $client, @args);</dt>
<dd>
<p>Emits a signal from the object, with a name of <code>$name</code>.
The signal and the data types of the arguments <code>@args</code> must
have been registered with Net::DBus::Exporter by calling the
<code>dbus_signal</code> method. The signal will be sent only to the
client named by the <code>$client</code> parameter.</p>
</dd>
<dt>$self-&gt;emit_signal($name, @args);</dt>
<dd>
<p>Emits a signal from the object, with a name of <code>$name</code>.
The signal and the data types of the arguments <code>@args</code> must
have been registered with Net::DBus::Exporter by calling the
<code>dbus_signal</code> method. The signal will be broadcast to all
clients on the bus.</p>
</dd>
<dt>$object-&gt;connect_to_signal_in($name, $interface, $coderef);</dt>
<dd>
<p>Connects a callback to a signal emitted by the object. The
<code>$name</code> parameter is the name of the signal within the
object, and <code>$coderef</code> is a reference to an anonymous
subroutine. When the signal <code>$name</code> is emitted by the remote
object, the subroutine <code>$coderef</code> will be invoked, and passed
the parameters from the signal. The <code>$interface</code> parameter is
used to specify the explicit interface defining the signal to connect
to.</p>
</dd>
<dt>$object-&gt;connect_to_signal($name, $coderef);</dt>
<dd>
<p>Connects a callback to a signal emitted by the object. The
<code>$name</code> parameter is the name of the signal within the
object, and <code>$coderef</code> is a reference to an anonymous
subroutine. When the signal <code>$name</code> is emitted by the remote
object, the subroutine <code>$coderef</code> will be invoked, and passed
the parameters from the signal.</p>
</dd>
<dt>$reply = $object-&gt;_dispatch_object($connection, $message);</dt>
<dd>
<p>The <code>_dispatch_object</code> method is to be used to handle
dispatch of methods implemented by the object. The default
implementation is a no-op and should be overridden by subclasses todo
whatever processing is required. If the <code>$message</code> could be
handled then another <code>Net::DBus::Binding::Message</code> instance
should be returned for the reply. If <code>undef</code> is returned,
then a generic error will be returned to the caller.</p>
</dd>
<dt>$currvalue = $object-&gt;_dispatch_property($name); =item
$object-&gt;_dispatch_property($name, $newvalue);</dt>
<dd>
<p>The <code>_dispatch_property</code> method is to be used to handle
dispatch of property reads and writes. The <code>$name</code> parameter
is the name of the property being accessed. If <code>$newvalue</code> is
supplied then the property is to be updated, otherwise the current value
is to be returned. The default implementation will simply raise an
error, so must be overridden in subclasses.</p>
</dd>
</dl>
<h1>AUTHOR</h1>
<p>Daniel P. Berrange</p>
<h1>COPYRIGHT</h1>
<p>Copyright (C) 2005-2011 Daniel P. Berrange</p>
<h1>SEE ALSO</h1>
<p>Net::DBus, Net::DBus::Service, Net::DBus::Object,
Net::DBus::ProxyObject, Net::DBus::Exporter, Net::DBus::RemoteObject</p>
