<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>HTML::Parser - HTML parser class</p>
<h1>SYNOPSIS</h1>
<p>use strict; use warnings; use HTML::Parser (); # Create parser object
my $p = HTML::Parser-&gt;new( api_version =&gt; 3, start_h =&gt;
[\&amp;start, "tagname, attr"], end_h =&gt; [\&amp;end, "tagname"],
marked_sections =&gt; 1, ); # Parse document text chunk by chunk
$p-&gt;parse($chunk1); $p-&gt;parse($chunk2); # ... # signal end of
document $p-&gt;eof; # Parse directly from file
$p-&gt;parse_file("foo.html"); # or open(my $fh, "&lt;:utf8",
"foo.html") || die; $p-&gt;parse_file($fh);</p>
<h1>DESCRIPTION</h1>
<p>Objects of the <code>HTML::Parser</code> class will recognize markup
and separate it from plain text (alias data content) in HTML documents.
As different kinds of markup and text are recognized, the corresponding
event handlers are invoked.</p>
<p><code>HTML::Parser</code> is not a generic SGML parser. We have tried
to make it able to deal with the HTML that is actually out there, and it
normally parses as closely as possible to the way the popular web
browsers do it instead of strictly following one of the many HTML
specifications from W3C. Where there is disagreement, there is often an
option that you can enable to get the official behaviour.</p>
<p>The document to be parsed may be supplied in arbitrary chunks. This
makes on-the-fly parsing as documents are received from the network
possible.</p>
<p>If event driven parsing does not feel right for your application, you
might want to use <code>HTML::PullParser</code>. This is an
<code>HTML::Parser</code> subclass that allows a more conventional
program structure.</p>
<h1>METHODS</h1>
<p>The following method is used to construct a new
<code>HTML::Parser</code> object:</p>
<dl>
<dt>$p = HTML::Parser-&gt;new( %options_and_handlers )</dt>
<dd>
<p>This class method creates a new <code>HTML::Parser</code> object and
returns it. Key/value argument pairs may be provided to assign event
handlers or initialize parser options. The handlers and parser options
can also be set or modified later by the method calls described below.
If a top level key is in the form &lt;event&gt;_h (e.g., text_h) then it
assigns a handler to that event, otherwise it initializes a parser
option. The event handler specification value must be an array
reference. Multiple handlers may also be assigned with the 'handlers
=&gt; [%handlers]' option. See examples below. If <strong>new()</strong>
is called without any arguments, it will create a parser that uses
callback methods compatible with version 2 of <code>HTML::Parser</code>.
See the section on version 2 compatibility below for details. The
special constructor option 'api_version =&gt; 2' can be used to
initialize version 2 callbacks while still setting other options and
handlers. The 'api_version =&gt; 3' option can be used if you don't want
to set any options and don't want to fall back to v2 compatible mode.
Examples: $p = HTML::Parser-&gt;new( api_version =&gt; 3, text_h =&gt; [
sub {...}, "dtext" ] ); This creates a new parser object with a text
event handler subroutine that receives the original text with general
entities decoded. $p = HTML::Parser-&gt;new( api_version =&gt; 3,
start_h =&gt; [ my_start, "self,tokens" ] ); This creates a new parser
object with a start event handler method that receives the
<code>$p</code> and the tokens array. $p = HTML::Parser-&gt;new(
api_version =&gt; 3, handlers =&gt; { text =&gt; [\@array,
"event,text"], comment =&gt; [\@array, "event,text"], } ); This creates
a new parser object that stores the event type and the original text in
<code>@array</code> for text and comment events.</p>
</dd>
</dl>
<p>The following methods feed the HTML document to the
<code>HTML::Parser</code> object:</p>
<dl>
<dt>$p-&gt;parse( $string )</dt>
<dd>
<p>Parse <code>$string</code> as the next chunk of the HTML document.
Handlers invoked should not attempt to modify the <code>$string</code>
in-place until <code>$p</code>-&gt;parse returns. If an invoked event
handler aborts parsing by calling <code>$p</code>-&gt;eof, then
<code>$p</code>-&gt;<strong>parse()</strong> will return a FALSE value.
Otherwise the return value is a reference to the parser object ($p).</p>
</dd>
<dt>$p-&gt;parse( $code_ref )</dt>
<dd>
<p>If a code reference is passed as the argument to be parsed, then the
chunks to be parsed are obtained by invoking this function repeatedly.
Parsing continues until the function returns an empty (or undefined)
result. When this happens <code>$p</code>-&gt;eof is automatically
signaled. Parsing will also abort if one of the event handlers calls
<code>$p</code>-&gt;eof. The effect of this is the same as: while (1) {
my $chunk = &amp;$code_ref(); if (!defined($chunk) || !length($chunk)) {
$p-&gt;eof; return $p; } $p-&gt;parse($chunk) || return undef; } But it
is more efficient as this loop runs internally in XS code.</p>
</dd>
<dt>$p-&gt;parse_file( $file )</dt>
<dd>
<p>Parse text directly from a file. The <code>$file</code> argument can
be a filename, an open file handle, or a reference to an open file
handle. If <code>$file</code> contains a filename and the file can't be
opened, then the method returns an undefined value and $! tells why it
failed. Otherwise the return value is a reference to the parser object.
If a file handle is passed as the <code>$file</code> argument, then the
file will normally be read until EOF, but not closed. If an invoked
event handler aborts parsing by calling <code>$p</code>-&gt;eof, then
<code>$p</code>-&gt;<strong>parse_file()</strong> may not have read the
entire file. On systems with multi-byte line terminators, the values
passed for the offset and length argspecs may be too low if
<strong>parse_file()</strong> is called on a file handle that is not in
binary mode. If a filename is passed in, then
<strong>parse_file()</strong> will open the file in binary mode.</p>
</dd>
<dt>$p-&gt;eof</dt>
<dd>
<p>Signals the end of the HTML document. Calling the
<code>$p</code>-&gt;eof method outside a handler callback will flush any
remaining buffered text (which triggers the <code>text</code> event if
there is any remaining text). Calling <code>$p</code>-&gt;eof inside a
handler will terminate parsing at that point and cause
<code>$p</code>-&gt;parse to return a FALSE value. This also terminates
parsing by <code>$p</code>-&gt;<strong>parse_file()</strong>. After
<code>$p</code>-&gt;eof has been called, the <strong>parse()</strong>
and <strong>parse_file()</strong> methods can be invoked to feed new
documents with the parser object. The return value from
<strong>eof()</strong> is a reference to the parser object.</p>
</dd>
</dl>
<p>Most parser options are controlled by boolean attributes. Each
boolean attribute is enabled by calling the corresponding method with a
TRUE argument and disabled with a FALSE argument. The attribute value is
left unchanged if no argument is given. The return value from each
method is the old attribute value.</p>
<p>Methods that can be used to get and/or set parser options are:</p>
<dl>
<dt>$p-&gt;attr_encoded</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;attr_encoded( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, the <code>attr</code> and <code>@attr</code> argspecs
will have general entities for attribute values decoded. Enabling this
attribute leaves entities alone.</p>
<dl>
<dt>$p-&gt;backquote</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;backquote( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, only ' and " are recognized as quote characters around
attribute values. MSIE also recognizes backquotes for some reason.
Enabling this attribute provides compatibility with this behaviour.</p>
<dl>
<dt>$p-&gt;boolean_attribute_value( $val )</dt>
<dd>
<p>This method sets the value reported for boolean attributes inside
HTML start tags. By default, the name of the attribute is also used as
its value. This affects the values reported for <code>tokens</code> and
<code>attr</code> argspecs.</p>
</dd>
<dt>$p-&gt;case_sensitive</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;case_sensitive( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, tag names and attribute names are down-cased. Enabling
this attribute leaves them as found in the HTML source document.</p>
<dl>
<dt>$p-&gt;closing_plaintext</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;closing_plaintext( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, <code>plaintext</code> element can never be closed.
Everything up to the end of the document is parsed in CDATA mode. This
historical behaviour is what at least MSIE does. Enabling this attribute
makes closing <code> &lt;/plaintext</code> &gt; tag effective and the
parsing process will resume after seeing this tag. This emulates early
gecko-based browsers.</p>
<dl>
<dt>$p-&gt;empty_element_tags</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;empty_element_tags( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, empty element tags are not recognized as such and the /
before &gt; is just treated like a normal name character (unless
<code>strict_names</code> is enabled). Enabling this attribute make
<code>HTML::Parser</code> recognize these tags. Empty element tags look
like start tags, but end with the character sequence /&gt; instead of
&gt;. When recognized by <code>HTML::Parser</code> they cause an
artificial end event in addition to the start event. The
<code>text</code> for the artificial end event will be empty and the
<code>tokenpos</code> array will be undefined even though the token
array will have one element containing the tag name.</p>
<dl>
<dt>$p-&gt;marked_sections</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;marked_sections( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, section markings like &lt;![CDATA[...]]&gt; are treated
like ordinary text. When this attribute is enabled section markings are
honoured. There are currently no events associated with the marked
section markup, but the text can be returned as
<code>skipped_text</code>.</p>
<dl>
<dt>$p-&gt;strict_comment</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;strict_comment( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, comments are terminated by the first occurrence of
--&gt;. This is the behaviour of most popular browsers (like Mozilla,
Opera and MSIE), but it is not correct according to the official HTML
standard. Officially, you need an even number of -- tokens before the
closing &gt; is recognized and there may not be anything but whitespace
between an even and an odd --. The official behaviour is enabled by
enabling this attribute. Enabling of 'strict_comment' also disables
recognizing these forms as comments: &lt;/ comment&gt; &lt;!
comment&gt;</p>
<dl>
<dt>$p-&gt;strict_end</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;strict_end( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, attributes and other junk are allowed to be present on
end tags in a manner that emulates MSIE's behaviour. The official
behaviour is enabled with this attribute. If enabled, only whitespace is
allowed between the tagname and the final &gt;.</p>
<dl>
<dt>$p-&gt;strict_names</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;strict_names( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, almost anything is allowed in tag and attribute names.
This is the behaviour of most popular browsers and allows us to parse
some broken tags with invalid attribute values like: &lt;IMG
SRC=newprevlstGr.gif ALT=[PREV LIST] BORDER=0&gt; By default, LIST] is
parsed as a boolean attribute, not as part of the ALT value as was
clearly intended. This is also what Mozilla sees. The official behaviour
is enabled by enabling this attribute. If enabled, it will cause the tag
above to be reported as text since LIST] is not a legal attribute
name.</p>
<dl>
<dt>$p-&gt;unbroken_text</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;unbroken_text( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, blocks of text are given to the text handler as soon as
possible (but the parser takes care always to break text at a boundary
between whitespace and non-whitespace so single words and entities can
always be decoded safely). This might create breaks that make it hard to
do transformations on the text. When this attribute is enabled, blocks
of text are always reported in one piece. This will delay the text event
until the following (non-text) event has been recognized by the parser.
Note that the <code>offset</code> argspec will give you the offset of
the first segment of text and <code>length</code> is the combined length
of the segments. Since there might be ignored tags in between, these
numbers can't be used to directly index in the original document
file.</p>
<dl>
<dt>$p-&gt;utf8_mode</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;utf8_mode( $bool )</dt>
<dd>

</dd>
</dl>
<p>Enable this option when parsing raw undecoded UTF-8. This tells the
parser that the entities expanded for strings reported by
<code>attr</code>, <code>@attr</code> and <code>dtext</code> should be
expanded as decoded UTF-8 so they end up compatible with the surrounding
text. If <code>utf8_mode</code> is enabled then it is an error to pass
strings containing characters with code above 255 to the
<strong>parse()</strong> method, and the <strong>parse()</strong> method
will croak if you try. Example: The Unicode character \x{2665} is
\xE2\x99\xA5 when UTF-8 encoded. The character can also be represented
by the entity &amp;hearts; or &amp;#x2665. If we feed the parser:
$p-&gt;parse("\xE2\x99\xA5&amp;hearts;"); then <code>dtext</code> will
be reported as \xE2\x99\xA5\x{2665} without <code>utf8_mode</code>
enabled, but as \xE2\x99\xA5\xE2\x99\xA5 when enabled. The later string
is what you want. This option is only available with perl-5.8 or
better.</p>
<dl>
<dt>$p-&gt;xml_mode</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;xml_mode( $bool )</dt>
<dd>

</dd>
</dl>
<p>Enabling this attribute changes the parser to allow some XML
constructs. This enables the behaviour controlled by individually by the
<code>case_sensitive</code>, <code>empty_element_tags</code>,
<code>strict_names</code> and <code>xml_pic</code> attributes and also
suppresses special treatment of elements that are parsed as CDATA for
HTML.</p>
<dl>
<dt>$p-&gt;xml_pic</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;xml_pic( $bool )</dt>
<dd>

</dd>
</dl>
<p>By default, <em>processing instructions</em> are terminated by &gt;.
When this attribute is enabled, processing instructions are terminated
by ?&gt; instead.</p>
<p>As markup and text is recognized, handlers are invoked. The following
method is used to set up handlers for different events:</p>
<dl>
<dt>$p-&gt;handler( event =&gt; \&amp;subroutine, $argspec )</dt>
<dd>

</dd>
</dl>
<dl>
<dt>$p-&gt;handler( event =&gt; $method_name, $argspec )</dt>
<dd>

</dd>
<dt>$p-&gt;handler( event =&gt; \@accum, $argspec )</dt>
<dd>

</dd>
<dt>$p-&gt;handler( event =&gt; "" );</dt>
<dd>

</dd>
<dt>$p-&gt;handler( event =&gt; undef );</dt>
<dd>

</dd>
<dt>$p-&gt;handler( event );</dt>
<dd>

</dd>
</dl>
<p>This method assigns a subroutine, method, or array to handle an
event. Event is one of <code>text</code>, <code>start</code>,
<code>end</code>, <code>declaration</code>, <code>comment</code>,
<code>process</code>, <code>start_document</code>,
<code>end_document</code> or <code>default</code>. The
<code>\&amp;subroutine</code> is a reference to a subroutine which is
called to handle the event. The <code>$method_name</code> is the name of
a method of <code>$p</code> which is called to handle the event. The
<code>@accum</code> is an array that will hold the event information as
sub-arrays. If the second argument is "", the event is ignored. If it is
undef, the default handler is invoked for the event. The
<code>$argspec</code> is a string that describes the information to be
reported for the event. Any requested information that does not apply to
a specific event is passed as <code>undef</code>. If argspec is omitted,
then it is left unchanged. The return value from
<code>$p</code>-&gt;handler is the old callback routine or a reference
to the accumulator array. Any return values from handler callback
routines/methods are always ignored. A handler callback can request
parsing to be aborted by invoking the <code>$p</code>-&gt;eof method. A
handler callback is not allowed to invoke the
<code>$p</code>-&gt;<strong>parse()</strong> or
<code>$p</code>-&gt;<strong>parse_file()</strong> method. An exception
will be raised if it tries. Examples: $p-&gt;handler(start =&gt;
"start", self, attr, attrseq, text ); This causes the start method of
object <code>$p</code> to be called for 'start' events. The callback
signature is <code>$p-&gt;start(\%attr, \@attr_seq, $text)</code>.
$p-&gt;handler(start =&gt; \&amp;start, attr, attrseq, text ); This
causes subroutine <strong>start()</strong> to be called for 'start'
events. The callback signature is start(\%attr, \@attr_seq,
<code>$text</code>). $p-&gt;handler(start =&gt; \@accum, "S", attr,
attrseq, text ); This causes 'start' event information to be saved in
<code>@accum</code>. The array elements will be ['S', \%attr,
\@attr_seq, <code>$text</code>]. $p-&gt;handler(start =&gt; ""); This
causes 'start' events to be ignored. It also suppresses invocations of
any default handler for start events. It is in most cases equivalent to
<code>$p</code>-&gt;handler(start =&gt; sub {}), but is more efficient.
It is different from the empty-sub-handler in that
<code>skipped_text</code> is not reset by it. $p-&gt;handler(start =&gt;
undef); This causes no handler to be associated with start events. If
there is a default handler it will be invoked.</p>
<p>Filters based on tags can be set up to limit the number of events
reported. The main bottleneck during parsing is often the huge number of
callbacks made from the parser. Applying filters can improve performance
significantly.</p>
<p>The following methods control filters:</p>
<dl>
<dt>$p-&gt;ignore_elements( @tags )</dt>
<dd>
<p>Both the <code>start</code> event and the <code>end</code> event as
well as any events that would be reported in between are suppressed. The
ignored elements can contain nested occurrences of itself. Example:
$p-&gt;ignore_elements(qw(script style)); The <code>script</code> and
<code>style</code> tags will always nest properly since their content is
parsed in CDATA mode. For most other tags <code>ignore_elements</code>
must be used with caution since HTML is often not <em>well
formed</em>.</p>
</dd>
<dt>$p-&gt;ignore_tags( @tags )</dt>
<dd>
<p>Any <code>start</code> and <code>end</code> events involving any of
the tags given are suppressed. To reset the filter (i.e. don't suppress
any <code>start</code> and <code>end</code> events), call
<code>ignore_tags</code> without an argument.</p>
</dd>
<dt>$p-&gt;report_tags( @tags )</dt>
<dd>
<p>Any <code>start</code> and <code>end</code> events involving any of
the tags <em>not</em> given are suppressed. To reset the filter (i.e.
report all <code>start</code> and <code>end</code> events), call
<code>report_tags</code> without an argument.</p>
</dd>
</dl>
<p>Internally, the system has two filter lists, one for
<code>report_tags</code> and one for <code>ignore_tags</code>, and both
filters are applied. This effectively gives <code>ignore_tags</code>
precedence over <code>report_tags</code>.</p>
<p>Examples:</p>
<p>$p-&gt;ignore_tags(qw(style)); $p-&gt;report_tags(qw(script
style));</p>
<p>results in only <code>script</code> events being reported.</p>
<h2>Argspec</h2>
<p>Argspec is a string containing a comma-separated list that describes
the information reported by the event. The following argspec identifier
names can be used:</p>
<dl>
<dt>"attr"</dt>
<dd>
<p>Attr causes a reference to a hash of attribute name/value pairs to be
passed. Boolean attributes' values are either the value set by
<code>$p</code>-&gt;boolean_attribute_value, or the attribute name if no
value has been set by <code>$p</code>-&gt;boolean_attribute_value. This
passes undef except for <code>start</code> events. Unless
<code>xml_mode</code> or <code>case_sensitive</code> is enabled, the
attribute names are forced to lower case. General entities are decoded
in the attribute values and one layer of matching quotes enclosing the
attribute values is removed. The Unicode character set is assumed for
entity decoding.</p>
</dd>
</dl>
<ol class="example" type="1">
<li><p>Basically the same as <code>attr</code>, but keys and values are
passed as individual arguments and the original sequence of the
attributes is kept. The parameters passed will be the same as the
<code>@attr</code> calculated here: @attr = map { $_ =&gt;
$attr-&gt;{$_} } @$attrseq; assuming <code>$attr</code> and
<code>$attrseq</code> here are the hash and array passed as the result
of <code>attr</code> and <code>attrseq</code> argspecs. This passes no
values for events besides <code>start</code>.</p></li>
</ol>
<dl>
<dt>"attrseq"</dt>
<dd>
<p>Attrseq causes a reference to an array of attribute names to be
passed. This can be useful if you want to walk the <code>attr</code>
hash in the original sequence. This passes undef except for
<code>start</code> events. Unless <code>xml_mode</code> or
<code>case_sensitive</code> is enabled, the attribute names are forced
to lower case.</p>
</dd>
<dt>"column"</dt>
<dd>
<p>Column causes the column number of the start of the event to be
passed. The first column on a line is 0.</p>
</dd>
<dt>"dtext"</dt>
<dd>
<p>Dtext causes the decoded text to be passed. General entities are
automatically decoded unless the event was inside a CDATA section or was
between literal start and end tags (<code>script</code>,
<code>style</code>, <code>xmp</code>, <code>iframe</code>,
<code>title</code>, <code>textarea</code> and <code>plaintext</code>).
The Unicode character set is assumed for entity decoding. With Perl
version 5.6 or earlier only the Latin-1 range is supported, and entities
for characters outside the range 0..255 are left unchanged. This passes
undef except for <code>text</code> events.</p>
</dd>
<dt>"event"</dt>
<dd>
<p>Event causes the event name to be passed. The event name is one of
<code>text</code>, <code>start</code>, <code>end</code>,
<code>declaration</code>, <code>comment</code>, <code>process</code>,
<code>start_document</code> or <code>end_document</code>.</p>
</dd>
<dt>"is_cdata"</dt>
<dd>
<p>Is_cdata causes a TRUE value to be passed if the event is inside a
CDATA section or between literal start and end tags
(<code>script</code>, <code>style</code>, <code>xmp</code>,
<code>iframe</code>, <code>title</code>, <code>textarea</code> and
<code>plaintext</code>). if the flag is FALSE for a text event, then you
should normally either use <code>dtext</code> or decode the entities
yourself before the text is processed further.</p>
</dd>
<dt>"length"</dt>
<dd>
<p>Length causes the number of bytes of the source text of the event to
be passed.</p>
</dd>
<dt>"line"</dt>
<dd>
<p>Line causes the line number of the start of the event to be passed.
The first line in the document is 1. Line counting doesn't start until
at least one handler requests this value to be reported.</p>
</dd>
<dt>"offset"</dt>
<dd>
<p>Offset causes the byte position in the HTML document of the start of
the event to be passed. The first byte in the document has offset 0.</p>
</dd>
<dt>"offset_end"</dt>
<dd>
<p>Offset_end causes the byte position in the HTML document of the end
of the event to be passed. This is the same as <code>offset</code> +
<code>length</code>.</p>
</dd>
<dt>"self"</dt>
<dd>
<p>Self causes the current object to be passed to the handler. If the
handler is a method, this must be the first element in the argspec. An
alternative to passing self as an argspec is to register closures that
capture <code>$self</code> by themselves as handlers. Unfortunately this
creates circular references which prevent the HTML::Parser object from
being garbage collected. Using the <code>self</code> argspec avoids this
problem.</p>
</dd>
<dt>"skipped_text"</dt>
<dd>
<p>Skipped_text returns the concatenated text of all the events that
have been skipped since the last time an event was reported. Events
might be skipped because no handler is registered for them or because
some filter applies. Skipped text also includes marked section markup,
since there are no events that can catch it. If an
<code>""</code>-handler is registered for an event, then the text for
this event is not included in <code>skipped_text</code>. Skipped text
both before and after the <code>""</code>-event is included in the next
reported <code>skipped_text</code>.</p>
</dd>
<dt>"tag"</dt>
<dd>
<p>Same as <code>tagname</code>, but prefixed with / if it belongs to an
<code>end</code> event and ! for a declaration. The <code>tag</code>
does not have any prefix for <code>start</code> events, and is in this
case identical to <code>tagname</code>.</p>
</dd>
<dt>"tagname"</dt>
<dd>
<p>This is the element name (or <em>generic identifier</em> in SGML
jargon) for start and end tags. Since HTML is case insensitive, this
name is forced to lower case to ease string matching. Since XML is case
sensitive, the tagname case is not changed when <code>xml_mode</code> is
enabled. The same happens if the <code>case_sensitive</code> attribute
is set. The declaration type of declaration elements is also passed as a
tagname, even if that is a bit strange. In fact, in the current
implementation tagname is identical to <code>token0</code> except that
the name may be forced to lower case.</p>
</dd>
<dt>"token0"</dt>
<dd>
<p>Token0 causes the original text of the first token string to be
passed. This should always be the same as <code>$tokens</code>-&gt;[0].
For <code>declaration</code> events, this is the declaration type. For
<code>start</code> and <code>end</code> events, this is the tag name.
For <code>process</code> and non-strict <code>comment</code> events,
this is everything inside the tag. This passes undef if there are no
tokens in the event.</p>
</dd>
<dt>"tokenpos"</dt>
<dd>
<p>Tokenpos causes a reference to an array of token positions to be
passed. For each string that appears in <code>tokens</code>, this array
contains two numbers. The first number is the offset of the start of the
token in the original <code>text</code> and the second number is the
length of the token. Boolean attributes in a <code>start</code> event
will have (0,0) for the attribute value offset and length. This passes
undef if there are no tokens in the event (e.g., <code>text</code>) and
for artificial <code>end</code> events triggered by empty element tags.
If you are using these offsets and lengths to modify <code>text</code>,
you should either work from right to left, or be very careful to
calculate the changes to the offsets.</p>
</dd>
<dt>"tokens"</dt>
<dd>
<p>Tokens causes a reference to an array of token strings to be passed.
The strings are exactly as they were found in the original text, no
decoding or case changes are applied. For <code>declaration</code>
events, the array contains each word, comment, and delimited string
starting with the declaration type. For <code>comment</code> events,
this contains each sub-comment. If <code>$p</code>-&gt;strict_comments
is disabled, there will be only one sub-comment. For <code>start</code>
events, this contains the original tag name followed by the attribute
name/value pairs. The values of boolean attributes will be either the
value set by <code>$p</code>-&gt;boolean_attribute_value, or the
attribute name if no value has been set by
<code>$p</code>-&gt;boolean_attribute_value. For <code>end</code>
events, this contains the original tag name (always one token). For
<code>process</code> events, this contains the process instructions
(always one token). This passes <code>undef</code> for <code>text</code>
events.</p>
</dd>
<dt>"text"</dt>
<dd>
<p>Text causes the source text (including markup element delimiters) to
be passed.</p>
</dd>
<dt>"undef"</dt>
<dd>
<p>Pass an undefined value. Useful as padding where the same handler
routine is registered for multiple events.</p>
</dd>
<dt>...</dt>
<dd>
<p>A literal string of 0 to 255 characters enclosed in single (') or
double (") quotes is passed as entered.</p>
</dd>
</dl>
<p>The whole argspec string can be wrapped up in <code>@{...}</code> to
signal that the resulting event array should be flattened. This only
makes a difference if an array reference is used as the handler target.
Consider this example:</p>
<p>$p-&gt;handler(text =&gt; [], text); $p-&gt;handler(text =&gt; [],
@{text}]);</p>
<p>With two text events; <code>"foo"</code>, <code>"bar"</code>; then
the first example will end up with [[foo], [bar]] and the second with
[foo, bar] in the handler target array.</p>
<h2>Events</h2>
<p>Handlers for the following events can be registered:</p>
<dl>
<dt>"comment"</dt>
<dd>
<p>This event is triggered when a markup comment is recognized. Example:
&lt;!-- This is a comment -- -- So is this --&gt;</p>
</dd>
<dt>"declaration"</dt>
<dd>
<p>This event is triggered when a <em>markup declaration</em> is
recognized. For typical HTML documents, the only declaration you are
likely to find is &lt;!DOCTYPE ...&gt;. Example: &lt;!DOCTYPE HTML
PUBLIC "-//W3C//DTD HTML 4.01//EN"
"http://www.w3.org/TR/html4/strict.dtd"&gt; DTDs inside &lt;!DOCTYPE
...&gt; will confuse HTML::Parser.</p>
</dd>
<dt>"default"</dt>
<dd>
<p>This event is triggered for events that do not have a specific
handler. You can set up a handler for this event to catch stuff you did
not want to catch explicitly.</p>
</dd>
<dt>"end"</dt>
<dd>
<p>This event is triggered when an end tag is recognized. Example:
&lt;/A&gt;</p>
</dd>
<dt>"end_document"</dt>
<dd>
<p>This event is triggered when <code>$p</code>-&gt;eof is called and
after any remaining text is flushed. There is no document text
associated with this event.</p>
</dd>
<dt>"process"</dt>
<dd>
<p>This event is triggered when a processing instructions markup is
recognized. The format and content of processing instructions are system
and application dependent. Examples: &lt;? HTML processing instructions
&gt; &lt;? XML processing instructions ?&gt;</p>
</dd>
<dt>"start"</dt>
<dd>
<p>This event is triggered when a start tag is recognized. Example:
&lt;A HREF="http://www.perl.com/"&gt;</p>
</dd>
<dt>"start_document"</dt>
<dd>
<p>This event is triggered before any other events for a new document. A
handler for it can be used to initialize stuff. There is no document
text associated with this event.</p>
</dd>
<dt>"text"</dt>
<dd>
<p>This event is triggered when plain text (characters) is recognized.
The text may contain multiple lines. A sequence of text may be broken
between several text events unless <code>$p</code>-&gt;unbroken_text is
enabled. The parser will make sure that it does not break a word or a
sequence of whitespace between two text events.</p>
</dd>
</dl>
<h2>Unicode</h2>
<p><code>HTML::Parser</code> can parse Unicode strings when running
under perl-5.8 or better. If Unicode is passed to
<code>$p</code>-&gt;<strong>parse()</strong> then chunks of Unicode will
be reported to the handlers. The offset and length argspecs will also
report their position in terms of characters.</p>
<p>It is safe to parse raw undecoded UTF-8 if you either avoid decoding
entities and make sure to not use <em>argspecs</em> that do, or enable
the <code>utf8_mode</code> for the parser. Parsing of undecoded UTF-8
might be useful when parsing from a file where you need the reported
offsets and lengths to match the byte offsets in the file.</p>
<p>If a filename is passed to
<code>$p</code>-&gt;<strong>parse_file()</strong> then the file will be
read in binary mode. This will be fine if the file contains only ASCII
or Latin-1 characters. If the file contains UTF-8 encoded text then care
must be taken when decoding entities as described in the previous
paragraph, but better is to open the file with the UTF-8 layer so that
it is decoded properly:</p>
<p>open(my $fh, "&lt;:utf8", "index.html") || die "...: $!";
$p-&gt;parse_file($fh);</p>
<p>If the file contains text encoded in a charset besides ASCII, Latin-1
or UTF-8 then decoding will always be needed.</p>
<h1>VERSION 2 COMPATIBILITY</h1>
<p>When an <code>HTML::Parser</code> object is constructed with no
arguments, a set of handlers is automatically provided that is
compatible with the old HTML::Parser version 2 callback methods.</p>
<p>This is equivalent to the following method calls:</p>
<p>$p-&gt;handler(start =&gt; "start", "self, tagname, attr, attrseq,
text"); $p-&gt;handler(end =&gt; "end", "self, tagname, text");
$p-&gt;handler(text =&gt; "text", "self, text, is_cdata");
$p-&gt;handler(process =&gt; "process", "self, token0, text");
$p-&gt;handler( comment =&gt; sub { my ($self, $tokens) = @_; for
(@$tokens) { $self-&gt;comment($_); } }, "self, tokens" );
$p-&gt;handler( declaration =&gt; sub { my $self = shift;
$self-&gt;declaration(substr($_[0], 2, -1)); }, "self, text" );</p>
<p>Setting up these handlers can also be requested with the api_version
=&gt; 2 constructor option.</p>
<h1>SUBCLASSING</h1>
<p>The <code>HTML::Parser</code> class is able to be subclassed. Parser
objects are plain hashes and <code>HTML::Parser</code> reserves only
hash keys that start with _hparser. The parser state can be set up by
invoking the <strong>init()</strong> method, which takes the same
arguments as <strong>new()</strong>.</p>
<h1>EXAMPLES</h1>
<p>The first simple example shows how you might strip out comments from
an HTML document. We achieve this by setting up a comment handler that
does nothing and a default handler that will print out anything
else:</p>
<p>use HTML::Parser (); HTML::Parser-&gt;new( default_h =&gt; [sub {
print shift }, text], comment_h =&gt; [""], )-&gt;parse_file(shift ||
die) || die $!;</p>
<p>An alternative implementation is:</p>
<p>use HTML::Parser (); HTML::Parser-&gt;new( end_document_h =&gt; [sub
{ print shift }, skipped_text], comment_h =&gt; [""],
)-&gt;parse_file(shift || die) || die $!;</p>
<p>This will in most cases be much more efficient since only a single
callback will be made.</p>
<p>The next example prints out the text that is inside the &lt;title&gt;
element of an HTML document. Here we start by setting up a start
handler. When it sees the title start tag it enables a text handler that
prints any text found and an end handler that will terminate parsing as
soon as the title end tag is seen:</p>
<p>use HTML::Parser (); sub start_handler { return if shift ne "title";
my $self = shift; $self-&gt;handler(text =&gt; sub { print shift },
"dtext"); $self-&gt;handler( end =&gt; sub { shift-&gt;eof if shift eq
"title"; }, "tagname,self" ); } my $p = HTML::Parser-&gt;new(api_version
=&gt; 3); $p-&gt;handler(start =&gt; \&amp;start_handler,
"tagname,self"); $p-&gt;parse_file(shift || die) || die $!; print
"\n";</p>
<p>On a Debian box, more examples can be found in the
/usr/share/doc/libhtml-parser-perl/examples directory. The program
<code>hrefsub</code> shows how you can edit all links found in a
document and <code>htextsub</code> how to edit the text only; the
program <code>hstrip</code> shows how you can strip out certain
tags/elements and/or attributes; and the program <code>htext</code> show
how to obtain the plain text, but not any script/style content.</p>
<p>You can browse the <em>eg/</em> directory online from the
<em>[Browse]</em> link on the http://search.cpan.org/~gaas/HTML-Parser/
page.</p>
<h1>BUGS</h1>
<p>The &lt;style&gt; and &lt;script&gt; sections do not end with the
first &lt;/, but need the complete corresponding end tag. The standard
behaviour is not really practical.</p>
<p>When the <em>strict_comment</em> option is enabled, we still
recognize comments where there is something other than whitespace
between even and odd -- markers.</p>
<p>Once <code>$p</code>-&gt;boolean_attribute_value has been set, there
is no way to restore the default behaviour.</p>
<p>There is currently no way to get both quote characters into the same
literal argspec.</p>
<p>Empty tags, e.g. &lt;&gt; and &lt;/&gt;, are not recognized. SGML
allows them to repeat the previous start tag or close the previous start
tag respectively.</p>
<p>NET tags, e.g. code/.../ are not recognized. This is SGML shorthand
for &lt;code&gt;...&lt;/code&gt;.</p>
<p>Incomplete start or end tags, e.g.
&lt;tt&lt;b&gt;...&lt;/b&lt;/tt&gt; are not recognized.</p>
<h1>DIAGNOSTICS</h1>
<p>The following messages may be produced by HTML::Parser. The notation
in this listing is the same as used in perldiag:</p>
<dl>
<dt>Not a reference to a hash</dt>
<dd>
<p>(F) The object blessed into or subclassed from HTML::Parser is not a
hash as required by the HTML::Parser methods.</p>
</dd>
<dt>Bad signature in parser state object at %p</dt>
<dd>
<p>(F) The _hparser_xs_state element does not refer to a valid state
structure. Something must have changed the internal value stored in this
hash element, or the memory has been overwritten.</p>
</dd>
<dt>_hparser_xs_state element is not a reference</dt>
<dd>
<p>(F) The _hparser_xs_state element has been destroyed.</p>
</dd>
<dt>Can't find '_hparser_xs_state' element in HTML::Parser hash</dt>
<dd>
<p>(F) The _hparser_xs_state element is missing from the parser hash. It
was either deleted, or not created when the object was created.</p>
</dd>
<dt>API version %s not supported by HTML::Parser %s</dt>
<dd>
<p>(F) The constructor option 'api_version' with an argument greater
than or equal to 4 is reserved for future extensions.</p>
</dd>
<dt>Bad constructor option '%s'</dt>
<dd>
<p>(F) An unknown constructor option key was passed to the
<strong>new()</strong> or <strong>init()</strong> methods.</p>
</dd>
<dt>Parse loop not allowed</dt>
<dd>
<p>(F) A handler invoked the <strong>parse()</strong> or
<strong>parse_file()</strong> method. This is not permitted.</p>
</dd>
<dt>marked sections not supported</dt>
<dd>
<p>(F) The <code>$p</code>-&gt;<strong>marked_sections()</strong> method
was invoked in a HTML::Parser module that was compiled without support
for marked sections.</p>
</dd>
<dt>Unknown boolean attribute (%d)</dt>
<dd>
<p>(F) Something is wrong with the internal logic that set up aliases
for boolean attributes.</p>
</dd>
<dt>Only code or array references allowed as handler</dt>
<dd>
<p>(F) The second argument for <code>$p</code>-&gt;handler must be
either a subroutine reference, then name of a subroutine or method, or a
reference to an array.</p>
</dd>
<dt>No handler for %s events</dt>
<dd>
<p>(F) The first argument to <code>$p</code>-&gt;handler must be a valid
event name; i.e. one of start, end, text, process, declaration or
comment.</p>
</dd>
<dt>Unrecognized identifier %s in argspec</dt>
<dd>
<p>(F) The identifier is not a known argspec name. Use one of the names
mentioned in the argspec section above.</p>
</dd>
<dt>Literal string is longer than 255 chars in argspec</dt>
<dd>
<p>(F) The current implementation limits the length of literals in an
argspec to 255 characters. Make the literal shorter.</p>
</dd>
<dt>Backslash reserved for literal string in argspec</dt>
<dd>
<p>(F) The backslash character \ is not allowed in argspec literals. It
is reserved to permit quoting inside a literal in a later version.</p>
</dd>
<dt>Unterminated literal string in argspec</dt>
<dd>
<p>(F) The terminating quote character for a literal was not found.</p>
</dd>
<dt>Bad argspec (%s)</dt>
<dd>
<p>(F) Only identifier names, literals, spaces and commas are allowed in
argspecs.</p>
</dd>
<dt>Missing comma separator in argspec</dt>
<dd>
<p>(F) Identifiers in an argspec must be separated with ,.</p>
</dd>
<dt>Parsing of undecoded UTF-8 will give garbage when decoding
entities</dt>
<dd>
<p>(W) The first chunk parsed appears to contain undecoded UTF-8 and one
or more argspecs that decode entities are used for the callback
handlers. The result of decoding will be a mix of encoded and decoded
characters for any entities that expand to characters with code above
127. This is not a good thing. The recommended solution is to apply
<strong>Encode::decode_utf8()</strong> on the data before feeding it to
the <code>$p</code>-&gt;<strong>parse()</strong>. For
<code>$p</code>-&gt;<strong>parse_file()</strong> pass a file that has
been opened in :utf8 mode. The alternative solution is to enable the
<code>utf8_mode</code> and not decode before passing strings to
<code>$p</code>-&gt;<strong>parse()</strong>. The parser can process raw
undecoded UTF-8 sanely if the <code>utf8_mode</code> is enabled, or if
the <code>attr</code>, <code>@attr</code> or <code>dtext</code> argspecs
are avoided.</p>
</dd>
<dt>Parsing string decoded with wrong endian selection</dt>
<dd>
<p>(W) The first character in the document is U+FFFE. This is not a
legal Unicode character but a byte swapped <code>BOM</code>. The result
of parsing will likely be garbage.</p>
</dd>
<dt>Parsing of undecoded UTF-32</dt>
<dd>
<p>(W) The parser found the Unicode UTF-32 <code>BOM</code> signature at
the start of the document. The result of parsing will likely be
garbage.</p>
</dd>
<dt>Parsing of undecoded UTF-16</dt>
<dd>
<p>(W) The parser found the Unicode UTF-16 <code>BOM</code> signature at
the start of the document. The result of parsing will likely be
garbage.</p>
</dd>
</dl>
<h1>SEE ALSO</h1>
<p>HTML::Entities, HTML::PullParser, HTML::TokeParser, HTML::HeadParser,
HTML::LinkExtor, HTML::Form</p>
<p>HTML::TreeBuilder (part of the <em>HTML-Tree</em> distribution)</p>
<p>&lt;http://www.w3.org/TR/html4/&gt;</p>
<p>More information about marked sections and processing instructions
may be found at &lt;http://www.is-thought.co.uk/book/sgml-8.htm&gt;.</p>
<h1>COPYRIGHT</h1>
<p>Copyright 1996-2016 Gisle Aas. All rights reserved. Copyright
1999-2000 Michael A. Chase. All rights reserved.</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
