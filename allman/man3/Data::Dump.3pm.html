<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>Data::Dump - Pretty printing of data structures</p>
<h1>SYNOPSIS</h1>
<p>use Data::Dump qw(dump); $str = dump(@list); @copy_of_list = eval
$str; # or use it for easy debug printout use Data::Dump; dd
localtime;</p>
<h1>DESCRIPTION</h1>
<p>This module provides a few functions that traverse their argument
list and return a string containing Perl code that, when
<code>eval</code>ed, produces a deep copy of the original arguments.</p>
<p>The main feature of the module is that it strives to produce output
that is easy to read. Example:</p>
<p>@a = (1, [2, 3], {4 =&gt; 5}); dump(@a);</p>
<p>Produces:</p>
<p>"(1, [2, 3], { 4 =&gt; 5 })"</p>
<p>If you dump just a little data, it is output on a single line. If you
dump data that is more complex or there is a lot of it, line breaks are
automatically added to keep it easy to read.</p>
<p>The following functions are provided (only the dd* functions are
exported by default):</p>
<dl>
<dt>dump( ... )</dt>
<dd>

</dd>
</dl>
<dl>
<dt>pp( ... )</dt>
<dd>

</dd>
</dl>
<p>Returns a string containing a Perl expression. If you pass this
string to Perl's built-in <strong>eval()</strong> function it should
return a copy of the arguments you passed to <strong>dump()</strong>. If
you call the function with multiple arguments then the output will be
wrapped in parenthesis ( ..., ... ). If you call the function with a
single argument the output will not have the wrapping. If you call the
function with a single scalar (non-reference) argument it will just
return the scalar quoted if needed, but never break it into multiple
lines. If you pass multiple arguments or references to arrays of hashes
then the return value might contain line breaks to format it for easier
reading. The returned string will never be \n terminated, even if
contains multiple lines. This allows code like this to place the
semicolon in the expected place: print $obj = , dump($obj), ";\n"; If
<strong>dump()</strong> is called in void context, then the dump is
printed on STDERR and then \n terminated. You might find this useful for
quick debug printouts, but the dd*() functions might be better
alternatives for this. There is no difference between
<strong>dump()</strong> and <strong>pp()</strong>, except that
<strong>dump()</strong> shares its name with a not-so-useful perl
builtin. Because of this some might want to avoid using that name.</p>
<dl>
<dt>quote( $string )</dt>
<dd>
<p>Returns a quoted version of the provided string. It differs from
<code>dump($string)</code> in that it will quote even numbers and not
try to come up with clever expressions that might shorten the output. If
a non-scalar argument is provided then it's just stringified instead of
traversed.</p>
</dd>
<dt>dd( ... )</dt>
<dd>

</dd>
</dl>
<dl>
<dt>ddx( ... )</dt>
<dd>

</dd>
</dl>
<p>These functions will call <strong>dump()</strong> on their argument
and print the result to STDOUT (actually, it's the currently selected
output handle, but STDOUT is the default for that). The difference
between them is only that <strong>ddx()</strong> will prefix the lines
it prints with # and mark the first line with the file and line number
where it was called. This is meant to be useful for debug printouts of
state within programs.</p>
<dl>
<dt>dumpf( ..., \&amp;filter )</dt>
<dd>
<p>Short hand for calling the <strong>dump_filtered()</strong> function
of Data::Dump::Filtered. This works like <strong>dump()</strong>, but
the last argument should be a filter callback function. As objects are
visited the filter callback is invoked and it can modify how the objects
are dumped.</p>
</dd>
</dl>
<h1>CONFIGURATION</h1>
<p>There are a few global variables that can be set to modify the output
generated by the dump functions. It's wise to localize the setting of
these.</p>
<dl>
<dt>$Data::Dump::INDENT</dt>
<dd>
<p>This holds the string that's used for indenting multiline data
structures. It's default value is (two spaces). Set it to " to suppress
indentation. Setting it to | " makes for nice visuals even if the dump
output then fails to be valid Perl.</p>
</dd>
<dt>$Data::Dump::TRY_BASE64</dt>
<dd>
<p>How long must a binary string be before we try to use the base64
encoding for the dump output. The default is 50. Set it to 0 to disable
base64 dumps.</p>
</dd>
<dt>$Data::Dump::LINEWIDTH</dt>
<dd>
<p>This controls how wide the string should before we add a line break.
The default is 60.</p>
</dd>
</dl>
<h1>LIMITATIONS</h1>
<p>Code references will be dumped as <code>sub { ... }</code>. Thus,
<code>eval</code>ing them will not reproduce the original routine. The
<code>...</code>-operator used will also require perl-5.12 or better to
be evaled.</p>
<p>If you forget to explicitly import the <code>dump</code> function,
your code will core dump. That's because you just called the builtin
<code>dump</code> function by accident, which intentionally dumps core.
Because of this you can also import the same function as
<code>pp</code>, mnemonic for pretty-print.</p>
<h1>HISTORY</h1>
<p>The <code>Data::Dump</code> module grew out of frustration with
Sarathy's in-most-cases-excellent <code>Data::Dumper</code>. Basic ideas
and some code are shared with Sarathy's module.</p>
<p>The <code>Data::Dump</code> module provides a much simpler interface
than <code>Data::Dumper</code>. No OO interface is available and there
are fewer configuration options to worry about. The other benefit is
that the dump produced does not try to set any variables. It only
returns what is needed to produce a copy of the arguments. This means
that <code>dump("foo")</code> simply returns <code>"foo"</code>, and
<code>dump(1..3)</code> simply returns <code>(1, 2, 3)</code>.</p>
<h1>SEE ALSO</h1>
<p>Data::Dump::Filtered, Data::Dump::Trace, Data::Dumper, JSON,
Storable</p>
<h1>AUTHORS</h1>
<p>The <code>Data::Dump</code> module is written by Gisle Aas
&lt;gisle@aas.no&gt;, based on <code>Data::Dumper</code> by Gurusamy
Sarathy &lt;gsar@umich.edu&gt;.</p>
<p>Copyright 1998-2010 Gisle Aas. Copyright 1996-1998 Gurusamy
Sarathy.</p>
<p>This distribution is currenly maintained by Breno G. de Oliveira.</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.</p>
