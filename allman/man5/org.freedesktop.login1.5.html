<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>org.freedesktop.login1 - The D-Bus interface of systemd-logind</p>
<h1>INTRODUCTION</h1>
<p><strong>systemd-logind.service</strong>(8) is a system service that
keeps track of user logins and seats.</p>
<p>The daemon provides both a C library interface as well as a D-Bus
interface. The library interface may be used to introspect and watch the
state of user logins and seats. The bus interface provides the same
functionality but in addition may also be used to make changes to the
system state. For more information please consult
<strong>sd-login</strong>(3).</p>
<h1>THE MANAGER OBJECT</h1>
<p>The service exposes the following interfaces on the Manager object on
the bus:</p>
<blockquote>
<pre><code>node /org/freedesktop/login1 {
  interface org.freedesktop.login1.Manager {
    methods:
      GetSession(in  s session_id,
                 out o object_path);
      GetSessionByPID(in  u pid,
                      out o object_path);
      GetUser(in  u uid,
              out o object_path);
      GetUserByPID(in  u pid,
                   out o object_path);
      GetSeat(in  s seat_id,
              out o object_path);
      ListSessions(out a(susso) sessions);
      ListUsers(out a(uso) users);
      ListSeats(out a(so) seats);
      ListInhibitors(out a(ssssuu) inhibitors);
      @org.freedesktop.systemd1.Privileged(&quot;true&quot;)
      CreateSession(in  u uid,
                    in  u pid,
                    in  s service,
                    in  s type,
                    in  s class,
                    in  s desktop,
                    in  s seat_id,
                    in  u vtnr,
                    in  s tty,
                    in  s display,
                    in  b remote,
                    in  s remote_user,
                    in  s remote_host,
                    in  a(sv) properties,
                    out s session_id,
                    out o object_path,
                    out s runtime_path,
                    out h fifo_fd,
                    out u uid,
                    out s seat_id,
                    out u vtnr,
                    out b existing);
      @org.freedesktop.systemd1.Privileged(&quot;true&quot;)
      ReleaseSession(in  s session_id);
      ActivateSession(in  s session_id);
      ActivateSessionOnSeat(in  s session_id,
                            in  s seat_id);
      LockSession(in  s session_id);
      UnlockSession(in  s session_id);
      LockSessions();
      UnlockSessions();
      KillSession(in  s session_id,
                  in  s who,
                  in  i signal_number);
      KillUser(in  u uid,
               in  i signal_number);
      TerminateSession(in  s session_id);
      TerminateUser(in  u uid);
      TerminateSeat(in  s seat_id);
      SetUserLinger(in  u uid,
                    in  b enable,
                    in  b interactive);
      AttachDevice(in  s seat_id,
                   in  s sysfs_path,
                   in  b interactive);
      FlushDevices(in  b interactive);
      PowerOff(in  b interactive);
      PowerOffWithFlags(in  t flags);
      Reboot(in  b interactive);
      RebootWithFlags(in  t flags);
      Halt(in  b interactive);
      HaltWithFlags(in  t flags);
      Suspend(in  b interactive);
      SuspendWithFlags(in  t flags);
      Hibernate(in  b interactive);
      HibernateWithFlags(in  t flags);
      HybridSleep(in  b interactive);
      HybridSleepWithFlags(in  t flags);
      SuspendThenHibernate(in  b interactive);
      SuspendThenHibernateWithFlags(in  t flags);
      CanPowerOff(out s result);
      CanReboot(out s result);
      CanHalt(out s result);
      CanSuspend(out s result);
      CanHibernate(out s result);
      CanHybridSleep(out s result);
      CanSuspendThenHibernate(out s result);
      ScheduleShutdown(in  s type,
                       in  t usec);
      CancelScheduledShutdown(out b cancelled);
      Inhibit(in  s what,
              in  s who,
              in  s why,
              in  s mode,
              out h pipe_fd);
      CanRebootParameter(out s result);
      SetRebootParameter(in  s parameter);
      CanRebootToFirmwareSetup(out s result);
      SetRebootToFirmwareSetup(in  b enable);
      CanRebootToBootLoaderMenu(out s result);
      SetRebootToBootLoaderMenu(in  t timeout);
      CanRebootToBootLoaderEntry(out s result);
      SetRebootToBootLoaderEntry(in  s boot_loader_entry);
      SetWallMessage(in  s wall_message,
                     in  b enable);
    signals:
      SessionNew(s session_id,
                 o object_path);
      SessionRemoved(s session_id,
                     o object_path);
      UserNew(u uid,
              o object_path);
      UserRemoved(u uid,
                  o object_path);
      SeatNew(s seat_id,
              o object_path);
      SeatRemoved(s seat_id,
                  o object_path);
      PrepareForShutdown(b start);
      PrepareForSleep(b start);
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      @org.freedesktop.systemd1.Privileged(&quot;true&quot;)
      readwrite b EnableWallMessages = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      @org.freedesktop.systemd1.Privileged(&quot;true&quot;)
      readwrite s WallMessage = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u NAutoVTs = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly as KillOnlyUsers = [..., ...];
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly as KillExcludeUsers = [..., ...];
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly b KillUserProcesses = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly s RebootParameter = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b RebootToFirmwareSetup = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly t RebootToBootLoaderMenu = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly s RebootToBootLoaderEntry = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly as BootLoaderEntries = [..., ...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      readonly s BlockInhibited = ...;
      readonly s DelayInhibited = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t InhibitDelayMaxUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t UserStopDelayUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandlePowerKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandlePowerKeyLongPress = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleRebootKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleRebootKeyLongPress = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleSuspendKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleSuspendKeyLongPress = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleHibernateKey = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleHibernateKeyLongPress = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleLidSwitch = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleLidSwitchExternalPower = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s HandleLidSwitchDocked = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t HoldoffTimeoutUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s IdleAction = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t IdleActionUSec = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b PreparingForShutdown = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b PreparingForSleep = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly (st) ScheduledShutdown = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b Docked = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b LidClosed = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b OnExternalPower = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly b RemoveIPC = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t RuntimeDirectorySize = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t RuntimeDirectoryInodesMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t InhibitorsMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly t NCurrentInhibitors = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t SessionsMax = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly t NCurrentSessions = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t StopIdleSessionUSec = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
</blockquote>
<h2>Methods</h2>
<p><strong>GetSession()</strong> may be used to get the session object
path for the session with the specified ID. Similarly,
<strong>GetUser()</strong> and <strong>GetSeat()</strong> get the user
and seat objects, respectively. <strong>GetSessionByPID()</strong> and
<strong>GetUserByPID()</strong> get the session/user object the
specified PID belongs to if there is any.</p>
<p><strong>ListSessions()</strong> returns an array of all current
sessions. The structures in the array consist of the following fields:
session id, user id, user name, seat id, session object path. If a
session does not have a seat attached, the seat id field will be an
empty string.</p>
<p><strong>ListUsers()</strong> returns an array of all currently logged
in users. The structures in the array consist of the following fields:
user id, user name, user object path.</p>
<p><strong>ListSeats()</strong> returns an array of all currently
available seats. The structure in the array consists of the following
fields: seat id, seat object path.</p>
<p><strong>ListInhibitors()</strong> lists all currently active
inhibitors. It returns an array of structures consisting of
<em>what</em>, <em>who</em>, <em>why</em>, <em>mode</em>, <em>uid</em>
(user ID), and <em>pid</em> (process ID).</p>
<p><strong>CreateSession()</strong> and
<strong>ReleaseSession()</strong> may be used to open or close login
sessions. These calls should <em>never</em> be invoked directly by
clients. Creating/closing sessions is exclusively the job of PAM and its
<strong>pam_systemd</strong>(8) module.</p>
<p><strong>ActivateSession()</strong> brings the session with the
specified ID into the foreground.
<strong>ActivateSessionOnSeat()</strong> does the same, but only if the
seat id matches.</p>
<p><strong>LockSession()</strong> asks the session with the specified ID
to activate the screen lock. <strong>UnlockSession()</strong> asks the
session with the specified ID to remove an active screen lock, if there
is any. This is implemented by sending out the Lock() and Unlock()
signals from the respective session object which session managers are
supposed to listen on.</p>
<p><strong>LockSessions()</strong> asks all sessions to activate their
screen locks. This may be used to lock access to the entire machine in
one action. Similarly, <strong>UnlockSessions()</strong> asks all
sessions to deactivate their screen locks.</p>
<p><strong>KillSession()</strong> may be used to send a Unix signal to
one or all processes of a session. As arguments it takes the session id,
either the string "leader" or "all" and a signal number. If "leader" is
passed only the session "leader" is killed. If "all" is passed all
processes of the session are killed.</p>
<p><strong>KillUser()</strong> may be used to send a Unix signal to all
processes of a user. As arguments it takes the user id and a signal
number.</p>
<p><strong>TerminateSession()</strong>,
<strong>TerminateUser()</strong>, <strong>TerminateSeat()</strong> may
be used to forcibly terminate one specific session, all processes of a
user, and all sessions attached to a specific seat, respectively. The
session, user, and seat are identified by their respective IDs.</p>
<p><strong>SetUserLinger()</strong> enables or disables user lingering.
If enabled, the runtime directory of a user is kept around and they may
continue to run processes while logged out. If disabled, the runtime
directory goes away as soon as they log out.
<strong>SetUserLinger()</strong> expects three arguments: the UID, a
boolean whether to enable/disable and a boolean controlling the
<strong>polkit</strong>[1] authorization interactivity (see below). Note
that the user linger state is persistently stored on disk.</p>
<p><strong>AttachDevice()</strong> may be used to assign a specific
device to a specific seat. The device is identified by its /sys/ path
and must be eligible for seat assignments.
<strong>AttachDevice()</strong> takes three arguments: the seat id, the
sysfs path, and a boolean for controlling polkit interactivity (see
below). Device assignments are persistently stored on disk. To create a
new seat, simply specify a previously unused seat id. For more
information about the seat assignment logic see
<strong>sd-login</strong>(3).</p>
<p><strong>FlushDevices()</strong> removes all explicit seat assignments
for devices, resetting all assignments to the automatic defaults. The
only argument it takes is the polkit interactivity boolean (see
below).</p>
<p><strong>PowerOff()</strong>, <strong>Reboot()</strong>,
<strong>Halt()</strong>, <strong>Suspend()</strong>, and
<strong>Hibernate()</strong> result in the system being powered off,
rebooted, halted (shut down without turning off power), suspended (the
system state is saved to RAM and the CPU is turned off), or hibernated
(the system state is saved to disk and the machine is powered down).
<strong>HybridSleep()</strong> results in the system entering a
hybrid-sleep mode, i.e. the system is both hibernated and suspended.
<strong>SuspendThenHibernate()</strong> results in the system being
suspended, then later woken using an RTC timer and hibernated. The only
argument is the polkit interactivity boolean <em>interactive</em> (see
below). The main purpose of these calls is that they enforce polkit
policy and hence allow powering off/rebooting/suspending/hibernating
even by unprivileged users. They also enforce inhibition locks for
non-privileged users. UIs should expose these calls as the primary
mechanism to poweroff/reboot/suspend/hibernate the machine. Methods
<strong>PowerOffWithFlags()</strong>,
<strong>RebootWithFlags()</strong>, <strong>HaltWithFlags()</strong>,
<strong>SuspendWithFlags()</strong>,
<strong>HibernateWithFlags()</strong>,
<strong>HybridSleepWithFlags()</strong> and
<strong>SuspendThenHibernateWithFlags()</strong> add <em>flags</em> to
allow for extendability, defined as follows:</p>
<blockquote>
<pre><code>#define SD_LOGIND_ROOT_CHECK_INHIBITORS  (UINT64_C(1) &lt;&lt; 0)
#define SD_LOGIND_KEXEC_REBOOT           (UINT64_C(1) &lt;&lt; 1)
      </code></pre>
</blockquote>
<p>When the <em>flags</em> is 0 then these methods behave just like the
versions without flags. When
<strong>SD_LOGIND_ROOT_CHECK_INHIBITORS</strong> (0x01) is set, active
inhibitors are honoured for privileged users too. When
<strong>SD_LOGIND_KEXEC_REBOOT</strong> (0x02) is set, then
<strong>RebootWithFlags()</strong> perform kexec reboot if kexec kernel
is loaded.</p>
<p><strong>SetRebootParameter()</strong> sets a parameter for a
subsequent reboot operation. See the description of
<strong>reboot</strong> in <strong>systemctl</strong>(1) and
<strong>reboot</strong>(2) for more information.</p>
<p><strong>SetRebootToFirmwareSetup()</strong>,
<strong>SetRebootToBootLoaderMenu()</strong>, and
<strong>SetRebootToBootLoaderEntry()</strong> configure the action to be
taken from the boot loader after a reboot: respectively entering
firmware setup mode, the boot loader menu, or a specific boot loader
entry. See <strong>systemctl</strong>(1) for the corresponding command
line interface.</p>
<p><strong>CanPowerOff()</strong>, <strong>CanReboot()</strong>,
<strong>CanHalt()</strong>, <strong>CanSuspend()</strong>,
<strong>CanHibernate()</strong>, <strong>CanHybridSleep()</strong>,
<strong>CanSuspendThenHibernate()</strong>,
<strong>CanRebootParameter()</strong>,
<strong>CanRebootToFirmwareSetup()</strong>,
<strong>CanRebootToBootLoaderMenu()</strong>, and
<strong>CanRebootToBootLoaderEntry()</strong> test whether the system
supports the respective operation and whether the calling user is
allowed to execute it. Returns one of "na", "yes", "no", and
"challenge". If "na" is returned, the operation is not available because
hardware, kernel, or drivers do not support it. If "yes" is returned,
the operation is supported and the user may execute the operation
without further authentication. If "no" is returned, the operation is
available but the user is not allowed to execute the operation. If
"challenge" is returned, the operation is available but only after
authorization.</p>
<p><strong>ScheduleShutdown()</strong> schedules a shutdown operation
<em>type</em> at time <em>usec</em> in microseconds since the UNIX
epoch. <em>type</em> can be one of "poweroff", "dry-poweroff", "reboot",
"dry-reboot", "halt", and "dry-halt". (The "dry-" variants do not
actually execute the shutdown action.)
<strong>CancelScheduledShutdown()</strong> cancels a scheduled shutdown.
The output parameter <em>cancelled</em> is true if a shutdown operation
was scheduled.</p>
<p><strong>SetWallMessage()</strong> sets the wall message (the message
that will be sent out to all terminals and stored in a
<strong>utmp</strong>(5) record) for a subsequent scheduled shutdown
operation. The parameter <em>wall_message</em> specifies the shutdown
reason (and may be empty) which will be included in the shutdown
message. The parameter <em>enable</em> specifies whether to print a wall
message on shutdown.</p>
<p><strong>Inhibit()</strong> creates an inhibition lock. It takes four
parameters: <em>what</em>, <em>who</em>, <em>why</em>, and
<em>mode</em>. <em>what</em> is one or more of "shutdown", "sleep",
"idle", "handle-power-key", "handle-suspend-key",
"handle-hibernate-key", "handle-lid-switch", separated by colons, for
inhibiting poweroff/reboot, suspend/hibernate, the automatic idle logic,
or hardware key handling. <em>who</em> should be a short human readable
string identifying the application taking the lock. <em>why</em> should
be a short human readable string identifying the reason why the lock is
taken. Finally, <em>mode</em> is either "block" or "delay" which encodes
whether the inhibit shall be consider mandatory or whether it should
just delay the operation to a certain maximum time. The method returns a
file descriptor. The lock is released the moment this file descriptor
and all its duplicates are closed. For more information on the
inhibition logic see <strong>Inhibitor Locks</strong>[2].</p>
<h2>Signals</h2>
<p>Whenever the inhibition state or idle hint changes,
<strong>PropertyChanged</strong> signals are sent out to which clients
can subscribe.</p>
<p>The <strong>SessionNew</strong>, <strong>SessionRemoved</strong>,
<strong>UserNew</strong>, <strong>UserRemoved</strong>,
<strong>SeatNew</strong>, and <strong>SeatRemoved</strong> signals are
sent each time a session is created or removed, a user logs in or out,
or a seat is added or removed. They each contain the ID of the object
plus the object path.</p>
<p>The <strong>PrepareForShutdown()</strong> and
<strong>PrepareForSleep()</strong> signals are sent right before (with
the argument "true") or after (with the argument "false") the system
goes down for reboot/poweroff and suspend/hibernate, respectively. This
may be used by applications to save data on disk, release memory, or do
other jobs that should be done shortly before shutdown/sleep, in
conjunction with delay inhibitor locks. After completion of this work
they should release their inhibition locks in order to not delay the
operation any further. For more information see <strong>Inhibitor
Locks</strong>[2].</p>
<h2>Properties</h2>
<p>Most properties simply reflect the configuration, see
<strong>logind.conf</strong>(5). This includes: <em>NAutoVTs</em>,
<em>KillOnlyUsers</em>, <em>KillExcludeUsers</em>,
<em>KillUserProcesses</em>, <em>IdleAction</em>,
<em>InhibitDelayMaxUSec</em>, <em>InhibitorsMax</em>,
<em>UserStopDelayUSec</em>, <em>HandlePowerKey</em>,
<em>HandleSuspendKey</em>, <em>HandleHibernateKey</em>,
<em>HandleLidSwitch</em>, <em>HandleLidSwitchExternalPower</em>,
<em>HandleLidSwitchDocked</em>, <em>IdleActionUSec</em>,
<em>HoldoffTimeoutUSec</em>, <em>RemoveIPC</em>,
<em>RuntimeDirectorySize</em>, <em>RuntimeDirectoryInodesMax</em>,
<em>InhibitorsMax</em>, and <em>SessionsMax</em>.</p>
<p>The <em>IdleHint</em> property reflects the idle hint state of the
system. If the system is idle it might get into automatic suspend or
shutdown depending on the configuration.</p>
<p><em>IdleSinceHint</em> and <em>IdleSinceHintMonotonic</em> encode the
timestamps of the last change of the idle hint boolean, in
<strong>CLOCK_REALTIME</strong> and <strong>CLOCK_MONOTONIC</strong>
timestamps, respectively, in microseconds since the epoch.</p>
<p>The <em>BlockInhibited</em> and <em>DelayInhibited</em> properties
encode the currently active locks of the respective modes. They are
colon separated lists of "shutdown", "sleep", and "idle" (see
above).</p>
<p><em>NCurrentSessions</em> and <em>NCurrentInhibitors</em> contain the
number of currently registered sessions and inhibitors.</p>
<p>The <em>BootLoaderEntries</em> property contains a list of boot
loader entries. This includes boot loader entries defined in
configuration and any additional loader entries reported by the boot
loader. See <strong>systemd-boot</strong>(7) for more information.</p>
<p>The <em>PreparingForShutdown</em> and <em>PreparingForSleep</em>
boolean properties are true during the interval between the two
<strong>PrepareForShutdown</strong> and <strong>PrepareForSleep</strong>
signals respectively. Note that these properties do not send out
<strong>PropertyChanged</strong> signals.</p>
<p>The <em>RebootParameter</em> property shows the value set with the
<strong>SetRebootParameter()</strong> method described above.</p>
<p><em>ScheduledShutdown</em> shows the value pair set with the
<strong>ScheduleShutdown()</strong> method described above.</p>
<p><em>RebootToFirmwareSetup</em>, <em>RebootToBootLoaderMenu</em>, and
<em>RebootToBootLoaderEntry</em> are true when the resprective
post-reboot operation was selected with
<strong>SetRebootToFirmwareSetup</strong>,
<strong>SetRebootToBootLoaderMenu</strong>, or
<strong>SetRebootToBootLoaderEntry</strong>.</p>
<p>The <em>WallMessage</em> and <em>EnableWallMessages</em> properties
reflect the shutdown reason and wall message enablement switch which can
be set with the <strong>SetWallMessage()</strong> method described
above.</p>
<p><em>Docked</em> is true if the machine is connected to a dock.
<em>LidClosed</em> is true when the lid (of a laptop) is closed.
<em>OnExternalPower</em> is true when the machine is connected to an
external power supply.</p>
<h2>Security</h2>
<p>A number of operations are protected via the polkit privilege system.
<strong>SetUserLinger()</strong> requires the
org.freedesktop.login1.set-user-linger privilege.
<strong>AttachDevice()</strong> requires
org.freedesktop.login1.attach-device and <strong>FlushDevices()</strong>
requires org.freedesktop.login1.flush-devices.
<strong>PowerOff()</strong>, <strong>Reboot()</strong>,
<strong>Halt()</strong>, <strong>Suspend()</strong>,
<strong>Hibernate()</strong> require org.freedesktop.login1.power-off,
org.freedesktop.login1.power-off-multiple-sessions,
org.freedesktop.login1.power-off-ignore-inhibit,
org.freedesktop.login1.reboot,
org.freedesktop.login1.reboot-multiple-sessions,
org.freedesktop.login1.reboot-ignore-inhibit,
org.freedesktop.login1.halt,
org.freedesktop.login1.halt-multiple-sessions,
org.freedesktop.login1.halt-ignore-inhibit,
org.freedesktop.login1.suspend,
org.freedesktop.login1.suspend-multiple-sessions,
org.freedesktop.login1.suspend-ignore-inhibit,
org.freedesktop.login1.hibernate,
org.freedesktop.login1.hibernate-multiple-sessions,
org.freedesktop.login1.hibernate-ignore-inhibit, respectively depending
on whether there are other sessions around or active inhibits are
present. <strong>HybridSleep()</strong> and
<strong>SuspendThenHibernate()</strong> use the same privileges as
<strong>Hibernate()</strong>. <strong>SetRebootParameter()</strong>
requires org.freedesktop.login1.set-reboot-parameter.</p>
<p><strong>SetRebootToFirmwareSetup</strong> requires
org.freedesktop.login1.set-reboot-to-firmware-setup.
<strong>SetRebootToBootLoaderMenu</strong> requires
org.freedesktop.login1.set-reboot-to-boot-loader-menu.
<strong>SetRebootToBootLoaderEntry</strong> requires
org.freedesktop.login1.set-reboot-to-boot-loader-entry.</p>
<p><strong>ScheduleShutdown</strong> and
<strong>CancelScheduledShutdown</strong> require the same privileges
(listed above) as the immediate poweroff/reboot/halt operations.</p>
<p><strong>Inhibit()</strong> is protected via one of
org.freedesktop.login1.inhibit-block-shutdown,
org.freedesktop.login1.inhibit-delay-shutdown,
org.freedesktop.login1.inhibit-block-sleep,
org.freedesktop.login1.inhibit-delay-sleep,
org.freedesktop.login1.inhibit-block-idle,
org.freedesktop.login1.inhibit-handle-power-key,
org.freedesktop.login1.inhibit-handle-suspend-key,
org.freedesktop.login1.inhibit-handle-hibernate-key,
org.freedesktop.login1.inhibit-handle-lid-switch depending on the lock
type and mode taken.</p>
<p>The <em>interactive</em> boolean parameters can be used to control
whether polkit should interactively ask the user for authentication
credentials if required.</p>
<h1>SEAT OBJECTS</h1>
<blockquote>
<pre><code>node /org/freedesktop/login1/seat/seat0 {
  interface org.freedesktop.login1.Seat {
    methods:
      Terminate();
      ActivateSession(in  s session_id);
      SwitchTo(in  u vtnr);
      SwitchToNext();
      SwitchToPrevious();
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Id = ...;
      readonly (so) ActiveSession = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly b CanTTY = ...;
      readonly b CanGraphical = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly a(so) Sessions = [...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
</blockquote>
<h2>Methods</h2>
<p><strong>Terminate()</strong> and <strong>ActivateSession()</strong>
work similarly to <strong>TerminateSeat()</strong> and
<strong>ActivationSessionOnSeat()</strong> on the Manager object.</p>
<p><strong>SwitchTo()</strong> switches to the session on the virtual
terminal <em>vtnr</em>. <strong>SwitchToNext()</strong> and
<strong>SwitchToPrevious()</strong> switch to, respectively, the next
and previous sessions on the seat in the order of virtual terminals. If
there is no active session, they switch to, respectively, the first and
last session on the seat.</p>
<h2>Signals</h2>
<p>Whenever <strong>ActiveSession</strong>, <strong>Sessions</strong>,
<strong>CanGraphical</strong>, <strong>CanTTY</strong>, or the idle
state changes, <strong>PropertyChanged</strong> signals are sent out to
which clients can subscribe.</p>
<h2>Properties</h2>
<p>The <em>Id</em> property encodes the ID of the seat.</p>
<p><em>ActiveSession</em> encodes the currently active session if there
is one. It is a structure consisting of the session id and the object
path.</p>
<p><em>CanTTY</em> encodes whether the session is suitable for text
logins, and <em>CanGraphical</em> whether it is suitable for graphical
sessions.</p>
<p>The <em>Sessions</em> property is an array of all current sessions of
this seat, each encoded in a structure consisting of the ID and the
object path.</p>
<p>The <em>IdleHint</em>, <em>IdleSinceHint</em>, and
<em>IdleSinceHintMonotonic</em> properties encode the idle state,
similarly to the ones exposed on the Manager object, but specific for
this seat.</p>
<h1>USER OBJECTS</h1>
<blockquote>
<pre><code>node /org/freedesktop/login1/user/_1000 {
  interface org.freedesktop.login1.User {
    methods:
      Terminate();
      Kill(in  i signal_number);
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u UID = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u GID = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Name = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t Timestamp = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t TimestampMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s RuntimePath = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Service = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Slice = ...;
      readonly (so) Display = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly s State = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly a(so) Sessions = [...];
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;false&quot;)
      readonly b Linger = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
</blockquote>
<h2>Methods</h2>
<p><strong>Terminate()</strong> and <strong>Kill()</strong> work
similarly to the <strong>TerminateUser()</strong> and
<strong>KillUser()</strong> methods on the manager object.</p>
<h2>Signals</h2>
<p>Whenever <em>Sessions</em> or the idle state changes,
<strong>PropertyChanged</strong> signals are sent out to which clients
can subscribe.</p>
<h2>Properties</h2>
<p>The <em>UID</em> and <em>GID</em> properties encode the Unix UID and
primary GID of the user.</p>
<p>The <em>Name</em> property encodes the user name.</p>
<p><em>Timestamp</em> and <em>TimestampMonotonic</em> encode the login
time of the user in microseconds since the epoch, in the
<strong>CLOCK_REALTIME</strong> and <strong>CLOCK_MONOTONIC</strong>
clocks, respectively.</p>
<p><em>RuntimePath</em> encodes the runtime path of the user, i.e.
<em>$XDG_RUNTIME_DIR</em>. For details see the <strong>XDG Basedir
Specification</strong>[3].</p>
<p><em>Service</em> contains the unit name of the user systemd service
of this user. Each logged in user is assigned a user service that runs a
user systemd instance. This is usually an instance of user@.service.</p>
<p><em>Slice</em> contains the unit name of the user systemd slice of
this user. Each logged in user gets a private slice.</p>
<p><em>Display</em> encodes which graphical session should be used as
the primary UI display for the user. It is a structure encoding the
session ID and the object path of the session to use.</p>
<p><em>State</em> encodes the user state and is one of "offline",
"lingering", "online", "active", or "closing". See
<strong>sd_uid_get_state</strong>(3) for more information about the
states.</p>
<p><em>Sessions</em> is an array of structures encoding all current
sessions of the user. Each structure consists of the ID and object
path.</p>
<p>The <em>IdleHint</em>, <em>IdleSinceHint</em>, and
<em>IdleSinceHintMonotonic</em> properties encode the idle hint state of
the user, similarly to the Managers properties, but specific for this
user.</p>
<p>The <em>Linger</em> property shows whether lingering is enabled for
this user.</p>
<h1>SESSION OBJECTS</h1>
<blockquote>
<pre><code>node /org/freedesktop/login1/session/1 {
  interface org.freedesktop.login1.Session {
    methods:
      Terminate();
      Activate();
      Lock();
      Unlock();
      SetIdleHint(in  b idle);
      SetLockedHint(in  b locked);
      Kill(in  s who,
           in  i signal_number);
      TakeControl(in  b force);
      ReleaseControl();
      SetType(in  s type);
      SetDisplay(in  s display);
      TakeDevice(in  u major,
                 in  u minor,
                 out h fd,
                 out b inactive);
      ReleaseDevice(in  u major,
                    in  u minor);
      PauseDeviceComplete(in  u major,
                          in  u minor);
      SetBrightness(in  s subsystem,
                    in  s name,
                    in  u brightness);
    signals:
      PauseDevice(u major,
                  u minor,
                  s type);
      ResumeDevice(u major,
                   u minor,
                   h fd);
      Lock();
      Unlock();
    properties:
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Id = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly (uo) User = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Name = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t Timestamp = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly t TimestampMonotonic = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u VTNr = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly (so) Seat = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s TTY = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Display = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly b Remote = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s RemoteHost = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s RemoteUser = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Service = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Desktop = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Scope = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u Leader = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly u Audit = ...;
      readonly s Type = ...;
      @org.freedesktop.DBus.Property.EmitsChangedSignal(&quot;const&quot;)
      readonly s Class = ...;
      readonly b Active = ...;
      readonly s State = ...;
      readonly b IdleHint = ...;
      readonly t IdleSinceHint = ...;
      readonly t IdleSinceHintMonotonic = ...;
      readonly b LockedHint = ...;
  };
  interface org.freedesktop.DBus.Peer { ... };
  interface org.freedesktop.DBus.Introspectable { ... };
  interface org.freedesktop.DBus.Properties { ... };
};
    </code></pre>
</blockquote>
<h2>Methods</h2>
<p><strong>Terminate()</strong>, <strong>Activate()</strong>,
<strong>Lock()</strong>, <strong>Unlock()</strong>, and
<strong>Kill()</strong> work similarly to the respective calls on the
Manager object.</p>
<p><strong>SetIdleHint()</strong> is called by the session object to
update the idle state of the session whenever it changes.</p>
<p><strong>TakeControl()</strong> allows a process to take exclusive
managed device access-control for that session. Only one D-Bus
connection can be a controller for a given session at any time. If the
<em>force</em> argument is set (root only), an existing controller is
kicked out and replaced. Otherwise, this method fails if there is
already a controller. Note that this method is limited to D-Bus users
with the effective UID set to the user of the session or root.</p>
<p><strong>ReleaseControl()</strong> drops control of a given session.
Closing the D-Bus connection implicitly releases control as well. See
<strong>TakeControl()</strong> for more information. This method also
releases all devices for which the controller requested ownership via
<strong>TakeDevice()</strong>.</p>
<p><strong>SetType()</strong> allows the type of the session to be
changed dynamically. It can only be called by sessions current
controller. If <strong>TakeControl()</strong> has not been called, this
method will fail. In addition, the session type will be reset to its
original value once control is released, either by calling
<strong>ReleaseControl()</strong> or closing the D-Bus connection. This
should help prevent a session from entering an inconsistent state, for
example if the controller crashes. The only argument <em>type</em> is
the new session type.</p>
<p><strong>SetDisplay()</strong> allows the display name of the
graphical session to be changed. This is useful if the display server is
started as part of the session. It can only be called by sessions
current controller. If <strong>TakeControl()</strong> has not been
called, this method will fail. The only argument <em>display</em> is the
new display name.</p>
<p><strong>TakeDevice()</strong> allows a session controller to get a
file descriptor for a specific device. Pass in the major and minor
numbers of the character device and systemd-logind will return a file
descriptor for the device. Only a limited set of device-types is
currently supported (but may be extended). systemd-logind automatically
mutes the file descriptor if the session is inactive and resumes it once
the session is activated again. This guarantees that a session can only
access session devices if the session is active. Note that this
revoke/resume mechanism is asynchronous and may happen at any given
time. This only works on devices that are attached to the seat of the
given session. A process is not required to have direct access to the
device node. systemd-logind only requires you to be the active session
controller (see <strong>TakeControl()</strong>). Also note that any
device can only be requested once. As long as you dont release it,
further <strong>TakeDevice()</strong> calls will fail.</p>
<p><strong>ReleaseDevice()</strong> releases a device again (see
<strong>TakeDevice()</strong>). This is also implicitly done by
<strong>ReleaseControl()</strong> or when closing the D-Bus
connection.</p>
<p><strong>PauseDeviceComplete()</strong> allows a session controller to
synchronously pause a device after receiving a
<strong>PauseDevice("pause")</strong> signal. Forced signals (or after
an internal timeout) are automatically completed by systemd-logind
asynchronously.</p>
<p><strong>SetLockedHint()</strong> may be used to set the "locked hint"
to <em>locked</em>, i.e. information whether the session is locked. This
is intended to be used by the desktop environment to tell
<strong>systemd-logind</strong> when the session is locked and
unlocked.</p>
<p><strong>SetBrightness()</strong> may be used to set the display
brightness. This is intended to be used by the desktop environment and
allows unprivileged programs to access hardware settings in a controlled
way. The <em>subsystem</em> parameter specifies a kernel subsystem,
either "backlight" or "leds". The <em>name</em> parameter specifies a
device name under the specified subsystem. The <em>brightness</em>
parameter specifies the brightness. The range is defined by individual
drivers, see
/sys/class/<em>subsystem</em>/<em>name</em>/max_brightness.</p>
<h2>Signals</h2>
<p>The active session controller exclusively gets
<strong>PauseDevice</strong> and <strong>ResumeDevice</strong> events
for any device it requested via <strong>TakeDevice()</strong>. They
notify the controller whenever a device is paused or resumed. A device
is never resumed if its session is inactive. Also note that
<strong>PauseDevice</strong> signals are sent before the
<strong>PropertyChanged</strong> signal for the <strong>Active</strong>
state. The inverse is true for <strong>ResumeDevice</strong>. A device
may remain paused for unknown reasons even though the Session is
active.</p>
<p>A <strong>PauseDevice</strong> signal carries the major and minor
numbers and a string describing the type as arguments.
<strong>force</strong> means the device was already paused by
systemd-logind and the signal is only an asynchronous notification.
<strong>pause</strong> means systemd-logind grants you a limited amount
of time to pause the device. You must respond to this via
<strong>PauseDeviceComplete()</strong>. This synchronous pausing
mechanism is used for backwards-compatibility to VTs and systemd-logind
is free to not make use of it. It is also free to send a forced
<strong>PauseDevice</strong> if you dont respond in a timely manner (or
for any other reason). <strong>gone</strong> means the device was
unplugged from the system and you will no longer get any notifications
about it. There is no need to call <strong>ReleaseDevice()</strong>. You
may call <strong>TakeDevice()</strong> again if a new device is assigned
the major+minor combination.</p>
<p><strong>ResumeDevice</strong> is sent whenever a session is active
and a device is resumed. It carries the major/minor numbers as arguments
and provides a new open file descriptor. You should switch to the new
descriptor and close the old one. They are not guaranteed to have the
same underlying open file descriptor in the kernel (except for a limited
set of device types).</p>
<p>Whenever <strong>Active</strong> or the idle state changes,
<strong>PropertyChanged</strong> signals are sent out to which clients
can subscribe.</p>
<p><strong>Lock</strong>/<strong>Unlock</strong> is sent when the
session is asked to be screen-locked/unlocked. A session manager of the
session should listen to this signal and act accordingly. This signal is
sent out as a result of the <strong>Lock()</strong> and
<strong>Unlock()</strong> methods, respectively.</p>
<h2>Properties</h2>
<p><em>Id</em> encodes the session ID.</p>
<p><em>User</em> encodes the user ID of the user this session belongs
to. This is a structure consisting of the Unix UID and the object
path.</p>
<p><em>Name</em> encodes the user name.</p>
<p><em>Timestamp</em> and <em>TimestampMonotonic</em> encode the
microseconds since the epoch when the session was created, in
<strong>CLOCK_REALTIME</strong> or <strong>CLOCK_MONOTONIC</strong>,
respectively.</p>
<p><em>VTNr</em> encodes the virtual terminal number of the session if
there is any, 0 otherwise.</p>
<p><em>Seat</em> encodes the seat this session belongs to if there is
any. This is a structure consisting of the ID and the seat object
path.</p>
<p><em>TTY</em> encodes the kernel TTY path of the session if this is a
text login. If not this is an empty string.</p>
<p><em>Display</em> encodes the X11 display name if this is a graphical
login. If not, this is an empty string.</p>
<p><em>Remote</em> encodes whether the session is local or remote.</p>
<p><em>RemoteHost</em> and <em>RemoteUser</em> encode the remote host
and user if this is a remote session, or an empty string otherwise.</p>
<p><em>Service</em> encodes the PAM service name that registered the
session.</p>
<p><em>Desktop</em> describes the desktop environment running in the
session (if known).</p>
<p><em>Scope</em> contains the systemd scope unit name of this
session.</p>
<p><em>Leader</em> encodes the PID of the process that registered the
session.</p>
<p><em>Audit</em> encodes the Kernel Audit session ID of the session if
auditing is available.</p>
<p><em>Type</em> encodes the session type. Its one of "unspecified" (for
cron PAM sessions and suchlike), "tty" (for text logins) or
"x11"/"mir"/"wayland" (for graphical logins).</p>
<p><em>Class</em> encodes the session class. Its one of "user" (for
normal user sessions), "greeter" (for display manager pseudo-sessions),
or "lock-screen" (for display lock screens).</p>
<p><em>Active</em> is a boolean that is true if the session is active,
i.e. currently in the foreground. This field is semi-redundant due to
<em>State</em>.</p>
<p><em>State</em> encodes the session state and one of "online",
"active", or "closing". See <strong>sd_session_get_state</strong>(3) for
more information about the states.</p>
<p><em>IdleHint</em>, <em>IdleSinceHint</em>, and
<em>IdleSinceHintMonotonic</em> encapsulate the idle hint state of this
session, similarly to how the respective properties on the manager
object do it for the whole system.</p>
<p><em>LockedHint</em> shows the locked hint state of this session, as
set by the <strong>SetLockedHint()</strong> method described above.</p>
<h1>EXAMPLES</h1>
<p><strong>Example 1. Introspect the logind manager on the
bus</strong></p>
<blockquote>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1
      </code></pre>
</blockquote>
<p>or</p>
<blockquote>
<pre><code>$ busctl introspect org.freedesktop.login1 /org/freedesktop/login1
      </code></pre>
</blockquote>
<p><strong>Example 2. Introspect the default seat on the
bus</strong></p>
<blockquote>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
 --object-path /org/freedesktop/login1/seat/seat0
      </code></pre>
</blockquote>
<p>or</p>
<blockquote>
<pre><code>$ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/seat/seat0
      </code></pre>
</blockquote>
<p>Seat "seat0" is the default seat, so itll be present unless local
configuration is made to reassign all devices to a different seat. The
list of seats and users can be acquired with <strong>loginctl
list-sessions</strong>.</p>
<p><strong>Example 3. Introspect a single user on the bus</strong></p>
<blockquote>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1/user/_1000
      </code></pre>
</blockquote>
<p>or</p>
<blockquote>
<pre><code>$ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/user/_1000
      </code></pre>
</blockquote>
<p><strong>Example 4. Introspect org.freedesktop.login1.Session on the
bus</strong></p>
<blockquote>
<pre><code>$ gdbus introspect --system --dest org.freedesktop.login1 \
  --object-path /org/freedesktop/login1/session/45
      </code></pre>
</blockquote>
<p>or</p>
<blockquote>
<pre><code>$ busctl introspect org.freedesktop.login1 /org/freedesktop/login1/session/45
      </code></pre>
</blockquote>
<h1>VERSIONING</h1>
<p>These D-Bus interfaces follow <strong>the usual interface versioning
guidelines</strong>[4].</p>
<h1>NOTES</h1>
<dl>
<dt> 1.</dt>
<dd>
<p>polkit</p>
<p>https://www.freedesktop.org/software/polkit/docs/latest/</p>
</dd>
<dt> 2.</dt>
<dd>
<p>Inhibitor Locks</p>
<p>https://www.freedesktop.org/wiki/Software/systemd/inhibit</p>
</dd>
<dt> 3.</dt>
<dd>
<p>XDG Basedir Specification</p>
<p>https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html</p>
</dd>
<dt> 4.</dt>
<dd>
<p>the usual interface versioning guidelines</p>
<p>https://0pointer.de/blog/projects/versioning-dbus.html</p>
</dd>
</dl>
