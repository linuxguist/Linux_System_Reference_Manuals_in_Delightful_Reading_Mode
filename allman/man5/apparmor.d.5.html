<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>apparmor.d - syntax of security profiles for AppArmor.</p>
<h1>DESCRIPTION</h1>
<p>AppArmor profiles describe mandatory access rights granted to given
programs and are fed to the AppArmor policy enforcement module using
<strong>apparmor_parser</strong> (8). This man page describes the format
of the AppArmor configuration files; see <strong>apparmor</strong> (7)
for an overview of AppArmor.</p>
<p>Some features are not supported on Debian yet:</p>
<dl>
<dt>Network Rules</dt>
<dd>

</dd>
</dl>
<dl>
<dt>DBus rules</dt>
<dd>

</dd>
<dt>Unix socket rules</dt>
<dd>

</dd>
</dl>
<h1>FORMAT</h1>
<p>AppArmor policy is written in a declarative language, in which the
order of rules within a given section or block does not matter. Policy
is by convention written so that it is contained in multiple files, but
this is not a requirement. It could just as easily be written in a
single file. The policy language is compiled to a architecture
independent binary format that is loaded into the kernel for
enforcement.</p>
<p>The base unit of AppArmor confinement is the profile. It contains a
set of rules which are enforced when the profile is associated with a
running program. The rules within the profile provide a whitelist of
different permission that are allowed, along with a few other special
rules.</p>
<p>The text in AppArmor policy is split into two sections, the preamble
and the profile definitions. The preamble must occur at the head of the
file and once profile definitions begin, no more preamble rules are
allowed (even in files that are included into the profile). When
AppArmor policy (set of profiles) is split across multiple files, each
file can have its own preamble section, which may be the same or
different from other files preamble. Files included within a profile
section can not have a preamble section.</p>
<p>The following is a BNF-style description of AppArmor policy
configuration files; see below for an example AppArmor policy file.
AppArmor configuration files are line-oriented; <strong>#</strong>
introduces a comment, similar to shell scripting languages. The
exception to this rule is that <strong>#include</strong> will
<em>include</em> the contents of a file inline to the policy; this
behaviour is modelled after <strong>cpp</strong> (1).</p>
<blockquote>
<p><strong>PROFILE FILE</strong> = ( [ <em>PREAMBLE</em> ] [
<em>PROFILE</em> ] )* <strong>PREAMBLE</strong> = ( <em>COMMENT</em> |
<em>VARIABLE ASSIGNMENT</em> | <em>ALIAS RULE</em> | <em>INCLUDE</em> |
<em>ABI</em> )* Variable assignment and alias rules must come before the
profile. <strong>VARIABLE ASSIGNMENT</strong> = <em>VARIABLE</em> ('=' |
'+=') (space separated values) <strong>VARIABLE</strong> = '@{'
<em>ALPHA</em> [ ( <em>ALPHANUMERIC</em> | '_' ) ... ] '}' <strong>ALIAS
RULE</strong> = 'alias' <em>ABS PATH</em> '-&gt;' <em>REWRITTEN ABS
PATH</em> ',' <strong>INCLUDE</strong> = ( '#include' | 'include' ) [
'if exists' ] ( <em>ABS PATH</em> | <em>MAGIC PATH</em> )
<strong>ABI</strong> = ( 'abi' ) ( <em>ABS PATH</em> | <em>MAGIC
PATH</em> ) ',' <strong>ABS PATH</strong> = '' path '' (the path is
passed to <strong>open</strong> (2)) <strong>MAGIC PATH</strong> =
'&lt;' relative path '&gt;' The path is relative to
<em>/etc/apparmor.d/</em>. <strong>COMMENT</strong> = '#' <em>TEXT</em>
[ '\r' ] '\n' <strong>TEXT</strong> = any characters
<strong>PROFILE</strong> = ( <em>PROFILE HEAD</em> ) [ <em>ATTACHMENT
SPECIFICATION</em> ] [ <em>PROFILE FLAG CONDS</em> ] '{' (
<em>RULES</em> )* '}' <strong>PROFILE HEAD</strong> = [ 'profile' ]
<em>FILEGLOB</em> | 'profile' <em>PROFILE NAME</em> <strong>PROFILE
NAME</strong> ( <em>UNQUOTED PROFILE NAME</em> | <em>QUOTED PROFILE
NAME</em> ) <strong>QUOTED PROFILE NAME</strong> = '"' <em>UNQUOTED
PROFILE NAME</em> '"' <strong>UNQUOTED PROFILE NAME</strong> = (must
start with alphanumeric character (after variable expansion), or '/'
<strong>AARE</strong> have special meanings; see below. May include
<em>VARIABLE</em>. Rules with embedded spaces or tabs must be quoted.)
<strong>ATTACHMENT SPECIFICATION</strong> = [ <em>PROFILE_EXEC_COND</em>
] [ <em>PROFILE XATTR CONDS</em> ] <strong>PROFILE_EXEC_COND</strong> =
<em>FILEGLOB</em> <strong>PROFILE XATTR CONDS</strong> = [ 'xattrs=' ]
'(' comma or white space separated list of <em>PROFILE XATTR</em> ')'
<strong>PROFILE XATTR</strong> = extended attribute name '=' <em>XATTR
VALUE FILEGLOB</em> <strong>XATTR VALUE FILEGLOB</strong> =
<em>FILEGLOB</em> <strong>PROFILE FLAG CONDS</strong> = [ 'flags=' ] '('
comma or white space separated list of <em>PROFILE FLAGS</em> ')'
<strong>PROFILE FLAGS</strong> = <em>PROFILE MODE</em> |
<em>AUDIT_MODE</em> | 'mediate_deleted' | 'attach_disconnected' |
'chroot_relative' <strong>PROFILE MODE</strong> = 'enforce' | 'complain'
| 'kill' | 'unconfined' <strong>AUDIT MODE</strong> = 'audit'
<strong>RULES</strong> = [ ( <em>LINE RULES</em> | <em>COMMA RULES</em>
',' | <em>BLOCK RULES</em> ) <strong>LINE RULES</strong> = (
<em>COMMENT</em> | <em>INCLUDE</em> ) [ '\r' ] '\n' <strong>COMMA
RULES</strong> = ( <em>CAPABILITY RULE</em> | <em>NETWORK RULE</em> |
<em>MOUNT RULE</em> | <em>PIVOT ROOT RULE</em> | <em>UNIX RULE</em> |
<em>FILE RULE</em> | <em>LINK RULE</em> | <em>CHANGE_PROFILE RULE</em> |
<em>RLIMIT RULE</em> | <em>DBUS RULE</em> ) <strong>BLOCK RULES</strong>
= ( <em>SUBPROFILE</em> | <em>HAT</em> | <em>QUALIFIER BLOCK</em> )
<strong>SUBPROFILE</strong> = 'profile' <em>PROFILE NAME</em> [
<em>ATTACHMENT SPECIFICATION</em> ] [ <em>PROFILE FLAG CONDS</em> ] '{'
( <em>RULES</em> )* '}' <strong>HAT</strong> = ('hat' | '^')
<em>HATNAME</em> [ <em>PROFILE FLAG CONDS</em> ] '{' ( <em>RULES</em> )*
'}' <strong>HATNAME</strong> = (must start with alphanumeric character.
See <strong>aa_change_hat</strong> (2) for a description of how this hat
is used. If '^' is used to start a hat then there is no space between
the '^' and <em>HATNAME</em>) <strong>QUALIFIER BLOCK</strong> =
<em>QUALIFIERS</em> <em>BLOCK</em> <strong>ACCESS TYPE</strong> = (
'allow' | 'deny' ) <strong>QUALIFIERS</strong> = [ 'audit' ] [
<em>ACCESS TYPE</em> ] <strong>CAPABILITY RULE</strong> = [
<em>QUALIFIERS</em> ] 'capability' [ <em>CAPABILITY LIST</em> ]
<strong>CAPABILITY LIST</strong> = ( <em>CAPABILITY</em> )+
<strong>CAPABILITY</strong> = (lowercase capability name without 'CAP_'
prefix; see <strong>capabilities</strong> (7)) <strong>NETWORK
RULE</strong> = [ <em>QUALIFIERS</em> ] 'network' [ <em>DOMAIN</em> ] [
<em>TYPE</em> | <em>PROTOCOL</em> ] <strong>DOMAIN</strong> = ( 'unix' |
'inet' | 'ax25' | 'ipx' | 'appletalk' | 'netrom' | 'bridge' | 'atmpvc' |
'x25' | 'inet6' | 'rose' | 'netbeui' | 'security' | 'key' | 'netlink' |
'packet' | 'ash' | 'econet' | 'atmsvc' | 'rds' | 'sna' | 'irda' |
'pppox' | 'wanpipe' | 'llc' | 'ib' | 'mpls' | 'can' | 'tipc' |
'bluetooth' | 'iucv' | 'rxrpc' | 'isdn' | 'phonet' | 'ieee802154' |
'caif' | 'alg' | 'nfc' | 'vsock' | 'kcm' | 'qipcrtr' | 'smc' | 'xdp' |
'mctp' ) ',' <strong>TYPE</strong> = ( 'stream' | 'dgram' | 'seqpacket'
| 'rdm' | 'raw' | 'packet' ) <strong>PROTOCOL</strong> = ( 'tcp' | 'udp'
| 'icmp' ) <strong>MOUNT RULE</strong> = ( <em>MOUNT</em> |
<em>REMOUNT</em> | <em>UMOUNT</em> ) <strong>MOUNT</strong> = [
<em>QUALIFIERS</em> ] 'mount' [ <em>MOUNT CONDITIONS</em> ] [ <em>SOURCE
FILEGLOB</em> ] [ '-&gt;' [ <em>MOUNTPOINT FILEGLOB</em> ]
<strong>REMOUNT</strong> = [ <em>QUALIFIERS</em> ] 'remount' [ <em>MOUNT
CONDITIONS</em> ] <em>MOUNTPOINT FILEGLOB</em> <strong>UMOUNT</strong> =
[ <em>QUALIFIERS</em> ] 'umount' [ <em>MOUNT CONDITIONS</em> ]
<em>MOUNTPOINT FILEGLOB</em> <strong>MOUNT CONDITIONS</strong> = [ (
'fstype' | 'vfstype' ) ( '=' | 'in' ) <em>MOUNT FSTYPE EXPRESSION</em> ]
[ 'options' ( '=' | 'in' ) <em>MOUNT FLAGS EXPRESSION</em> ]
<strong>MOUNT FSTYPE EXPRESSION</strong> = ( <em>MOUNT FSTYPE LIST</em>
| <em>MOUNT EXPRESSION</em> ) <strong>MOUNT FSTYPE LIST</strong> = Comma
separated list of valid filesystem and virtual filesystem types (eg
ext4, debugfs, devfs, etc) <strong>MOUNT FLAGS EXPRESSION</strong> = (
<em>MOUNT FLAGS LIST</em> | <em>MOUNT EXPRESSION</em> ) <strong>MOUNT
FLAGS LIST</strong> = Comma separated list of <em>MOUNT FLAGS</em>.
<strong>MOUNT FLAGS</strong> = ( 'ro' | 'rw' | 'nosuid' | 'suid' |
'nodev' | 'dev' | 'noexec' | 'exec' | 'sync' | 'async' | 'remount' |
'mand' | 'nomand' | 'dirsync' | 'noatime' | 'atime' | 'nodiratime' |
'diratime' | 'bind' | 'rbind' | 'move' | 'verbose' | 'silent' | 'loud' |
'acl' | 'noacl' | 'unbindable' | 'runbindable' | 'private' | 'rprivate'
| 'slave' | 'rslave' | 'shared' | 'rshared' | 'relatime' | 'norelatime'
| 'iversion' | 'noiversion' | 'strictatime' | 'nouser' | 'user' )
<strong>MOUNT EXPRESSION</strong> = ( <em>ALPHANUMERIC</em> |
<em>AARE</em> ) ... <strong>PIVOT ROOT RULE</strong> = [
<em>QUALIFIERS</em> ] pivot_root [ oldroot=<em>OLD PUT FILEGLOB</em> ] [
<em>NEW ROOT FILEGLOB</em> ] [ '-&gt;' <em>PROFILE NAME</em> ]
<strong>SOURCE FILEGLOB</strong> = <em>FILEGLOB</em> <strong>MOUNTPOINT
FILEGLOB</strong> = <em>FILEGLOB</em> <strong>OLD PUT FILEGLOB</strong>
= <em>FILEGLOB</em> <strong>PTRACE_RULE</strong> = [ <em>QUALIFIERS</em>
] 'ptrace' [ <em>PTRACE ACCESS PERMISSIONS</em> ] [ <em>PTRACE PEER</em>
] <strong>PTRACE ACCESS PERMISSIONS</strong> = <em>PTRACE ACCESS</em> |
<em>PTRACE ACCESS LIST</em> <strong>PTRACE ACCESS LIST</strong> = '('
Comma or space separated list of <em>PTRACE ACCESS</em> ')'
<strong>PTRACE ACCESS</strong> = ( 'r' | 'w' | 'rw' | 'read' | 'readby'
| 'trace' | 'tracedby' ) <strong>PTRACE PEER</strong> = 'peer' '='
<em>AARE</em> <strong>SIGNAL_RULE</strong> = [ <em>QUALIFIERS</em> ]
'signal' [ <em>SIGNAL ACCESS PERMISSIONS</em> ] [ <em>SIGNAL SET</em> ]
[ <em>SIGNAL PEER</em> ] <strong>SIGNAL ACCESS PERMISSIONS</strong> =
<em>SIGNAL ACCESS</em> | <em>SIGNAL ACCESS LIST</em> <strong>SIGNAL
ACCESS LIST</strong> = '(' Comma or space separated list of <em>SIGNAL
ACCESS</em> ')' <strong>SIGNAL ACCESS</strong> = ( 'r' | 'w' | 'rw' |
'read' | 'write' | 'send' | 'receive' ) <strong>SIGNAL SET</strong> =
'set' '=' '(' <em>SIGNAL LIST</em> ')' <strong>SIGNAL LIST</strong> =
Comma or space separated list of <em>SIGNALS</em>
<strong>SIGNALS</strong> = ( 'hup' | 'int' | 'quit' | 'ill' | 'trap' |
'abrt' | 'bus' | 'fpe' | 'kill' | 'usr1' | 'segv' | 'usr2' | 'pipe' |
'alrm' | 'term' | 'stkflt' | 'chld' | 'cont' | 'stop' | 'stp' | 'ttin' |
'ttou' | 'urg' | 'xcpu' | 'xfsz' | 'vtalrm' | 'prof' | 'winch' | 'io' |
'pwr' | 'sys' | 'emt' | 'exists' | 'rtmin+0' ... 'rtmin+32' )
<strong>SIGNAL PEER</strong> = 'peer' '=' <em>AARE</em> <strong>DBUS
RULE</strong> = ( <em>DBUS MESSAGE RULE</em> | <em>DBUS SERVICE
RULE</em> | <em>DBUS EAVESDROP RULE</em> | <em>DBUS COMBINED RULE</em> )
<strong>DBUS MESSAGE RULE</strong> = [ <em>QUALIFIERS</em> ] 'dbus' [
<em>DBUS ACCESS EXPRESSION</em> ] [ <em>DBUS BUS</em> ] [ <em>DBUS
PATH</em> ] [ <em>DBUS INTERFACE</em> ] [ <em>DBUS MEMBER</em> ] [
<em>DBUS PEER</em> ] <strong>DBUS SERVICE RULE</strong> = [
<em>QUALIFIERS</em> ] 'dbus' [ <em>DBUS ACCESS EXPRESSION</em> ] [
<em>DBUS BUS</em> ] [ <em>DBUS NAME</em> ] <strong>DBUS EAVESDROP
RULE</strong> = [ <em>QUALIFIERS</em> ] 'dbus' [ <em>DBUS ACCESS
EXPRESSION</em> ] [ <em>DBUS BUS</em> ] <strong>DBUS COMBINED
RULE</strong> = [ <em>QUALIFIERS</em> ] 'dbus' [ <em>DBUS ACCESS
EXPRESSION</em> ] [ <em>DBUS BUS</em> ] <strong>DBUS ACCESS
EXPRESSION</strong> = ( <em>DBUS ACCESS</em> | '(' <em>DBUS ACCESS
LIST</em> ')' ) <strong>DBUS BUS</strong> = 'bus' '=' '(' 'system' |
'session' | '"' <em>AARE</em> '"' | <em>AARE</em> ')' <strong>DBUS
PATH</strong> = 'path' '=' '(' '"' <em>AARE</em> '"' | <em>AARE</em> ')'
<strong>DBUS INTERFACE</strong> = 'interface' '=' '(' '"' <em>AARE</em>
'"' | <em>AARE</em> ')' <strong>DBUS MEMBER</strong> = 'member' '=' '('
'"' <em>AARE</em> '"' | <em>AARE</em> ')' <strong>DBUS PEER</strong> =
'peer' '=' '(' [ <em>DBUS NAME</em> ] [ <em>DBUS LABEL</em> ] ')'
<strong>DBUS NAME</strong> = 'name' '=' '(' '"' <em>AARE</em> '"' |
<em>AARE</em> ')' <strong>DBUS LABEL</strong> = 'label' '=' '(' '"'
<em>AARE</em> '"' | <em>AARE</em> ')' <strong>DBUS ACCESS LIST</strong>
= Comma separated list of <em>DBUS ACCESS</em> <strong>DBUS
ACCESS</strong> = ( 'send' | 'receive' | 'bind' | 'eavesdrop' | 'r' |
'read' | 'w' | 'write' | 'rw' ) Some accesses are incompatible with some
rules; see below. <strong>AARE</strong> = <strong>?*[]{}^</strong> See
below for meanings. <strong>UNIX RULE</strong> = [ <em>QUALIFIERS</em> ]
'unix' [ <em>UNIX ACCESS EXPR</em> ] [ <em>UNIX RULE CONDS</em> ] [
<em>UNIX LOCAL EXPR</em> ] [ <em>UNIX PEER EXPR</em> ] <strong>UNIX
ACCESS EXPR</strong> = ( <em>UNIX ACCESS</em> | <em>UNIX ACCESS
LIST</em> ) <strong>UNIX ACCESS</strong> = ( 'create' | 'bind' |
'listen' | 'accept' | 'connect' | 'shutdown' | 'getattr' | 'setattr' |
'getopt' | 'setopt' | 'send' | 'receive' | 'r' | 'w' | 'rw' ) Some
access modes are incompatible with some rules or require additional
parameters. <strong>UNIX ACCESS LIST</strong> = '(' <em>UNIX ACCESS</em>
( [','] <em>UNIX ACCESS</em> )* ')' <strong>UNIX RULE CONDS</strong> = (
<em>TYPE COND</em> | <em>PROTO COND</em> ) Each cond can appear at most
once. <strong>TYPE COND</strong> = 'type' '=' ( <em>AARE</em> | '(' (
'"' <em>AARE</em> '"' | <em>AARE</em> )+ ')' ) <strong>PROTO
COND</strong> = 'protocol' '=' ( <em>AARE</em> | '(' ( '"' <em>AARE</em>
'"' | <em>AARE</em> )+ ')' ) <strong>UNIX LOCAL EXPR</strong> = (
<em>UNIX ADDRESS COND</em> | <em>UNIX LABEL COND</em> | <em>UNIX ATTR
COND</em> | <em>UNIX OPT COND</em> )* Each cond can appear at most once.
<strong>UNIX PEER EXPR</strong> = 'peer' '=' ( <em>UNIX ADDRESS
COND</em> | <em>UNIX LABEL COND</em> )+ Each cond can appear at most
once. <strong>UNIX ADDRESS COND</strong> 'addr' '=' ( <em>AARE</em> |
'(' '"' <em>AARE</em> '"' | <em>AARE</em> ')' ) <strong>UNIX LABEL
COND</strong> 'label' '=' ( <em>AARE</em> | '(' '"' <em>AARE</em> '"' |
<em>AARE</em> ')' ) <strong>UNIX ATTR COND</strong> 'attr' '=' (
<em>AARE</em> | '(' '"' <em>AARE</em> '"' | <em>AARE</em> ')' )
<strong>UNIX OPT COND</strong> 'opt' '=' ( <em>AARE</em> | '(' '"'
<em>AARE</em> '"' | <em>AARE</em> ')' ) <strong>RLIMIT RULE</strong> =
'set' 'rlimit' [<em>RLIMIT</em> '&lt;=' <em>RLIMIT VALUE</em> ]
<strong>RLIMIT</strong> = ( 'cpu' | 'fsize' | 'data' | 'stack' | 'core'
| 'rss' | 'nofile' | 'ofile' | 'as' | 'nproc' | 'memlock' | 'locks' |
'sigpending' | 'msgqueue' | 'nice' | 'rtprio' | 'rttime' )
<strong>RLIMIT VALUE</strong> = ( <em>RLIMIT SIZE</em> | <em>RLIMIT
NUMBER</em> | <em>RLIMIT TIME</em> | <em>RLIMIT NICE</em> )
<strong>RLIMIT SIZE</strong> = <em>NUMBER</em> ( 'K' | 'M' | 'G' ) Only
applies to RLIMIT of 'fsize', 'data', 'stack', 'core', 'rss', 'as',
'memlock', 'msgqueue'. <strong>RLIMIT NUMBER</strong> = number from 0 to
max rlimit value. Only applies to RLIMIT of 'ofile', 'nofile', 'locks',
'sigpending', 'nproc', 'rtprio'. <strong>RLIMIT TIME</strong> =
<em>NUMBER</em> ( 'us' | 'microsecond' | 'microseconds' | 'ms' |
'millisecond' | 'milliseconds' | 's' | 'sec' | 'second' | 'seconds' |
'min' | 'minute' | 'minutes' | 'h' | 'hour' | 'hours' | 'd' | 'day' |
'days' | 'week' | 'weeks' ) Only applies to RLIMIT of 'cpu' and
'rttime'. RLIMIT 'cpu' only allows units &gt;= 'seconds'. <strong>RLIMIT
NICE</strong> = a number between -20 and 19. Only applies to RLIMIT of
'nice'. <strong>FILE RULE</strong> = [ <em>QUALIFIERS</em> ] [ 'owner' ]
( 'file' | [ 'file' ] ( <em>FILEGLOB</em> <em>ACCESS</em> |
<em>ACCESS</em> <em>FILEGLOB</em> ) [ '-&gt;' <em>EXEC TARGET</em> ] )
<strong>FILEGLOB</strong> = ( <em>QUOTED FILEGLOB</em> | <em>UNQUOTED
FILEGLOB</em> ) <strong>QUOTED FILEGLOB</strong> = '"' <em>UNQUOTED
FILEGLOB</em> '"' <strong>UNQUOTED FILEGLOB</strong> = (must start with
'/' (after variable expansion), <strong>AARE</strong> have special
meanings; see below. May include <em>VARIABLE</em>. Rules with embedded
spaces or tabs must be quoted. Rules must end with '/' to apply to
directories.) <strong>ACCESS</strong> = ( 'r' | 'w' | 'a' | 'l' | 'k' |
'm' | <em>EXEC TRANSITION</em> )+ (not all combinations are allowed; see
below.) <strong>EXEC TRANSITION</strong> = ( 'ix' | 'ux' | 'Ux' | 'px' |
'Px' | 'cx' | 'Cx' | 'pix' | 'Pix' | 'cix' | 'Cix' | 'pux' | 'PUx' |
'cux' | 'CUx' | 'x' ) A bare 'x' is only allowed in rules with the deny
qualifier, everything else only without the deny qualifier. <strong>EXEC
TARGET</strong> = name Requires <em>EXEC TRANSITION</em> specified.
<strong>LINK RULE</strong> = <em>QUALIFIERS</em> [ 'owner' ] 'link' [
'subset' ] <em>FILEGLOB</em> '-&gt;' <em>FILEGLOB</em>
<strong>ALPHA</strong> = ('a', 'b', 'c', ... 'z', 'A', 'B', ... 'Z')
<strong>ALPHANUMERIC</strong> = ('0', '1', '2', ... '9', 'a', 'b', 'c',
... 'z', 'A', 'B', ... 'Z') <strong>CHANGE_PROFILE RULE</strong> =
'change_profile' [ [ <em>EXEC MODE</em> ] <em>EXEC COND</em> ] [ '-&gt;'
<em>PROFILE NAME</em> ] <strong>EXEC_MODE</strong> = ( 'safe' | 'unsafe'
) <strong>EXEC COND</strong> = <em>FILEGLOB</em></p>
</blockquote>
<p>All resources and programs need a full path. There may be any number
of subprofiles (aka child profiles) in a profile, limited only by kernel
memory. Subprofile names are limited to 974 characters. Child profiles
can be used to confine an application in a special way, or when you want
the child to be unconfined on the system, but confined when called from
the parent. Hats are a special child profile that can be used with the
<strong>aa_change_hat</strong> (2) API call. Applications written or
modified to use <strong>aa_change_hat</strong> (2) can take advantage of
subprofiles to run under different confinements, dependent on program
logic. Several <strong>aa_change_hat</strong> (2)-aware applications
exist, including an Apache module, <strong>mod_apparmor</strong> (5); a
PAM module, pam_apparmor; and a Tomcat valve, tomcat_apparmor.
Applications written or modified to use
<strong>change_profile</strong> (2) transition permanently to the
specified profile. libvirt is one such application.</p>
<h2>Profile Head</h2>
<p>The profile head consists of a required name that is unique and
optional attachment conditionals and control flags.</p>
<p><em>Name</em></p>
<p>The name of the profile is its identifier. It is what is displayed
during introspection (eg. ps -Z), and defines how the profile is
referenced by policy rules for any policy interaction via ipc or domain
changes. It is recommended that the name be kept short and have meaning
for the application it is being applied eg. <em>firefox</em> for the
firefox web browser or its functional role eg. log_admin.</p>
<p>If the name is an applications full absolute path name eg.
<em>/usr/bin/firefox</em> and an exec attachment conditional is not
specified the name is also used as the profile's exec attachment
conditional. This use however has been deprecated and is discouraged as
it makes for long names that can make profile rules difficult to
understand, and may not be fully displayed by some introspection
tools.</p>
<p><em>Attachment Conditionals</em></p>
<p>The attachment conditionals are used during profile changes to
determine whether a profile is a match for the proposed profile
transition. The attachment conditionals are optional, how and when they
are applied is determined by the specific condition(s) used.</p>
<p>When attachment conditionals are used, the attachment conditionals
for all profiles in the namespace will be evaluated. The profile with
the set of attachments that result in the best match will become the new
profile after a transition operation. Attachments that don't match will
result in the profile not being available for transition.</p>
<p>If no conditionals are specified the profile will only be used if a
transition explicitly specifies the profile name.</p>
<p>Exec Attachment Conditional</p>
<p>The exec attachment conditional governs how closely the profile
matches an executable program. This conditional is only used during an
exec operation when the matching exec rule specifies either a
<strong>px</strong> or <strong>cx</strong> (or their derivatives)
transition type. The exec attachment conditional will also be used by
tasks that are <em>unconfined</em> as they use a <strong>pix</strong>
transition rule.</p>
<p>If there are no attachment matches then it is up to the exec rule to
determine what happens (fail or a fallback option).</p>
<p>Note: see profile <em>Name</em> for information around using the
profile name as an attachment conditional.</p>
<p>Exec attachment conditionals can contain variable names and pattern
matching. They use a longest left match heuristic to deterime the winner
in the case of multiple matches at run time. The exact implementation of
this resolution is kernel specific and has improved over time, while
retaining backwards compatibility. If the heuristic can not determine a
winner between multiple matches the exec will be denied.</p>
<p>Extended Attributes Attachment Conditional</p>
<p>AppArmor profiles have the ability to target files based on their
<strong>xattr</strong> (7) values in addition to their path. For
example, the following profile matches files in /usr/bin with the
attribute security.apparmor and value trusted:</p>
<p>/usr/bin/* xattrs(security.apparmor="trusted") { # ... }</p>
<p>See <strong>apparmor_xattrs</strong> (7) for further details.</p>
<p><em>Flags</em></p>
<p>The profile flags allow modifying the behavior of the profile. If a
profile flag is specified it takes priority over any conflicting flags
that have been specified by rules in the profile body.</p>
<p>Profile Mode</p>
<p>The profile mode allow controlling the enforcement behavior of the
profile rules.</p>
<p>If no mode is specified the profile defaults to <em>enforce</em>
mode.</p>
<dl>
<dt>enforce For a given action, if the profile rules do not grant
permission the action will be denied, with an EACCES or EPERM error code
returned to userspace, and the violation will be logged with a tag of
the access being DENIED.</dt>
<dd>

</dd>
</dl>
<dl>
<dt>kill This is a variant of enforce mode where in addition to
returning EACCES or EPERM for a violation, the task is also sent a
signal to kill it.</dt>
<dd>

</dd>
<dt>complain For a given action, if the profile rules do not grant
permission the action will be allowed, but the violation will be logged
with a tag of the access being ALLOWED.</dt>
<dd>

</dd>
<dt>unconfined This mode allows a task confined by the profile to behave
as though they are unconfined. This mode allow for an unconfined
behavior that can be later changed to confinement by using profile
replacement. This mode is should not be used under regular deployment
but can be useful during debugging and some system initialization
scenarios.</dt>
<dd>

</dd>
</dl>
<p>Audit Mode</p>
<p>The audit mode allows control of how AppArmor messages are are logged
to the audit system.</p>
<dl>
<dt>audit This flag causes all actions whether allowed or denied to be
logged.</dt>
<dd>

</dd>
</dl>
<p>Misc modes</p>
<dl>
<dt>mediate_deleted This forces AppArmor to mediate deleted files as if
they still exist in the file system.</dt>
<dd>

</dd>
</dl>
<dl>
<dt>attach_disconnected This forces AppArmor to attach disconnected
objects to the task's namespace and mediate them as though they are part
of the namespace. WARNING this mode is unsafe and can result in aliasing
and access to objects that should not be allowed. Its intent is a debug
and policy development tool.</dt>
<dd>

</dd>
<dt>chroot_relative This forces file names to be relative to a chroot
and behave as if the chroot is a mount namespace.</dt>
<dd>

</dd>
</dl>
<h2>Access Modes</h2>
<p>File permission access modes consists of combinations of the
following modes:</p>
<ol start="18" type="a">
<li><p>- read</p></li>
<li><p>- write Ω- conflicts with append</p></li>
<li><p>- append Ω- conflicts with write</p></li>
</ol>
<dl>
<dt>ux</dt>
<dd>
<p>- unconfined execute</p>
</dd>
<dt>Ux</dt>
<dd>
<p>- unconfined execute Ω- scrub the environment</p>
</dd>
<dt>px</dt>
<dd>
<p>- discrete profile execute</p>
</dd>
<dt>Px</dt>
<dd>
<p>- discrete profile execute Ω- scrub the environment</p>
</dd>
</dl>
<ol start="110" type="i">
<li><p>- transition to subprofile on execute</p></li>
</ol>
<dl>
<dt>Cx</dt>
<dd>
<p>- transition to subprofile on execute Ω- scrub the environment</p>
</dd>
</dl>
<ol start="9" type="i">
<li><p>- inherit execute</p></li>
</ol>
<dl>
<dt>pix</dt>
<dd>
<p>- discrete profile execute with inherit fallback</p>
</dd>
<dt>Pix</dt>
<dd>
<p>- discrete profile execute with inherit fallback Ω- scrub the
environment</p>
</dd>
</dl>
<ol start="109" type="i">
<li><p>- transition to subprofile on execute with inherit
fallback</p></li>
</ol>
<dl>
<dt>Cix</dt>
<dd>
<p>- transition to subprofile on execute with inherit fallback Ω- scrub
the environment</p>
</dd>
<dt>pux</dt>
<dd>
<p>- discrete profile execute with fallback to unconfined</p>
</dd>
<dt>PUx</dt>
<dd>
<p>- discrete profile execute with fallback to unconfined Ω- scrub the
environment</p>
</dd>
<dt>cux</dt>
<dd>
<p>- transition to subprofile on execute with fallback to unconfined</p>
</dd>
<dt>CUx</dt>
<dd>
<p>- transition to subprofile on execute with fallback to unconfined Ω-
scrub the environment</p>
</dd>
<dt>deny x</dt>
<dd>
<p>- disallow execute (in rules with the deny qualifier)</p>
</dd>
</dl>
<ol start="13" type="a">
<li><p>- allow PROT_EXEC with <strong>mmap</strong> (2) calls</p></li>
<li><p>- link</p></li>
<li><p>- lock</p></li>
</ol>
<h2>Access Modes Details</h2>
<dl>
<dt>r - Read mode</dt>
<dd>
<p>Allows the program to have read access to the file or directory
listing. Read access is required for shell scripts and other interpreted
content.</p>
</dd>
<dt>w - Write mode</dt>
<dd>
<p>Allows the program to have write access to the file. Files and
directories must have this permission if they are to be unlinked
(removed.) Write mode is not required on a directory to rename or create
files within the directory. This mode conflicts with append mode.</p>
</dd>
<dt>a - Append mode</dt>
<dd>
<p>Allows the program to have a limited appending only write access to
the file. Append mode will prevent an application from opening the file
for write unless it passes the O_APPEND parameter flag on open. The mode
conflicts with Write mode.</p>
</dd>
<dt>ux - Unconfined execute mode</dt>
<dd>
<p>Allows the program to execute the program without any AppArmor
profile being applied to the program. This mode is useful when a
confined program needs to be able to perform a privileged operation,
such as rebooting the machine. By placing the privileged section in
another executable and granting unconfined execution rights, it is
possible to bypass the mandatory constraints imposed on all confined
processes. For more information on what is constrained, see the
<strong>apparmor</strong> (7) man page. <strong>WARNING</strong> 'ux'
should only be used in very special cases. It enables the designated
child processes to be run without any AppArmor protection. 'ux' does not
scrub the environment of variables such as LD_PRELOAD; as a result, the
calling domain may have an undue amount of influence over the callee.
Use this mode only if the child absolutely must be run unconfined and
LD_PRELOAD must be used. Any profile using this mode provides negligible
security. Use at your own risk. Incompatible with other exec transition
modes and the deny qualifier.</p>
</dd>
<dt>Ux - unconfined execute Ω- scrub the environment</dt>
<dd>
<p>'Ux' allows the named program to run in 'ux' mode, but AppArmor will
invoke the Linux Kernel's <strong>unsafe_exec</strong> routines to scrub
the environment, similar to setuid programs. (See
<strong>ld.so</strong> (8) for some information on setuid/setgid
environment scrubbing.) <strong>WARNING</strong> 'Ux' should only be
used in very special cases. It enables the designated child processes to
be run without any AppArmor protection. Use this mode only if the child
absolutely must be run unconfined. Use at your own risk. Incompatible
with other exec transition modes and the deny qualifier.</p>
</dd>
<dt>px - Discrete Profile execute mode</dt>
<dd>
<p>This mode requires that a discrete security profile is defined for a
program executed and forces an AppArmor domain transition. If there is
no profile defined then the access will be denied.
<strong>WARNING</strong> 'px' does not scrub the environment of
variables such as LD_PRELOAD; as a result, the calling domain may have
an undue amount of influence over the callee. Incompatible with other
exec transition modes and the deny qualifier.</p>
</dd>
<dt>Px - Discrete Profile execute mode Ω- scrub the environment</dt>
<dd>
<p>'Px' allows the named program to run in 'px' mode, but AppArmor will
invoke the Linux Kernel's <strong>unsafe_exec</strong> routines to scrub
the environment, similar to setuid programs. (See
<strong>ld.so</strong> (8) for some information on setuid/setgid
environment scrubbing.) Incompatible with other exec transition modes
and the deny qualifier.</p>
</dd>
<dt>cx - Transition to Subprofile execute mode</dt>
<dd>
<p>This mode requires that a local security profile is defined and
forces an AppArmor domain transition to the named profile. If there is
no profile defined then the access will be denied.
<strong>WARNING</strong> 'cx' does not scrub the environment of
variables such as LD_PRELOAD; as a result, the calling domain may have
an undue amount of influence over the callee. Incompatible with other
exec transition modes and the deny qualifier.</p>
</dd>
<dt>Cx - Transition to Subprofile execute mode Ω- scrub the
environment</dt>
<dd>
<p>'Cx' allows the named program to run in 'cx' mode, but AppArmor will
invoke the Linux Kernel's <strong>unsafe_exec</strong> routines to scrub
the environment, similar to setuid programs. (See
<strong>ld.so</strong> (8) for some information on setuid/setgid
environment scrubbing.) Incompatible with other exec transition modes
and the deny qualifier.</p>
</dd>
<dt>ix - Inherit execute mode</dt>
<dd>
<p>Prevent the normal AppArmor domain transition on
<strong>execve</strong> (2) when the profiled program executes the named
program. Instead, the executed resource will inherit the current
profile. This mode is useful when a confined program needs to call
another confined program without gaining the permissions of the target's
profile, or losing the permissions of the current profile. There is no
version to scrub the environment because 'ix' executions don't change
privileges. Incompatible with other exec transition modes and the deny
qualifier.</p>
</dd>
<dt>Profile transition with inheritance fallback execute mode</dt>
<dd>
<p>These modes attempt to perform a domain transition as specified by
the matching permission (shown below) and if that transition fails to
find the matching profile the domain transition proceeds using the 'ix'
transition mode. Pix == Px with fallback to ix pix == px with fallback
to ix Cix == Cx with fallback to ix cix == cx with fallback to ix
Incompatible with other exec transition modes and the deny
qualifier.</p>
</dd>
<dt>Profile transition with unconfined fallback execute mode</dt>
<dd>
<p>These modes attempt to perform a domain transition as specified by
the matching permission (shown below) and if that transition fails to
find the matching profile the domain transition proceeds using the 'ux'
transition mode if 'pux', 'cux' or the 'Ux' transition mode if 'PUx',
'CUx' is used. PUx == Px with fallback to Ux pux == px with fallback to
ux CUx == Cx with fallback to Ux cux == cx with fallback to ux
Incompatible with other exec transition modes and the deny
qualifier.</p>
</dd>
<dt>deny x - Deny execute</dt>
<dd>
<p>For rules including the deny modifier, only 'x' is allowed to deny
execute. The 'ix', 'Px', 'px', 'Cx', 'cx' and the fallback modes
conflict with the deny modifier.</p>
</dd>
<dt>Directed profile transitions</dt>
<dd>
<p>The directed ('px', 'Px', 'pix', 'Pix', 'pux', 'PUx') profile and
subprofile ('cx', 'Cx', 'cix', 'Cix', 'cux', 'CUx') transitions normally
determine the profile to transition to from the executable name. It is
however possible to specify the name of the profile that the transition
should use. The name of the profile to transition to is specified using
the '-&gt;' followed by the name of the profile to transition to. Eg.
/bin/** px -&gt; profile, Incompatible with other exec transition
modes.</p>
</dd>
<dt>m - Allow executable mapping</dt>
<dd>
<p>This mode allows a file to be mapped into memory using
<strong>mmap</strong> (2)'s PROT_EXEC flag. This flag marks the pages
executable; it is used on some architectures to provide non-executable
data pages, which can complicate exploit attempts. AppArmor uses this
mode to limit which files a well-behaved program (or all programs on
architectures that enforce non-executable memory access controls) may
use as libraries, to limit the effect of invalid <strong>-L</strong>
flags given to <strong>ld</strong> (1) and <strong>LD_PRELOAD</strong>,
<strong>LD_LIBRARY_PATH</strong>, given to
<strong>ld.so</strong> (8).</p>
</dd>
<dt>l - Link mode</dt>
<dd>
<p>Allows the program to be able to create a link with this name. When a
link is created, the new link <strong>MUST</strong> have a subset of
permissions as the original file (with the exception that the
destination does not have to have link access.) If there is an 'x' rule
on the new link, it must match the original file exactly.</p>
</dd>
<dt>k - lock mode</dt>
<dd>
<p>Allows the program to be able lock a file with this name. This
permission covers both advisory and mandatory locking.</p>
</dd>
<dt>leading OR trailing access permissions</dt>
<dd>
<p>File rules can be specified with the access permission either leading
or trailing the file glob. Eg. rw /**, # leading permissions /** rw, #
trailing permissions When leading permissions are used further rule
options and context may be allowed, Eg. l /foo -&gt; /bar, # lead l link
permission is equivalent to link rules</p>
</dd>
</dl>
<h2>Link rules</h2>
<p>Link rules allow specifying permission to form a hard link as a link
target pair. If the subset condition is specified then the permissions
to access the link file must be a subset of the profiles permissions to
access the target file. If there is an 'x' rule on the new link, it must
match the original file exactly.</p>
<p>Eg.</p>
<p>/file1 r, /file2 rwk, /link* rw, link subset /link* -&gt; /**,</p>
<p>The link rule allows linking of /link to both /file1 or /file2 by
name however because the /link file has 'rw' permissions it is not
allowed to link to /file1 because that would grant an access path to
/file1 with more permissions than the 'r' permissions the profile
specifies.</p>
<p>A link of /link to /file2 would be allowed because the 'rw'
permissions of /link are a subset of the 'rwk' permissions for
/file1.</p>
<p>The link rule is equivalent to specifying the 'l' link permission as
a leading permission with no other file access permissions. When this is
done the link rule options can be specified.</p>
<p>The following link rule is equivalent to the 'l' permission file
rule</p>
<p>link /foo -&gt; bar, l /foo -&gt; /bar,</p>
<p>File rules that specify the 'l' permission and don't specify the
extend link permissions map to link rules as follows.</p>
<p>/foo l, l /foo, link subset /foo -&gt; /**,</p>
<h2>Comments</h2>
<p>Comments start with # and may begin at any place within a line. The
comment ends when the line ends. This is the same comment style as shell
scripts.</p>
<h2>Capabilities</h2>
<p>The only capabilities a confined process may use may be enumerated;
for the complete list, please refer to
<strong>capabilities</strong> (7). Note that granting some capabilities
renders AppArmor confinement for that domain advisory; while
<strong>open</strong> (2), <strong>read</strong> (2),
<strong>write</strong> (2), etc., will still return error when access is
not granted, some capabilities allow loading kernel modules, arbitrary
access to IPC, ability to bypass discretionary access controls, and
other operations that are typically reserved for the root user.</p>
<h2>Network Rules</h2>
<p>AppArmor supports simple coarse grained network mediation. The
network rule restrict all <strong>socket</strong> (2) based operations.
The mediation done is a coarse-grained check on whether a socket of a
given type and family can be created, read, or written. There is no
mediation based of port number or protocol beyond tcp, udp, and raw.
Network <strong>netlink</strong> (7) rules may only specify type 'dgram'
and 'raw'.</p>
<p>AppArmor network rules are accumulated so that the granted network
permissions are the union of all the listed network rule
permissions.</p>
<p>AppArmor network rules are broad and general and become more
restrictive as further information is specified.</p>
<p>eg.</p>
<p>network, #allow access to all networking network tcp, #allow access
to tcp network inet tcp, #allow access to tcp only for inet4 addresses
network inet6 tcp, #allow access to tcp only for inet6 addresses network
netlink raw, #allow access to AF_NETLINK SOCK_RAW</p>
<h2>Mount Rules</h2>
<p>AppArmor supports mount mediation and allows specifying filesystem
types and mount flags. The syntax of mount rules in AppArmor is based on
the <strong>mount</strong> (8) command syntax. Mount rules must contain
one of the mount, remount or umount keywords, but all mount conditions
are optional. Unspecified optional conditionals are assumed to match all
entries (eg, not specifying fstype means all fstypes are matched). Due
to the complexity of the mount command and how options may be specified,
AppArmor allows specifying conditionals three different ways:</p>
<ol type="1">
<li><p>If a conditional is specified using '=', then the rule only
grants permission for mounts matching the exactly specified options. For
example, an AppArmor policy with the following rule: mount options=ro
/dev/foo -E&lt;gt&gt; /mnt/, Would match: $ mount -o ro /dev/foo /mnt
but not either of these: $ mount -o ro,atime /dev/foo /mnt $ mount -o rw
/dev/foo /mnt</p></li>
<li><p>If a conditional is specified using 'in', then the rule grants
permission for mounts matching any combination of the specified options.
For example, if an AppArmor policy has the following rule: mount options
in (ro,atime) /dev/foo -&gt; /mnt/, all of these mount commands will
match: $ mount -o ro /dev/foo /mnt $ mount -o ro,atime /dev/foo /mnt $
mount -o atime /dev/foo /mnt but none of these will: $ mount -o ro,sync
/dev/foo /mnt $ mount -o ro,atime,sync /dev/foo /mnt $ mount -o rw
/dev/foo /mnt $ mount -o rw,noatime /dev/foo /mnt $ mount /dev/foo
/mnt</p></li>
<li><p>If multiple conditionals are specified in a single mount rule,
then the rule grants permission for each set of options. This provides a
shorthand when writing mount rules which might help to logically break
up a conditional. For example, if an AppArmor policy has the following
rule: mount options=ro options=atime both of these mount commands will
match: $ mount -o ro /dev/foo /mnt $ mount -o atime /dev/foo /mnt but
this one will not: $ mount -o ro,atime /dev/foo /mnt</p></li>
</ol>
<p>Note that separate mount rules are distinct and the options do not
accumulate. For example, these AppArmor mount rules:</p>
<p>mount options=ro, mount options=atime,</p>
<p>are not equivalent to either of these mount rules:</p>
<p>mount options=(ro,atime), mount options in (ro,atime),</p>
<p>To help clarify the flexibility and complexity of mount rules, here
are some example rules with accompanying matching commands:</p>
<dl>
<dt>mount,</dt>
<dd>
<p>the 'mount' rule without any conditionals is the most generic and
allows any mount. Equivalent to 'mount fstype=** options=** ** -&gt;
/**'.</p>
</dd>
<dt>mount /dev/foo,</dt>
<dd>
<p>allow mounting of /dev/foo anywhere with any options. Some matching
mount commands: $ mount /dev/foo /mnt $ mount -t ext3 /dev/foo /mnt $
mount -t vfat /dev/foo /mnt $ mount -o ro,atime,noexec,nodiratime
/dev/foo /srv/some/mountpoint</p>
</dd>
<dt>mount options=ro /dev/foo,</dt>
<dd>
<p>allow mounting of /dev/foo anywhere, as read only. Some matching
mount commands: $ mount -o ro /dev/foo /mnt $ mount -o ro /dev/foo
/some/where/else</p>
</dd>
<dt>mount options=(ro,atime) /dev/foo,</dt>
<dd>
<p>allow mount of /dev/foo anywhere, as read only and using inode access
times. Some matching mount commands: $ mount -o ro,atime /dev/foo /mnt $
mount -o ro,atime /dev/foo /some/where/else</p>
</dd>
<dt>mount options in (ro,atime) /dev/foo,</dt>
<dd>
<p>allow mount of /dev/foo anywhere using some combination of 'ro' and
'atime' (see above). Some matching mount commands: $ mount -o ro
/dev/foo /mnt $ mount -o atime /dev/foo /some/where/else $ mount -o
ro,atime /dev/foo /some/other/place</p>
</dd>
<dt>mount options=ro /dev/foo, mount options=atime /dev/foo,</dt>
<dd>
<p>allow mount of /dev/foo anywhere as read only, and allow mount of
/dev/foo anywhere using inode access times. Note this is expressed as
two different rules. Matches: $ mount -o ro /dev/foo /mnt/1 $ mount -o
atime /dev/foo /mnt/2</p>
</dd>
<dt>mount -&gt; /mnt/**,</dt>
<dd>
<p>allow mounting anything under a directory in /mnt/**. Some matching
mount commands: $ mount /dev/foo1 /mnt/1 $ mount -o
ro,atime,noexec,nodiratime /dev/foo2 /mnt/deep/path/foo2</p>
</dd>
<dt>mount options=ro -&gt; /mnt/**,</dt>
<dd>
<p>allow mounting anything under /mnt/**, as read only. Some matching
mount commands: $ mount -o ro /dev/foo1 /mnt/1 $ mount -o ro /dev/foo2
/mnt/deep/path/foo2</p>
</dd>
<dt>mount fstype=ext3 options=(rw,atime) /dev/sdb1 -&gt;
/mnt/stick/,</dt>
<dd>
<p>allow mounting an ext3 filesystem in /dev/sdb1 on /mnt/stick as
read/write and using inode access times. Matches only: $ mount -o
rw,atime /dev/sdb1 /mnt/stick</p>
</dd>
<dt>mount options=(ro, atime) options in (nodev, user) /dev/foo -&gt;
/mnt/,</dt>
<dd>
<p>allow mounting /dev/foo on /mmt/ read only and using inode access
times or allow mounting /dev/foo on /mnt/ with some combination of
'nodev' and 'user'. Matches only: $ mount -o ro,atime /dev/foo /mnt $
mount -o nodev /dev/foo /mnt $ mount -o user /dev/foo /mnt $ mount -o
nodev,user /dev/foo /mnt</p>
</dd>
</dl>
<h2>Pivot Root Rules</h2>
<p>AppArmor mediates changing of the root filesystem through the
<strong>pivot_root</strong> (2) system call. The syntax of 'pivot_root'
rules in AppArmor is based on the <strong>pivot_root</strong> (2) system
call parameters with the notable exception that the ordering is
reversed. The path corresponding to the put_old parameter of
<strong>pivot_root</strong> (2) is optionally specified in the
'pivot_root' rule using the 'oldroot=' prefix.</p>
<p>AppArmor 'pivot_root' rules can specify a profile transition to occur
during the <strong>pivot_root</strong> (2) system call. Note that
AppArmor will only transition the process calling
<strong>pivot_root</strong> (2) to the new profile.</p>
<p>The paths specified in 'pivot_root' rules must end with '/' since
they are directories.</p>
<p>Here are some example 'pivot_root' rules:</p>
<p># Allow any pivot pivot_root, # Allow pivoting to any new root
directory and putting the old root # directory at /mnt/root/old/
pivot_root oldroot=/mnt/root/old/, # Allow pivoting the root directory
to /mnt/root/ pivot_root /mnt/root/, # Allow pivoting to /mnt/root/ and
putting the old root directory at # /mnt/root/old/ pivot_root
oldroot=/mnt/root/old/ /mnt/root/, # Allow pivoting to /mnt/root/,
putting the old root directory at # /mnt/root/old/ and transition to the
/mnt/root/sbin/init profile pivot_root oldroot=/mnt/root/old/ /mnt/root/
-&gt; /mnt/root/sbin/init,</p>
<h2>PTrace rules</h2>
<p>AppArmor supports mediation of <strong>ptrace</strong> (2). AppArmor
PTrace rules are accumulated so that the granted PTrace permissions are
the union of all the listed PTrace rule permissions.</p>
<p>AppArmor PTrace permissions are implied when a rule does not
explicitly state an access list. By default, all PTrace permissions are
implied.</p>
<p>The trace and tracedby permissions govern <strong>ptrace</strong> (2)
while read and readby govern certain <strong>proc</strong> (5)
filesystem accesses, <strong>kcmp</strong> (2), futexes
(<strong>get_robust_list</strong> (2)) and perf trace events.</p>
<p>For a ptrace operation to be allowed the profile of the tracing
process and the profile of the target task must both have the correct
permissions. For example, the profile of the process attaching to
another task must have the trace permission for the target task's
profile, and the task being traced must have the tracedby permission for
the tracing process' profile.</p>
<p>Example AppArmor PTrace rules:</p>
<p># Allow all PTrace access ptrace, # Explicitly allow all PTrace
access, ptrace (read, readby, trace, tracedby), # Explicitly deny use of
ptrace(2) deny ptrace (trace), # Allow unconfined processes (eg, a
debugger) to ptrace us ptrace (readby, tracedby) peer=unconfined, #
Allow ptrace of a process running under the /usr/bin/foo profile ptrace
(trace) peer=/usr/bin/foo,</p>
<h2>Signal rules</h2>
<p>AppArmor supports mediation of <strong>signal</strong> (7). AppArmor
signal rules are accumulated so that the granted signal permissions are
the union of all the listed signal rule permissions.</p>
<p>AppArmor signal permissions are implied when a rule does not
explicitly state an access list. By default, all signal permissions are
implied.</p>
<p>For the sending of a signal to be allowed, the profile of the sending
process and the profile of the target task must both have the correct
permissions. For example, the profile of a process sending a signal to
another task must have the send permission for the target task's
profile, and the task receiving the signal must have a receive
permission for the sending process' profile.</p>
<p>Example AppArmor signal rules:</p>
<p># Allow all signal access signal, # Explicitly deny sending the HUP
and INT signals deny signal (send) set=(hup, int), # Allow unconfined
processes to send us signals signal (receive) peer=unconfined, # Allow
sending of signals to a process running under the /usr/bin/foo # profile
signal (send) peer=/usr/bin/foo, # Allow checking for PID existence
signal (receive, send) set=("exists"), # Allow us to signal ourselves
using the built-in @{profile_name} variable signal peer=@{profile_name},
# Allow two real-time signals signal set=(rtmin+0 rtmin+32),</p>
<h2>DBus rules</h2>
<p>AppArmor supports DBus mediation. The mediation is performed in
conjunction with the DBus daemon. The DBus daemon verifies that
communications over the bus are permitted by AppArmor policy.</p>
<p>AppArmor DBus rules are accumulated so that the granted DBus
permissions are the union of all the listed DBus rule permissions.</p>
<p>AppArmor DBus rules are broad and general and become more restrictive
as further information is specified. Policy may be specified down to the
interface member level (method or signal name), however the contents of
messages are not examined.</p>
<p>Some AppArmor DBus permissions are not compatible with all AppArmor
DBus rules. The 'bind' permission cannot be used in message rules. The
'send' and 'receive' permissions cannot be used in service rules. The
'eavesdrop' permission cannot be used in rules containing any
conditionals outside of the 'bus' conditional.</p>
<p>'r' and 'read' are synonyms for 'receive'. 'w' and 'write' are
synonyms for 'send'. 'rw' is a synonym for both 'send' and
'receive'.</p>
<p>AppArmor DBus permissions are implied when a rule does not explicitly
state an access list. By default, all DBus permissions are implied. Only
message permissions are implied for message rules and only service
permissions are implied for service rules.</p>
<p>Example AppArmor DBus rules:</p>
<p># Allow all DBus access dbus, # Explicitly allow all DBus access,
dbus (send, receive, bind), # Deny send/receive/bind access to the
session bus deny dbus bus=session, # Allow bind access for a particular
name on any bus dbus bind name=com.example.ExampleName, # Allow receive
access for a particular path and interface dbus receive
path=/com/example/path interface=com.example.Interface, # Deny
send/receive access to the system bus for a particular interface deny
dbus bus=system interface=com.example.ExampleInterface, # Allow send
access for a particular path, interface, member, and pair of # peer
names: dbus send bus=session path=/com/example/path
interface=com.example.Interface member=ExampleMethod
peer=(name=(com.example.ExampleName1|com.example.ExampleName2)), # Allow
receive access for all unconfined peers dbus receive
peer=(label=unconfined), # Allow eavesdropping on the system bus dbus
eavesdrop bus=system, # Allow and audit all eavesdropping audit dbus
eavesdrop,</p>
<h2>Unix socket rules</h2>
<p>AppArmor supports fine grained mediation of unix domain abstract and
anonymous sockets. Unix domain sockets with file system paths are
mediated via file access rules.</p>
<p>Abstract unix domain sockets is a nonportable Linux extension of unix
domain sockets, see <strong>unix</strong> (7) for more information.</p>
<p><em>Unix socket address paths</em></p>
<p>The sun_path component (aka the socket address) of a unix domain
socket is specified by the</p>
<p>addr=</p>
<p>conditional. If an address conditional is not specified as part of a
rule then the rule matches both abstract and anonymous sockets.</p>
<p>In apparmor the address of an abstract unix domain socket begins with
the <em>@</em> character, similar to how they are reported (as paths) by
netstat -x. The address then follows and may contain pattern matching
and any characters including the null character. In apparmor null
characters must be specified by using an escape sequence <em>\000</em>
or <em>\x00</em>. The pattern matching is the same as is used by file
path matching so * will not match <em>/</em> even though it has no
special meaning with in an abstract socket name. Eg.</p>
<p>unix addr=@*,</p>
<p>Autobound unix domain sockets have a unix sun_path assigned to them
by the kernel, as such specifying a policy based address is not
possible. The autobinding of sockets can be controlled by specifying the
special <em>auto</em> keyword. Eg.</p>
<p>unix addr=auto,</p>
<p>To indicate that the rule only applies to auto binding of unix domain
sockets. It is important to note this only applies to the <em>bind</em>
permission as once the socket is bound to an address it is
indistinguishable from a socket that have an addr bound with a specified
name. When the <em>auto</em> keyword is used with other permissions or
as part of a peer addr it will be replaced with a pattern that can match
an autobound socket. Eg. For some kernels</p>
<p>unix rw addr=auto,</p>
<p>is transformed to</p>
<p>unix rw addr=@[a-f0-9][a-f0-9][a-f0-9][a-f0-9][a-f0-9],</p>
<p>It is important to note, this pattern may match abstract sockets that
were not autobound but have an addr that fits what is generated by the
kernel when autobinding a socket.</p>
<p>Anonymous unix domain sockets have no sun_path associated with the
socket address, however it can be specified with the special
<em>none</em> keyword to indicate the rule only applies to anonymous
unix domain sockets. Eg.</p>
<p>unix addr=none,</p>
<p>If the address component of a rule is not specified then the rule
applies to autobind, abstract and anonymous sockets.</p>
<p><em>Unix socket permissions</em></p>
<p>Unix domain socket rules are accumulated so that the granted unix
socket permissions are the union of all the listed unix rule
permissions.</p>
<p>Unix domain socket rules are broad and general and become more
restrictive as further information is specified. Policy may be specified
down to the socket address (aka sun_path) and label level. The content
of the communication is not examined.</p>
<p>Unix socket rule permissions are implied when a rule does not
explicitly state an access list. By default if a rule does not have an
access list all permissions that are compatible with the specified set
of local and peer conditionals are implied.</p>
<p>The create, bind, listen, shutdown, getattr, setattr, getopt, and
setopt permissions are local socket permissions. They are only applied
to the local socket and can't be specified in rules that have a peer
component. The accept permission applies to the combination of a local
and peer socket. The connect, send, and receive permissions are peer
socket permissions.</p>
<p>Only the peer socket permissions will be applied to rules that don't
specify permissions and contain a peer component.</p>
<p><em>Example Unix domain socket rules:</em></p>
<p># Allow all permissions to unix sockets unix, # Explicitly allow all
unix permissions unix (create, listen, accept, connect, send, receive,
getattr, setattr, setopt, getopt), # Explicitly deny unix socket access
deny unix, # Allow create and use of abstract and anonymous sockets for
profile_name unix peer=(label=@{profile_name}), # Allow receiving via
unix sockets from unconfined unix (receive) peer=(label=unconfined), #
Allow getattr and shutdown on anonymous sockets unix (getattr, shutdown)
addr=none, # Allow SOCK_STREAM connect, receive and send on an abstract
socket @bar # with peer running under profile /foo unix (connect,
receive, send) type=stream peer=(label=/foo,addr="@bar"), # Allow
accepting connections from and receiving from peer running under #
profile /bar on abstract socket @foo unix (accept, receive) addr=@foo
peer=(label=/bar),</p>
<p><em>Abstract unix domain sockets autobind</em></p>
<p>Abstract unix domain sockets can autobind to an address. The autobind
address is a unique 5 digit string of decimal numbers, eg.
<code>@00001</code>. There is nothing that prevents a task from manually
binding to addresses with a similar pattern so it is impossible to
reliably identify autobind addresses from a regular address.</p>
<p><em>Interaction of network rules and fine grained unix domain socket
rules</em></p>
<p>The coarse grained networking rules can be used to control unix
domain sockets as well. When fine grained unix domain socket mediation
is available the coarse grained network rule is mapped into the
equivalent unix socket rule.</p>
<p>E.G.</p>
<p>network unix, =&gt; unix, network unix stream, =&gt; unix stream,</p>
<p>Fine grained mediation rules however can not be losslessly converted
back to the coarse grained network rule; e.g.</p>
<p>unix bind addr=@example,</p>
<p>Has no exact match under coarse grained network rules, the closest
match is the much wider permission rule of</p>
<p>network unix,</p>
<h2>change_profile rules</h2>
<p>AppArmor supports self directed profile transitions via the
change_profile api. Change_profile rules control which permissions for
which profiles a confined task can transition to. The profile name can
contain apparmor pattern matching to specify different profiles.</p>
<p>change_profile -&gt; **,</p>
<p>The change_profile api allows the transition to be delayed until when
a task executes another application. If an exec rule transition is
specified for the application and the change_profile api is used to make
a transition at exec time, the transition specified by the
change_profile api takes precedence.</p>
<p>The Change_profile permission can restrict which profiles can be
transitioned to based off of the executable name by specifying the exec
condition.</p>
<p>change_profile /bin/bash -&gt; new_profile,</p>
<p>The restricting of the transition profile to a given executable at
exec time is only useful when then current task is allowed to make
dynamic decisions about what confinement should be, but the decision set
needs to be controlled. A list of profiles or multiple rules can be used
to specify the profiles in the set. Eg.</p>
<p>change_profile /bin/bash -&gt;
{new_profile1,new_profile2,new_profile3},</p>
<p>An exec rule can be used to specify a transition for the executable,
if the transition should be allowed even if the change_profile api has
not been used to select a transition for those available in the
change_profile rule set. Eg.</p>
<p>/bin/bash Px -&gt; new_profile1, change_profile /bin/bash -&gt;
{new_profile1,new_profile2,new_profile3},</p>
<p>The exec mode dictates whether or not the Linux Kernel's
<strong>unsafe_exec</strong> routines should be used to scrub the
environment, similar to setuid programs. (See <strong>ld.so</strong> (8)
for some information on setuid/setgid environment scrubbing.) The
<strong>safe</strong> mode sets up environment scrubbing to occur when
the new application is executed and <strong>unsafe</strong> mode
disables AppArmor's requirement for environment scrubbing (the kernel
and/or libc may still require environment scrubbing). An exec mode can
only be specified when an exec condition is present.</p>
<p>change_profile safe /bin/bash -&gt; new_profile,</p>
<p>Not all kernels support <strong>safe</strong> mode and the parser
will downgrade rules to <strong>unsafe</strong> mode in that situation.
If no exec mode is specified, the default is <strong>safe</strong> mode
in kernels that support it.</p>
<h2>rlimit rules</h2>
<p>AppArmor can set and control the resource limits associated with a
profile as described in the <strong>setrlimit</strong> (2) man page.</p>
<p>The AppArmor rlimit controls allow setting of limits and restricting
changes of them and these actions can be audited. Enforcement of the set
limits is handled by the standard kernel enforcement mechanism for
rlimits and will not result in an audited apparmor message if the limit
is enforced.</p>
<p>If a profile does not have an rlimit rule associated with a given
rlimit then the rlimit is left alone and regular access, including
changing the limit, is allowed. However if the profile sets an rlimit
then the current limit is checked and if greater than the limit
specified in the rule it will be changed to the specified limit.</p>
<p>AppArmor rlimit rules control the hard limit of an application and
ensure that if the hard limit is lowered that the soft limit does not
exceed the hard limit value.</p>
<p>Eg.</p>
<p>set rlimit data &lt;= 100M, set rlimit nproc &lt;= 10, set rlimit
nice &lt;= 5,</p>
<h2>Variables</h2>
<p>AppArmor's policy language allows embedding variables into file rules
to enable easier configuration for some common (and pervasive) setups.
Variables may have multiple values assigned, but any variable
assignments must be made before the start of the profile.</p>
<p>The parser will automatically expand variables to include all values
that they have been assigned; it is an error to reference a variable
without setting at least one value. You can use empty quotes ("") to
explicitly add an empty value.</p>
<p>At the time of this writing, the following variables are defined in
the provided AppArmor policy:</p>
<p>@{HOME} @{HOMEDIRS} @{multiarch} @{pid} @{pids} @{PROC} @{securityfs}
@{apparmorfs} @{sys} @{tid} @{run} @{XDG_DESKTOP_DIR}
@{XDG_DOWNLOAD_DIR} @{XDG_TEMPLATES_DIR} @{XDG_PUBLICSHARE_DIR}
@{XDG_DOCUMENTS_DIR} @{XDG_MUSIC_DIR} @{XDG_PICTURES_DIR}
@{XDG_VIDEOS_DIR}</p>
<p>These are defined in files in <em>/etc/apparmor.d/tunables</em> and
are used in many of the abstractions described later.</p>
<p>You may also add files in <em>/etc/apparmor.d/tunables/home.d</em>
for site-specific customization of <strong>@{HOMEDIRS}</strong>,
<em>/etc/apparmor.d/tunables/multiarch.d</em> for
<strong>@{multiarch}</strong> and
<em>/etc/apparmor.d/tunables/xdg-user-dirs.d</em> for
<strong>@{XDG_*}</strong>.</p>
<p>The special <strong>@{profile_name}</strong> variable is set to the
profile name and may be used in all policy.</p>
<h2>Alias rules</h2>
<p>AppArmor also provides alias rules for remapping paths for
site-specific layouts. They are an alternative form of path rewriting to
using variables, and are done after variable resolution. Alias rules
must occur within the preamble of the profile. System-wide aliases are
found in <em>/etc/apparmor.d/tunables/alias</em>, which is included by
<em>/etc/apparmor.d/tunables/global</em>.
<em>/etc/apparmor.d/tunables/global</em> is typically included at the
beginning of an AppArmor profile.</p>
<h2>Globbing</h2>
<p>File resources may be specified with a globbing syntax similar to
that used by popular shells, such as <strong>csh</strong> (1),
<strong>bash</strong> (1), <strong>zsh</strong> (1).</p>
<ul>
<li><p>can substitute for any number of characters, excepting
'/'</p></li>
</ul>
<dl>
<dt>**</dt>
<dd>
<p>can substitute for any number of characters, including '/'</p>
</dd>
<dt>?</dt>
<dd>
<p>can substitute for any single character excepting '/'</p>
</dd>
<dt>[abc]</dt>
<dd>
<p>will substitute for the single character a, b, or c</p>
</dd>
<dt>[a-c]</dt>
<dd>
<p>will substitute for the single character a, b, or c</p>
</dd>
<dt>[^a-c]</dt>
<dd>
<p>will substitute for any single character not matching a, b or c</p>
</dd>
<dt>{ab,cd}</dt>
<dd>
<p>will expand to one rule to match ab, one rule to match cd</p>
</dd>
</dl>
<p>When AppArmor looks up a directory the pathname being looked up will
end with a slash (e.g., <em>/var/tmp/</em>); otherwise it will not end
with a slash. Only rules that match a trailing slash will match
directories. Some examples, none matching the <em>/tmp/</em> directory
itself, are:</p>
<dl>
<dt>/tmp/*</dt>
<dd>
<p>Files directly in <em>/tmp</em>.</p>
</dd>
<dt>/tmp/*/</dt>
<dd>
<p>Directories directly in <em>/tmp</em>.</p>
</dd>
<dt>/tmp/**</dt>
<dd>
<p>Files and directories anywhere underneath <em>/tmp</em>.</p>
</dd>
<dt>/tmp/**/</dt>
<dd>
<p>Directories anywhere underneath <em>/tmp</em>.</p>
</dd>
</dl>
<h2>Rule Qualifiers</h2>
<p>There are several rule qualifiers that can be applied to permission
rules. Rule qualifiers can modify the rule and/or permissions within the
rule.</p>
<dl>
<dt>allow</dt>
<dd>
<p>Specifies that permissions requests that match the rule are allowed.
This is the default value for rules and does not need to be specified.
Conflicts with the <em>deny</em> qualifier.</p>
</dd>
<dt>audit</dt>
<dd>
<p>Specifies that permissions requests that match the rule should be
recorded to the audit log.</p>
</dd>
<dt>deny</dt>
<dd>
<p>Specifies that permissions requests that match the rule should be
denied without logging. Can be combined with 'audit' to enable logging.
Conflicts with the <em>allow</em> qualifier.</p>
</dd>
<dt>owner</dt>
<dd>
<p>Specifies that the task must have the same euid/fsuid as the object
being referenced by the permission check.</p>
</dd>
</dl>
<p><em>Qualifier Blocks</em></p>
<p>Rule Qualifiers can be applied to multiple rules at a time by
grouping the rules into a rule block.</p>
<p>audit { /foo r, network, }</p>
<h2>#include mechanism</h2>
<p>AppArmor provides an easy abstraction mechanism to group common
access requirements; this abstraction is an extremely flexible way to
grant site-specific rights and makes writing new AppArmor profiles very
simple by assembling the needed building blocks for any given
program.</p>
<p>The use of '#include' is modelled directly after
<strong>cpp</strong> (1); its use will replace the '#include' statement
with the specified file's contents. The leading '#' is optional, and the
'#include' keyword can be followed by an option conditional 'if exists'
that specifies profile compilation should continue if the specified file
or directory is not found.</p>
<p><strong>#include /absolute/path</strong> specifies that
<em>/absolute/path</em> should be used. <strong>#include
relative/path</strong> specifies that <em>relative/path</em> should be
used, where the path is relative to the current working directory.
<strong>#include &lt;magic/path&gt;</strong> is the most common usage;
it will load <em>magic/path</em> relative to a directory specified to
<strong>apparmor_parser</strong> (8). <em>/etc/apparmor.d/</em> is the
AppArmor default.</p>
<p>The supplied AppArmor profiles follow several conventions; the
abstractions stored in <em>/etc/apparmor.d/abstractions/</em> are some
large clusters that are used in most profiles. What follows are short
descriptions of how some of the abstractions are used.</p>
<dl>
<dt>abstractions/audio</dt>
<dd>
<p>Includes accesses to device files used for audio applications.</p>
</dd>
<dt>abstractions/authentication</dt>
<dd>
<p>Includes access to files and services typically necessary for
services that perform user authentication.</p>
</dd>
<dt>abstractions/base</dt>
<dd>
<p>Includes files that should be readable and writable in all
profiles.</p>
</dd>
<dt>abstractions/bash</dt>
<dd>
<p>Includes many files used by bash; useful for interactive shells and
programs that call <strong>system</strong> (3).</p>
</dd>
<dt>abstractions/consoles</dt>
<dd>
<p>Includes read and write access to the device files controlling the
virtual console, <strong>sshd</strong> (8), <strong>xterm</strong> (1),
etc. This abstraction is needed for many programs that interact with
users.</p>
</dd>
<dt>abstractions/fonts</dt>
<dd>
<p>Includes access to fonts and the font libraries.</p>
</dd>
<dt>abstractions/gnome</dt>
<dd>
<p>Includes read and write access to GNOME configuration files, as well
as read access to GNOME libraries.</p>
</dd>
<dt>abstractions/kde</dt>
<dd>
<p>Includes read and write access to KDE configuration files, as well as
read access to KDE libraries.</p>
</dd>
<dt>abstractions/kerberosclient</dt>
<dd>
<p>Includes file access rules needed for common kerberos clients.</p>
</dd>
<dt>abstractions/nameservice</dt>
<dd>
<p>Includes file rules to allow DNS, LDAP, NIS, SMB, user and group
password databases, services, and protocols lookups.</p>
</dd>
<dt>abstractions/perl</dt>
<dd>
<p>Includes read access to perl modules.</p>
</dd>
<dt>abstractions/user-download</dt>
<dd>

</dd>
</dl>
<dl>
<dt>abstractions/user-mail</dt>
<dd>

</dd>
<dt>abstractions/user-manpages</dt>
<dd>

</dd>
<dt>abstractions/user-tmp</dt>
<dd>

</dd>
<dt>abstractions/user-write</dt>
<dd>

</dd>
</dl>
<p>Some profiles for typical user programs will use these include files
to describe rights that users have in the system.</p>
<dl>
<dt>abstractions/wutmp</dt>
<dd>
<p>Includes write access to files used to maintain
<strong>wtmp</strong> (5) and <strong>utmp</strong> (5) databases, used
with the w(1) and associated commands.</p>
</dd>
<dt>abstractions/X</dt>
<dd>
<p>Includes read access to libraries, configuration files, X
authentication files, and the X socket.</p>
</dd>
</dl>
<p>Some of the abstractions rely on variables that are set in files in
the <em>/etc/apparmor.d/tunables/</em> directory. These variables are
currently <strong>@{HOME}</strong> and <strong>@{HOMEDIRS}</strong>.
Variables cannot be set in profile scope; they can only be set before
the profile. Therefore, any profiles that use abstractions should either
<strong>#include &lt;tunables/global&gt;</strong> or otherwise ensure
that <strong>@{HOME}</strong> and <strong>@{HOMEDIRS}</strong> are set
before starting the profile definition. The
<strong>aa-autodep</strong> (8) and <strong>aa-genprof</strong> (8)
utilities will automatically emit <strong>#include
&lt;tunables/global&gt;</strong> in generated profiles.</p>
<h2>Feature ABI</h2>
<p>The feature abi tells AppArmor which feature set the policy was
developed under. This is important to ensure that kernels with a
different feature set don't enforce features that the policy doesn't
support, which can result in unexpected application failures.</p>
<p>When policy is compiled both the kernel feature abi and policy
feature abi are consulted to build a policy that will work for the
system's kernel.</p>
<p>If the kernel supports a feature not supported by the policy then
policy will be built so that the kernel does NOT enforce that
feature.</p>
<p>If the policy supports a feature not supported by the kernel the
compile may downgrade the rule with the feature to something the kernel
supports, drop the rule completely, or fail the compile.</p>
<p>If the policy abi is specified as <strong>kernel</strong> then the
running kernel's abi will be used. This should never be used in shipped
policy as it can cause system breakage when a new kernel is
installed.</p>
<p><em>ABI compatibility with AppArmor 2.x</em></p>
<p>AppArmor 3 remains compatible with AppArmor 2.x by detecting when a
profile does not have a feature ABI specified. In this case the policy
compile will either apply the pinned feature ABI as specified by the
config file or the command line, or if neither of those are applied by
using a default feature ABI.</p>
<p>It is important to note that the default feature ABI does not support
new features added in AppArmor 3 or later.</p>
<h1>EXAMPLE</h1>
<p>An example AppArmor profile:</p>
<p># which feature abi the policy was developed with abi
&lt;abi/3.0&gt;, # a variable definition in the preamble @{HOME} =
/home/*/ /root/ # a comment about foo. /usr/bin/foo { /bin/mount ux,
/dev/{,u}random r, /etc/ld.so.cache r, /etc/foo.conf r, /etc/foo/* r,
/lib/ld-*.so* rmix, /lib/lib*.so* r, /proc/[0-9]** r, /usr/lib/** r,
/tmp/foo.pid wr, /tmp/foo.* lrw, /@{HOME}/.foo_file rw, /usr/bin/baz Cx
-&gt; baz, # a comment about foos hat (subprofile), bar. ^bar {
/lib/ld-*.so* rmix, /usr/bin/bar rmix, /var/spool/* rwl, } # a comment
about foos subprofile, baz. profile baz { #include
&lt;abstractions/bash&gt; owner /proc/[0-9]*/stat r, /bin/bash ixr,
/var/lib/baz/ r, owner /var/lib/baz/* rw, } }</p>
<h1>FILES</h1>
<dl>
<dt>/etc/init.d/boot.apparmor</dt>
<dd>

</dd>
</dl>
<dl>
<dt>/etc/apparmor.d/</dt>
<dd>

</dd>
</dl>
<h1>KNOWN BUGS</h1>
<ul>
<li><p>Mount options support the use of pattern matching but mount flags
are not correctly intersected against specified patterns. Eg, 'mount
options=**,' should be equivalent to 'mount,', but it is not. (LP:
#965690)</p></li>
<li><p>The fstype may not be matched against when certain mount command
flags are used. Specifically fstype matching currently only works when
creating a new mount and not remount, bind, etc.</p></li>
<li><p>Mount rules with multiple 'options' conditionals are not applied
as documented but instead merged such that 'options in (ro,nodev)
options in (atime)' is equivalent to 'options in
(ro,nodev,atime)'.</p></li>
<li><p>When specifying mount options with the 'in' conditional, both the
positive and negative values match when specifying one or the other. Eg,
'rw' matches when 'ro' is specified and 'dev' matches when 'nodev' is
specified such that 'options in (ro,nodev)' is equivalent to 'options in
(rw,dev)'.</p></li>
</ul>
<h1>SEE ALSO</h1>
<p><strong>apparmor</strong> (7), <strong>apparmor_parser</strong> (8),
<strong>apparmor_xattrs</strong> (7), <strong>aa-complain</strong> (1),
<strong>aa-enforce</strong> (1), <strong>aa_change_hat</strong> (2),
<strong>mod_apparmor</strong> (5), and
&lt;https://wiki.apparmor.net&gt;.</p>
