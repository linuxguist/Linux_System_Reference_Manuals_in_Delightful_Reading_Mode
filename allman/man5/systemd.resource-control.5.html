<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>systemd.resource-control - Resource control unit settings</p>
<h1>SYNOPSIS</h1>
<p><em>slice</em>.slice, <em>scope</em>.scope, <em>service</em>.service,
<em>socket</em>.socket, <em>mount</em>.mount, <em>swap</em>.swap</p>
<h1>DESCRIPTION</h1>
<p>Unit configuration files for services, slices, scopes, sockets, mount
points, and swap devices share a subset of configuration options for
resource control of spawned processes. Internally, this relies on the
Linux Control Groups (cgroups) kernel concept for organizing processes
in a hierarchical tree of named groups for the purpose of resource
management.</p>
<p>This man page lists the configuration options shared by those six
unit types. See <strong>systemd.unit</strong>(5) for the common options
of all unit configuration files, and <strong>systemd.slice</strong>(5),
<strong>systemd.scope</strong>(5), <strong>systemd.service</strong>(5),
<strong>systemd.socket</strong>(5), <strong>systemd.mount</strong>(5),
and <strong>systemd.swap</strong>(5) for more information on the
specific unit configuration files. The resource control configuration
options are configured in the [Slice], [Scope], [Service], [Socket],
[Mount], or [Swap] sections, depending on the unit type.</p>
<p>In addition, options which control resources available to programs
<em>executed</em> by systemd are listed in
<strong>systemd.exec</strong>(5). Those options complement options
listed here.</p>
<h2>Enabling and disabling controllers</h2>
<p>Controllers in the cgroup hierarchy are hierarchical, and resource
control is realized by distributing resource assignments between
siblings in branches of the cgroup hierarchy. There is no need to
explicitly <em>enable</em> a cgroup controller for a unit.
<strong>systemd</strong> will instruct the kernel to enable a controller
for a given unit when this unit has configuration for a given
controller. For example, when <em>CPUWeight=</em> is set, the
<strong>cpu</strong> controller will be enabled, and when
<em>TasksMax=</em> are set, the <strong>pids</strong> controller will be
enabled. In addition, various controllers may be also be enabled
explicitly via the
<em>MemoryAccounting=</em>/<em>TasksAccounting=</em>/<em>IOAccounting=</em>
settings. Because of how the cgroup hierarchy works, controllers will be
automatically enabled for all parent units and for any sibling units
starting with the lowest level at which a controller is enabled. Units
for which a controller is enabled may be subject to resource control
even if they dont have any explicit configuration.</p>
<p>Setting <em>Delegate=</em> enables any delegated controllers for that
unit (see below). The delegatee may then enable controllers for its
children as appropriate. In particular, if the delegatee is
<strong>systemd</strong> (in the user@.service unit), it will repeat the
same logic as the system instance and enable controllers for user units
which have resource limits configured, and their siblings and parents
and parents siblings.</p>
<p>Controllers may be <em>disabled</em> for parts of the cgroup
hierarchy with <em>DisableControllers=</em> (see below).</p>
<p><strong>Example 1. Enabling and disabling controllers</strong></p>
<blockquote>
<pre><code>                      -.slice
                     /       \
              /-----/         \--------------\
             /                                \
      system.slice                       user.slice
        /       \                          /      \
       /         \                        /        \
      /           \              user@42.service  user@1000.service
     /             \             Delegate=        Delegate=yes
a.service       b.slice                             /        \
CPUWeight=20   DisableControllers=cpu              /          \
                 /  \                      app.slice      session.slice
                /    \                     CPUWeight=100  CPUWeight=100
               /      \
       b1.service   b2.service
                    CPUWeight=1000
        </code></pre>
</blockquote>
<p>In this hierarchy, the <strong>cpu</strong> controller is enabled for
all units shown except b1.service and b2.service. Because there is no
explicit configuration for system.slice and user.slice, CPU resources
will be split equally between them. Similarly, resources are allocated
equally between children of user.slice and between the child slices
beneath user@1000.service. Assuming that there is no futher
configuration of resources or delegation below slices app.slice or
session.slice, the <strong>cpu</strong> controller would not be enabled
for units in those slices and CPU resources would be further allocated
using other mechanisms, e.g. based on nice levels. The manager for user
42 has delegation enabled without any controllers, i.e. it can
manipulate its subtree of the cgroup hierarchy, but without resource
control.</p>
<p>In the slice system.slice, CPU resources are split 1:6 for service
a.service, and 5:6 for slice b.slice, because slice b.slice gets the
default value of 100 for cpu.weight when <em>CPUWeight=</em> is not
set.</p>
<p><em>CPUWeight=</em> setting in service b2.service is neutralized by
<em>DisableControllers=</em> in slice b.slice, so the
<strong>cpu</strong> controller would not be enabled for services
b1.service and b2.service, and CPU resources would be further allocated
using other mechanisms, e.g. based on nice levels.</p>
<h2>Setting resource controls for a group of related units</h2>
<p>As described in <strong>systemd.unit</strong>(5), the settings listed
here may be set through the main file of a unit and drop-in snippets in
*.d/ directories. The list of directories searched for drop-ins includes
names formed by repeatedly truncating the unit name after all dashes.
This is particularly convenient to set resource limits for a group of
units with similar names.</p>
<p>For example, every user gets their own slice user-<em>nnn</em>.slice.
Drop-ins with local configuration that affect user 1000 may be placed in
/etc/systemd/system/user-1000.slice,
/etc/systemd/system/user-1000.slice.d/*.conf, but also
/etc/systemd/system/user-.slice.d/*.conf. This last directory applies to
all user slices.</p>
<p>See the <strong>New Control Group Interfaces</strong>[1] for an
introduction on how to make use of resource control APIs from
programs.</p>
<h1>IMPLICIT DEPENDENCIES</h1>
<p>The following dependencies are implicitly added:</p>
<blockquote>
<p>·</p>
<p>Units with the <em>Slice=</em> setting set automatically acquire
<em>Requires=</em> and <em>After=</em> dependencies on the specified
slice unit.</p>
</blockquote>
<h1>OPTIONS</h1>
<p>Units of the types listed above can have settings for resource
control configuration:</p>
<p><em>CPUAccounting=</em></p>
<blockquote>
<p>Turn on CPU usage accounting for this unit. Takes a boolean argument.
Note that turning on CPU accounting for one unit will also implicitly
turn it on for all units contained in the same slice and for all its
parent slices and the units contained therein. The system default for
this setting may be controlled with <em>DefaultCPUAccounting=</em> in
<strong>systemd-system.conf</strong>(5).</p>
<p>Under the unified cgroup hierarchy, CPU accounting is available for
all units and this setting has no effect.</p>
</blockquote>
<p><em>CPUWeight=weight</em>, <em>StartupCPUWeight=weight</em></p>
<blockquote>
<p>These settings control the <strong>cpu</strong> controller in the
unified hierarchy.</p>
<p>These options accept an integer value or a the special string
"idle":</p>
<blockquote>
<p>·</p>
<p>If set to an integer value, assign the specified CPU time weight to
the processes executed, if the unified control group hierarchy is used
on the system. These options control the "cpu.weight" control group
attribute. The allowed range is 1 to 10000. Defaults to unset, but the
kernel default is 100. For details about this control group attribute,
see <strong>Control Groups v2</strong>[2] and <strong>CFS
Scheduler</strong>[3]. The available CPU time is split up among all
units within one slice relative to their CPU time weight. A higher
weight means more CPU time, a lower weight means less.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>If set to the special string "idle", mark the cgroup for "idle
scheduling", which means that it will get CPU resources only when there
are no processes not marked in this way to execute in this cgroup or its
siblings. This setting corresponds to the "cpu.idle" cgroup
attribute.</p>
<p>Note that this value only has an effect on cgroup-v2, for cgroup-v1
it is equivalent to the minimum weight.</p>
</blockquote>
<p>While <em>StartupCPUWeight=</em> applies to the startup and shutdown
phases of the system, <em>CPUWeight=</em> applies to normal runtime of
the system, and if the former is not set also to the startup and
shutdown phases. Using <em>StartupCPUWeight=</em> allows prioritizing
specific services at boot-up and shutdown differently than during normal
runtime.</p>
<p>In addition to the resource allocation performed by the
<strong>cpu</strong> controller, the kernel may automatically divide
resources based on session-id grouping, see "The autogroup feature" in
<strong>sched</strong>(7). The effect of this feature is similar to the
<strong>cpu</strong> controller with no explicit configuration, so users
should be careful to not mistake one for the other.</p>
</blockquote>
<p><em>CPUQuota=</em></p>
<blockquote>
<p>This setting controls the <strong>cpu</strong> controller in the
unified hierarchy.</p>
<p>Assign the specified CPU time quota to the processes executed. Takes
a percentage value, suffixed with "%". The percentage specifies how much
CPU time the unit shall get at maximum, relative to the total CPU time
available on one CPU. Use values &gt; 100% for allotting CPU time on
more than one CPU. This controls the "cpu.max" attribute on the unified
control group hierarchy and "cpu.cfs_quota_us" on legacy. For details
about these control group attributes, see <strong>Control Groups
v2</strong>[2] and <strong>CFS Bandwidth Control</strong>[4]. Setting
<em>CPUQuota=</em> to an empty value unsets the quota.</p>
<p>Example: <em>CPUQuota=20%</em> ensures that the executed processes
will never get more than 20% CPU time on one CPU.</p>
</blockquote>
<p><em>CPUQuotaPeriodSec=</em></p>
<blockquote>
<p>This setting controls the <strong>cpu</strong> controller in the
unified hierarchy.</p>
<p>Assign the duration over which the CPU time quota specified by
<em>CPUQuota=</em> is measured. Takes a time duration value in seconds,
with an optional suffix such as "ms" for milliseconds (or "s" for
seconds.) The default setting is 100ms. The period is clamped to the
range supported by the kernel, which is [1ms, 1000ms]. Additionally, the
period is adjusted up so that the quota interval is also at least 1ms.
Setting <em>CPUQuotaPeriodSec=</em> to an empty value resets it to the
default.</p>
<p>This controls the second field of "cpu.max" attribute on the unified
control group hierarchy and "cpu.cfs_period_us" on legacy. For details
about these control group attributes, see <strong>Control Groups
v2</strong>[2] and <strong>CFS Scheduler</strong>[3].</p>
<p>Example: <em>CPUQuotaPeriodSec=10ms</em> to request that the CPU
quota is measured in periods of 10ms.</p>
</blockquote>
<p><em>AllowedCPUs=</em>, <em>StartupAllowedCPUs=</em></p>
<blockquote>
<p>This setting controls the <strong>cpuset</strong> controller in the
unified hierarchy.</p>
<p>Restrict processes to be executed on specific CPUs. Takes a list of
CPU indices or ranges separated by either whitespace or commas. CPU
ranges are specified by the lower and upper CPU indices separated by a
dash.</p>
<p>Setting <em>AllowedCPUs=</em> or <em>StartupAllowedCPUs=</em> doesnt
guarantee that all of the CPUs will be used by the processes as it may
be limited by parent units. The effective configuration is reported as
<em>EffectiveCPUs=</em>.</p>
<p>While <em>StartupAllowedCPUs=</em> applies to the startup and
shutdown phases of the system, <em>AllowedCPUs=</em> applies to normal
runtime of the system, and if the former is not set also to the startup
and shutdown phases. Using <em>StartupAllowedCPUs=</em> allows
prioritizing specific services at boot-up and shutdown differently than
during normal runtime.</p>
<p>This setting is supported only with the unified control group
hierarchy.</p>
</blockquote>
<p><em>AllowedMemoryNodes=</em>, <em>StartupAllowedMemoryNodes=</em></p>
<blockquote>
<p>These settings control the <strong>cpuset</strong> controller in the
unified hierarchy.</p>
<p>Restrict processes to be executed on specific memory NUMA nodes.
Takes a list of memory NUMA nodes indices or ranges separated by either
whitespace or commas. Memory NUMA nodes ranges are specified by the
lower and upper NUMA nodes indices separated by a dash.</p>
<p>Setting <em>AllowedMemoryNodes=</em> or
<em>StartupAllowedMemoryNodes=</em> doesnt guarantee that all of the
memory NUMA nodes will be used by the processes as it may be limited by
parent units. The effective configuration is reported as
<em>EffectiveMemoryNodes=</em>.</p>
<p>While <em>StartupAllowedMemoryNodes=</em> applies to the startup and
shutdown phases of the system, <em>AllowedMemoryNodes=</em> applies to
normal runtime of the system, and if the former is not set also to the
startup and shutdown phases. Using <em>StartupAllowedMemoryNodes=</em>
allows prioritizing specific services at boot-up and shutdown
differently than during normal runtime.</p>
<p>This setting is supported only with the unified control group
hierarchy.</p>
</blockquote>
<p><em>MemoryAccounting=</em></p>
<blockquote>
<p>This setting controls the <strong>memory</strong> controller in the
unified hierarchy.</p>
<p>Turn on process and kernel memory accounting for this unit. Takes a
boolean argument. Note that turning on memory accounting for one unit
will also implicitly turn it on for all units contained in the same
slice and for all its parent slices and the units contained therein. The
system default for this setting may be controlled with
<em>DefaultMemoryAccounting=</em> in
<strong>systemd-system.conf</strong>(5).</p>
</blockquote>
<p><em>MemoryMin=bytes</em>, <em>MemoryLow=bytes</em></p>
<blockquote>
<p>These settings control the <strong>memory</strong> controller in the
unified hierarchy.</p>
<p>Specify the memory usage protection of the executed processes in this
unit. When reclaiming memory, the unit is treated as if it was using
less memory resulting in memory to be preferentially reclaimed from
unprotected units. Using <em>MemoryLow=</em> results in a weaker
protection where memory may still be reclaimed to avoid invoking the OOM
killer in case there is no other reclaimable memory.</p>
<p>For a protection to be effective, it is generally required to set a
corresponding allocation on all ancestors, which is then distributed
between children (with the exception of the root slice). Any
<em>MemoryMin=</em> or <em>MemoryLow=</em> allocation that is not
explicitly distributed to specific children is used to create a shared
protection for all children. As this is a shared protection, the
children will freely compete for the memory.</p>
<p>Takes a memory size in bytes. If the value is suffixed with K, M, G
or T, the specified memory size is parsed as Kilobytes, Megabytes,
Gigabytes, or Terabytes (with the base 1024), respectively.
Alternatively, a percentage value may be specified, which is taken
relative to the installed physical memory on the system. If assigned the
special value "infinity", all available memory is protected, which may
be useful in order to always inherit all of the protection afforded by
ancestors. This controls the "memory.min" or "memory.low" control group
attribute. For details about this control group attribute, see
<strong>Memory Interface Files</strong>[5].</p>
<p>Units may have their children use a default "memory.min" or
"memory.low" value by specifying <em>DefaultMemoryMin=</em> or
<em>DefaultMemoryLow=</em>, which has the same semantics as
<em>MemoryMin=</em> and <em>MemoryLow=</em>. This setting does not
affect "memory.min" or "memory.low" in the unit itself. Using it to set
a default child allocation is only useful on kernels older than 5.7,
which do not support the "memory_recursiveprot" cgroup2 mount
option.</p>
</blockquote>
<p><em>MemoryHigh=bytes</em></p>
<blockquote>
<p>These settings control the <strong>memory</strong> controller in the
unified hierarchy.</p>
<p>Specify the throttling limit on memory usage of the executed
processes in this unit. Memory usage may go above the limit if
unavoidable, but the processes are heavily slowed down and memory is
taken away aggressively in such cases. This is the main mechanism to
control memory usage of a unit.</p>
<p>Takes a memory size in bytes. If the value is suffixed with K, M, G
or T, the specified memory size is parsed as Kilobytes, Megabytes,
Gigabytes, or Terabytes (with the base 1024), respectively.
Alternatively, a percentage value may be specified, which is taken
relative to the installed physical memory on the system. If assigned the
special value "infinity", no memory throttling is applied. This controls
the "memory.high" control group attribute. For details about this
control group attribute, see <strong>Memory Interface
Files</strong>[5].</p>
</blockquote>
<p><em>MemoryMax=bytes</em></p>
<blockquote>
<p>These settings control the <strong>memory</strong> controller in the
unified hierarchy.</p>
<p>Specify the absolute limit on memory usage of the executed processes
in this unit. If memory usage cannot be contained under the limit,
out-of-memory killer is invoked inside the unit. It is recommended to
use <em>MemoryHigh=</em> as the main control mechanism and use
<em>MemoryMax=</em> as the last line of defense.</p>
<p>Takes a memory size in bytes. If the value is suffixed with K, M, G
or T, the specified memory size is parsed as Kilobytes, Megabytes,
Gigabytes, or Terabytes (with the base 1024), respectively.
Alternatively, a percentage value may be specified, which is taken
relative to the installed physical memory on the system. If assigned the
special value "infinity", no memory limit is applied. This controls the
"memory.max" control group attribute. For details about this control
group attribute, see <strong>Memory Interface Files</strong>[5].</p>
</blockquote>
<p><em>MemorySwapMax=bytes</em></p>
<blockquote>
<p>These settings control the <strong>memory</strong> controller in the
unified hierarchy.</p>
<p>Specify the absolute limit on swap usage of the executed processes in
this unit.</p>
<p>Takes a swap size in bytes. If the value is suffixed with K, M, G or
T, the specified swap size is parsed as Kilobytes, Megabytes, Gigabytes,
or Terabytes (with the base 1024), respectively. If assigned the special
value "infinity", no swap limit is applied. This controls the
"memory.swap.max" control group attribute. For details about this
control group attribute, see <strong>Memory Interface
Files</strong>[5].</p>
</blockquote>
<p><em>TasksAccounting=</em></p>
<blockquote>
<p>This setting controls the <strong>pids</strong> controller in the
unified hierarchy.</p>
<p>Turn on task accounting for this unit. Takes a boolean argument. If
enabled, the kernel will keep track of the total number of tasks in the
unit and its children. This number includes both kernel threads and
userspace processes, with each thread counted individually. Note that
turning on tasks accounting for one unit will also implicitly turn it on
for all units contained in the same slice and for all its parent slices
and the units contained therein. The system default for this setting may
be controlled with <em>DefaultTasksAccounting=</em> in
<strong>systemd-system.conf</strong>(5).</p>
</blockquote>
<p><em>TasksMax=N</em></p>
<blockquote>
<p>This setting controls the <strong>pids</strong> controller in the
unified hierarchy.</p>
<p>Specify the maximum number of tasks that may be created in the unit.
This ensures that the number of tasks accounted for the unit (see above)
stays below a specific limit. This either takes an absolute number of
tasks or a percentage value that is taken relative to the configured
maximum number of tasks on the system. If assigned the special value
"infinity", no tasks limit is applied. This controls the "pids.max"
control group attribute. For details about this control group attribute,
the <strong>pids controller</strong>[6].</p>
<p>The system default for this setting may be controlled with
<em>DefaultTasksMax=</em> in
<strong>systemd-system.conf</strong>(5).</p>
</blockquote>
<p><em>IOAccounting=</em></p>
<blockquote>
<p>This setting controls the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Turn on Block I/O accounting for this unit, if the unified control
group hierarchy is used on the system. Takes a boolean argument. Note
that turning on block I/O accounting for one unit will also implicitly
turn it on for all units contained in the same slice and all for its
parent slices and the units contained therein. The system default for
this setting may be controlled with <em>DefaultIOAccounting=</em> in
<strong>systemd-system.conf</strong>(5).</p>
</blockquote>
<p><em>IOWeight=weight</em>, <em>StartupIOWeight=weight</em></p>
<blockquote>
<p>These settings control the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Set the default overall block I/O weight for the executed processes,
if the unified control group hierarchy is used on the system. Takes a
single weight value (between 1 and 10000) to set the default block I/O
weight. This controls the "io.weight" control group attribute, which
defaults to 100. For details about this control group attribute, see
<strong>IO Interface Files</strong>[7]. The available I/O bandwidth is
split up among all units within one slice relative to their block I/O
weight. A higher weight means more I/O bandwidth, a lower weight means
less.</p>
<p>While <em>StartupIOWeight=</em> applies to the startup and shutdown
phases of the system, <em>IOWeight=</em> applies to the later runtime of
the system, and if the former is not set also to the startup and
shutdown phases. This allows prioritizing specific services at boot-up
and shutdown differently than during runtime.</p>
</blockquote>
<p><em>IODeviceWeight=device</em> <em></em> <em>weight</em></p>
<blockquote>
<p>This setting controls the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Set the per-device overall block I/O weight for the executed
processes, if the unified control group hierarchy is used on the system.
Takes a space-separated pair of a file path and a weight value to
specify the device specific weight value, between 1 and 10000. (Example:
"/dev/sda 1000"). The file path may be specified as path to a block
device node or as any other file, in which case the backing block device
of the file system of the file is determined. This controls the
"io.weight" control group attribute, which defaults to 100. Use this
option multiple times to set weights for multiple devices. For details
about this control group attribute, see <strong>IO Interface
Files</strong>[7].</p>
<p>The specified device node should reference a block device that has an
I/O scheduler associated, i.e. should not refer to partition or loopback
block devices, but to the originating, physical device. When a path to a
regular file or directory is specified it is attempted to discover the
correct originating device backing the file system of the specified
path. This works correctly only for simpler cases, where the file system
is directly placed on a partition or physical block device, or where
simple 1:1 encryption using dm-crypt/LUKS is used. This discovery does
not cover complex storage and in particular RAID and volume management
storage devices.</p>
</blockquote>
<p><em>IOReadBandwidthMax=device</em> <em></em> <em>bytes</em>,
<em>IOWriteBandwidthMax=device</em> <em></em> <em>bytes</em></p>
<blockquote>
<p>These settings control the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Set the per-device overall block I/O bandwidth maximum limit for the
executed processes, if the unified control group hierarchy is used on
the system. This limit is not work-conserving and the executed processes
are not allowed to use more even if the device has idle capacity. Takes
a space-separated pair of a file path and a bandwidth value (in bytes
per second) to specify the device specific bandwidth. The file path may
be a path to a block device node, or as any other file in which case the
backing block device of the file system of the file is used. If the
bandwidth is suffixed with K, M, G, or T, the specified bandwidth is
parsed as Kilobytes, Megabytes, Gigabytes, or Terabytes, respectively,
to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 5M"). This controls the
"io.max" control group attributes. Use this option multiple times to set
bandwidth limits for multiple devices. For details about this control
group attribute, see <strong>IO Interface Files</strong>[7].</p>
<p>Similar restrictions on block device discovery as for
<em>IODeviceWeight=</em> apply, see above.</p>
</blockquote>
<p><em>IOReadIOPSMax=device</em> <em></em> <em>IOPS</em>,
<em>IOWriteIOPSMax=device</em> <em></em> <em>IOPS</em></p>
<blockquote>
<p>These settings control the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Set the per-device overall block I/O IOs-Per-Second maximum limit for
the executed processes, if the unified control group hierarchy is used
on the system. This limit is not work-conserving and the executed
processes are not allowed to use more even if the device has idle
capacity. Takes a space-separated pair of a file path and an IOPS value
to specify the device specific IOPS. The file path may be a path to a
block device node, or as any other file in which case the backing block
device of the file system of the file is used. If the IOPS is suffixed
with K, M, G, or T, the specified IOPS is parsed as KiloIOPS, MegaIOPS,
GigaIOPS, or TeraIOPS, respectively, to the base of 1000. (Example:
"/dev/disk/by-path/pci-0000:00:1f.2-scsi-0:0:0:0 1K"). This controls the
"io.max" control group attributes. Use this option multiple times to set
IOPS limits for multiple devices. For details about this control group
attribute, see <strong>IO Interface Files</strong>[7].</p>
<p>Similar restrictions on block device discovery as for
<em>IODeviceWeight=</em> apply, see above.</p>
</blockquote>
<p><em>IODeviceLatencyTargetSec=device</em> <em></em>
<em>target</em></p>
<blockquote>
<p>This setting controls the <strong>io</strong> controller in the
unified hierarchy.</p>
<p>Set the per-device average target I/O latency for the executed
processes, if the unified control group hierarchy is used on the system.
Takes a file path and a timespan separated by a space to specify the
device specific latency target. (Example: "/dev/sda 25ms"). The file
path may be specified as path to a block device node or as any other
file, in which case the backing block device of the file system of the
file is determined. This controls the "io.latency" control group
attribute. Use this option multiple times to set latency target for
multiple devices. For details about this control group attribute, see
<strong>IO Interface Files</strong>[7].</p>
<p>Implies "IOAccounting=yes".</p>
<p>These settings are supported only if the unified control group
hierarchy is used.</p>
<p>Similar restrictions on block device discovery as for
<em>IODeviceWeight=</em> apply, see above.</p>
</blockquote>
<p><em>IPAccounting=</em></p>
<blockquote>
<p>Takes a boolean argument. If true, turns on IPv4 and IPv6 network
traffic accounting for packets sent or received by the unit. When this
option is turned on, all IPv4 and IPv6 sockets created by any process of
the unit are accounted for.</p>
<p>When this option is used in socket units, it applies to all IPv4 and
IPv6 sockets associated with it (including both listening and connection
sockets where this applies). Note that for socket-activated services,
this configuration setting and the accounting data of the service unit
and the socket unit are kept separate, and displayed separately. No
propagation of the setting and the collected statistics is done, in
either direction. Moreover, any traffic sent or received on any of the
socket units sockets is accounted to the socket unit — and never to the
service unit it might have activated, even if the socket is used by
it.</p>
<p>The system default for this setting may be controlled with
<em>DefaultIPAccounting=</em> in
<strong>systemd-system.conf</strong>(5).</p>
</blockquote>
<p><em>IPAddressAllow=ADDRESS[/PREFIXLENGTH]...</em>,
<em>IPAddressDeny=ADDRESS[/PREFIXLENGTH]...</em></p>
<blockquote>
<p>Turn on network traffic filtering for IP packets sent and received
over <strong>AF_INET</strong> and <strong>AF_INET6</strong> sockets.
Both directives take a space separated list of IPv4 or IPv6 addresses,
each optionally suffixed with an address prefix length in bits after a
"/" character. If the suffix is omitted, the address is considered a
host address, i.e. the filter covers the whole address (32 bits for
IPv4, 128 bits for IPv6).</p>
<p>The access lists configured with this option are applied to all
sockets created by processes of this unit (or in the case of socket
units, associated with it). The lists are implicitly combined with any
lists configured for any of the parent slice units this unit might be a
member of. By default both access lists are empty. Both ingress and
egress traffic is filtered by these settings. In case of ingress traffic
the source IP address is checked against these access lists, in case of
egress traffic the destination IP address is checked. The following
rules are applied in turn:</p>
<blockquote>
<p>·</p>
<p>Access is granted when the checked IP address matches an entry in the
<em>IPAddressAllow=</em> list.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>Otherwise, access is denied when the checked IP address matches an
entry in the <em>IPAddressDeny=</em> list.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>Otherwise, access is granted.</p>
</blockquote>
<p>In order to implement an allow-listing IP firewall, it is recommended
to use a <em>IPAddressDeny=</em><strong>any</strong> setting on an
upper-level slice unit (such as the root slice -.slice or the slice
containing all system services system.slice – see
<strong>systemd.special</strong>(7) for details on these slice units),
plus individual per-service <em>IPAddressAllow=</em> lines permitting
network access to relevant services, and only them.</p>
<p>Note that for socket-activated services, the IP access list
configured on the socket unit applies to all sockets associated with it
directly, but not to any sockets created by the ultimately activated
services for it. Conversely, the IP access list configured for the
service is not applied to any sockets passed into the service via socket
activation. Thus, it is usually a good idea to replicate the IP access
lists on both the socket and the service unit. Nevertheless, it may make
sense to maintain one list more open and the other one more restricted,
depending on the usecase.</p>
<p>If these settings are used multiple times in the same unit the
specified lists are combined. If an empty string is assigned to these
settings the specific access list is reset and all previous settings
undone.</p>
<p>In place of explicit IPv4 or IPv6 address and prefix length
specifications a small set of symbolic names may be used. The following
names are defined:</p>
<p><br />
<strong>Table 1. Special address/network names</strong></p>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Symbolic Name</td>
<td style="text-align: left;">Definition</td>
<td style="text-align: left;">Meaning</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>any</strong></td>
<td style="text-align: left;">0.0.0.0/0 ::/0</td>
<td style="text-align: left;">Any host</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>localhost</strong></td>
<td style="text-align: left;">127.0.0.0/8 ::1/128</td>
<td style="text-align: left;">All addresses on the local loopback</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>link-local</strong></td>
<td style="text-align: left;">169.254.0.0/16 fe80::/64</td>
<td style="text-align: left;">All link-local IP addresses</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>multicast</strong></td>
<td style="text-align: left;">224.0.0.0/4 ff00::/8</td>
<td style="text-align: left;">All IP multicasting addresses</td>
</tr>
</tbody>
</table>
<p>Note that these settings might not be supported on some systems (for
example if eBPF control group support is not enabled in the underlying
kernel or container manager). These settings will have no effect in that
case. If compatibility with such systems is desired it is hence
recommended to not exclusively rely on them for IP security.</p>
</blockquote>
<p><em>IPIngressFilterPath=BPF_FS_PROGRAM_PATH</em>,
<em>IPEgressFilterPath=BPF_FS_PROGRAM_PATH</em></p>
<blockquote>
<p>Add custom network traffic filters implemented as BPF programs,
applying to all IP packets sent and received over
<strong>AF_INET</strong> and <strong>AF_INET6</strong> sockets. Takes an
absolute path to a pinned BPF program in the BPF virtual filesystem
(/sys/fs/bpf/).</p>
<p>The filters configured with this option are applied to all sockets
created by processes of this unit (or in the case of socket units,
associated with it). The filters are loaded in addition to filters any
of the parent slice units this unit might be a member of as well as any
<em>IPAddressAllow=</em> and <em>IPAddressDeny=</em> filters in any of
these units. By default there are no filters specified.</p>
<p>If these settings are used multiple times in the same unit all the
specified programs are attached. If an empty string is assigned to these
settings the program list is reset and all previous specified programs
ignored.</p>
<p>If the path <em>BPF_FS_PROGRAM_PATH</em> in
<em>IPIngressFilterPath=</em> assignment is already being handled by
<em>BPFProgram=</em> ingress hook, e.g.
<em>BPFProgram=</em><strong>ingress</strong>:<em>BPF_FS_PROGRAM_PATH</em>,
the assignment will be still considered valid and the program will be
attached to a cgroup. Same for <em>IPEgressFilterPath=</em> path and
<strong>egress</strong> hook.</p>
<p>Note that for socket-activated services, the IP filter programs
configured on the socket unit apply to all sockets associated with it
directly, but not to any sockets created by the ultimately activated
services for it. Conversely, the IP filter programs configured for the
service are not applied to any sockets passed into the service via
socket activation. Thus, it is usually a good idea, to replicate the IP
filter programs on both the socket and the service unit, however it
often makes sense to maintain one configuration more open and the other
one more restricted, depending on the usecase.</p>
<p>Note that these settings might not be supported on some systems (for
example if eBPF control group support is not enabled in the underlying
kernel or container manager). These settings will fail the service in
that case. If compatibility with such systems is desired it is hence
recommended to attach your filter manually (requires
<em>Delegate=</em><strong>yes</strong>) instead of using this
setting.</p>
</blockquote>
<p><em>BPFProgram=type</em><strong>:</strong><em>program-path</em></p>
<blockquote>
<p>Add a custom cgroup BPF program.</p>
<p><em>BPFProgram=</em> allows attaching BPF hooks to the cgroup of a
systemd unit. (This generalizes the functionality exposed via
<em>IPEgressFilterPath=</em> for egress and
<em>IPIngressFilterPath=</em> for ingress.) Cgroup-bpf hooks in the form
of BPF programs loaded to the BPF filesystem are attached with
cgroup-bpf attach flags determined by the unit. For details about
attachment types and flags see
<strong>https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/plain/include/uapi/linux/bpf.h</strong>.
For general BPF documentation please refer to
<strong>https://docs.kernel.org/bpf/index.html</strong>.</p>
<p>The specification of BPF program consists of a <em>type</em> followed
by a <em>program-path</em> with ":" as the separator:
<em>type</em><strong>:</strong><em>program-path</em>.</p>
<p><em>type</em> is the string name of BPF attach type also used in
<strong>bpftool</strong>. <em>type</em> can be one of
<strong>egress</strong>, <strong>ingress</strong>,
<strong>sock_create</strong>, <strong>sock_ops</strong>,
<strong>device</strong>, <strong>bind4</strong>, <strong>bind6</strong>,
<strong>connect4</strong>, <strong>connect6</strong>,
<strong>post_bind4</strong>, <strong>post_bind6</strong>,
<strong>sendmsg4</strong>, <strong>sendmsg6</strong>,
<strong>sysctl</strong>, <strong>recvmsg4</strong>,
<strong>recvmsg6</strong>, <strong>getsockopt</strong>,
<strong>setsockopt</strong>.</p>
<p>Setting <em>BPFProgram=</em> to an empty value makes previous
assignments ineffective.</p>
<p>Multiple assignments of the same <em>type</em>:<em>program-path</em>
value have the same effect as a single assignment: the program with the
path <em>program-path</em> will be attached to cgroup hook <em>type</em>
just once.</p>
<p>If BPF <strong>egress</strong> pinned to <em>program-path</em> path
is already being handled by <em>IPEgressFilterPath=</em>,
<em>BPFProgram=</em> assignment will be considered valid and
<em>BPFProgram=</em> will be attached to a cgroup. Similarly for
<strong>ingress</strong> hook and <em>IPIngressFilterPath=</em>
assignment.</p>
<p>BPF programs passed with <em>BPFProgram=</em> are attached to the
cgroup of a unit with BPF attach flag <strong>multi</strong>, that
allows further attachments of the same <em>type</em> within cgroup
hierarchy topped by the unit cgroup.</p>
<p>Examples:</p>
<blockquote>
<pre><code>BPFProgram=egress:/sys/fs/bpf/egress-hook
BPFProgram=bind6:/sys/fs/bpf/sock-addr-hook</code></pre>
</blockquote>
</blockquote>
<p><em>SocketBindAllow=bind-rule</em>,
<em>SocketBindDeny=bind-rule</em></p>
<blockquote>
<p>Allow or deny binding a socket address to a socket by matching it
with the <em>bind-rule</em> and applying a corresponding action if there
is a match.</p>
<p><em>bind-rule</em> describes socket properties such as
<em>address-family</em>, <em>transport-protocol</em> and
<em>ip-ports</em>.</p>
<p><em>bind-rule</em> := {
[<em>address-family</em><strong>:</strong>][<em>transport-protocol</em><strong>:</strong>][<em>ip-ports</em>]
| <strong>any</strong> }</p>
<p><em>address-family</em> := { <strong>ipv4</strong> |
<strong>ipv6</strong> }</p>
<p><em>transport-protocol</em> := { <strong>tcp</strong> |
<strong>udp</strong> }</p>
<p><em>ip-ports</em> := { <em>ip-port</em> | <em>ip-port-range</em>
}</p>
<p>An optional <em>address-family</em> expects <strong>ipv4</strong> or
<strong>ipv6</strong> values. If not specified, a rule will be matched
for both IPv4 and IPv6 addresses and applied depending on other socket
fields, e.g. <em>transport-protocol</em>, <em>ip-port</em>.</p>
<p>An optional <em>transport-protocol</em> expects <strong>tcp</strong>
or <strong>udp</strong> transport protocol names. If not specified, a
rule will be matched for any transport protocol.</p>
<p>An optional <em>ip-port</em> value must lie within 1...65535 interval
inclusively, i.e. dynamic port <strong>0</strong> is not allowed. A
range of sequential ports is described by <em>ip-port-range</em> :=
<em>ip-port-low</em><strong>-</strong><em>ip-port-high</em>, where
<em>ip-port-low</em> is smaller than or equal to <em>ip-port-high</em>
and both are within 1...65535 inclusively.</p>
<p>A special value <strong>any</strong> can be used to apply a rule to
any address family, transport protocol and any port with a positive
value.</p>
<p>To allow multiple rules assign <em>SocketBindAllow=</em> or
<em>SocketBindDeny=</em> multiple times. To clear the existing
assignments pass an empty <em>SocketBindAllow=</em> or
<em>SocketBindDeny=</em> assignment.</p>
<p>For each of <em>SocketBindAllow=</em> and <em>SocketBindDeny=</em>,
maximum allowed number of assignments is <strong>128</strong>.</p>
<blockquote>
<p>·</p>
<p>Binding to a socket is allowed when a socket address matches an entry
in the <em>SocketBindAllow=</em> list.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>Otherwise, binding is denied when the socket address matches an entry
in the <em>SocketBindDeny=</em> list.</p>
</blockquote>
<blockquote>
<p>·</p>
<p>Otherwise, binding is allowed.</p>
</blockquote>
<p>The feature is implemented with <strong>cgroup/bind4</strong> and
<strong>cgroup/bind6</strong> cgroup-bpf hooks.</p>
<p>Examples:</p>
<blockquote>
<pre><code>...
# Allow binding IPv6 socket addresses with a port greater than or equal to 10000.
[Service]
SocketBindAllow=ipv6:10000-65535
SocketBindDeny=any
...
# Allow binding IPv4 and IPv6 socket addresses with 1234 and 4321 ports.
[Service]
SocketBindAllow=1234
SocketBindAllow=4321
SocketBindDeny=any
...
# Deny binding IPv6 socket addresses.
[Service]
SocketBindDeny=ipv6
...
# Deny binding IPv4 and IPv6 socket addresses.
[Service]
SocketBindDeny=any
...
# Allow binding only over TCP
[Service]
SocketBindAllow=tcp
SocketBindDeny=any
...
# Allow binding only over IPv6/TCP
[Service]
SocketBindAllow=ipv6:tcp
SocketBindDeny=any
...
# Allow binding ports within 10000-65535 range over IPv4/UDP.
[Service]
SocketBindAllow=ipv4:udp:10000-65535
SocketBindDeny=any
...</code></pre>
</blockquote>
</blockquote>
<p><em>RestrictNetworkInterfaces=</em></p>
<blockquote>
<p>Takes a list of space-separated network interface names. This option
restricts the network interfaces that processes of this unit can use. By
default processes can only use the network interfaces listed
(allow-list). If the first character of the rule is "~", the effect is
inverted: the processes can only use network interfaces not listed
(deny-list).</p>
<p>This option can appear multiple times, in which case the network
interface names are merged. If the empty string is assigned the set is
reset, all prior assignments will have not effect.</p>
<p>If you specify both types of this option (i.e. allow-listing and
deny-listing), the first encountered will take precedence and will
dictate the default action (allow vs deny). Then the next occurrences of
this option will add or delete the listed network interface names from
the set, depending of its type and the default action.</p>
<p>The loopback interface ("lo") is not treated in any special way, you
have to configure it explicitly in the unit file.</p>
<p>Example 1: allow-list</p>
<blockquote>
<pre><code>RestrictNetworkInterfaces=eth1
RestrictNetworkInterfaces=eth2</code></pre>
</blockquote>
<p>Programs in the unit will be only able to use the eth1 and eth2
network interfaces.</p>
<p>Example 2: deny-list</p>
<blockquote>
<pre><code>RestrictNetworkInterfaces=~eth1 eth2</code></pre>
</blockquote>
<p>Programs in the unit will be able to use any network interface but
eth1 and eth2.</p>
<p>Example 3: mixed</p>
<blockquote>
<pre><code>RestrictNetworkInterfaces=eth1 eth2
RestrictNetworkInterfaces=~eth1</code></pre>
</blockquote>
<p>Programs in the unit will be only able to use the eth2 network
interface.</p>
</blockquote>
<p><em>DeviceAllow=</em></p>
<blockquote>
<p>Control access to specific device nodes by the executed processes.
Takes two space-separated strings: a device node specifier followed by a
combination of <strong>r</strong>, <strong>w</strong>,
<strong>m</strong> to control <em>r</em>eading, <em>w</em>riting, or
creation of the specific device nodes by the unit (<em>m</em>knod),
respectively. This functionality is implemented using eBPF
filtering.</p>
<p>When access to <em>all</em> physical devices should be disallowed,
<em>PrivateDevices=</em> may be used instead. See
<strong>systemd.exec</strong>(5).</p>
<p>The device node specifier is either a path to a device node in the
file system, starting with /dev/, or a string starting with either
"char-" or "block-" followed by a device group name, as listed in
/proc/devices. The latter is useful to allow-list all current and future
devices belonging to a specific device group at once. The device group
is matched according to filename globbing rules, you may hence use the
"*" and "?" wildcards. (Note that such globbing wildcards are not
available for device node path specifications!) In order to match device
nodes by numeric major/minor, use device node paths in the /dev/char/
and /dev/block/ directories. However, matching devices by major/minor is
generally not recommended as assignments are neither stable nor portable
between systems or different kernel versions.</p>
<p>Examples: /dev/sda5 is a path to a device node, referring to an ATA
or SCSI block device. "char-pts" and "char-alsa" are specifiers for all
pseudo TTYs and all ALSA sound devices, respectively. "char-cpu/*" is a
specifier matching all CPU related device groups.</p>
<p>Note that allow lists defined this way should only reference device
groups which are resolvable at the time the unit is started. Any device
groups not resolvable then are not added to the device allow list. In
order to work around this limitation, consider extending service units
with a pair of <strong>After=modprobe@xyz.service</strong> and
<strong>Wants=modprobe@xyz.service</strong> lines that load the
necessary kernel module implementing the device group if missing.
Example:</p>
<blockquote>
<pre><code>...
[Unit]
Wants=modprobe@loop.service
After=modprobe@loop.service

[Service]
DeviceAllow=block-loop
DeviceAllow=/dev/loop-control
...</code></pre>
</blockquote>
</blockquote>
<p><em>DevicePolicy=auto|closed|strict</em></p>
<blockquote>
<p>Control the policy for allowing device access:</p>
<p><strong>strict</strong></p>
<blockquote>
<p>means to only allow types of access that are explicitly
specified.</p>
</blockquote>
<p><strong>closed</strong></p>
<blockquote>
<p>in addition, allows access to standard pseudo devices including
/dev/null, /dev/zero, /dev/full, /dev/random, and /dev/urandom.</p>
</blockquote>
<p><strong>auto</strong></p>
<blockquote>
<p>in addition, allows access to all devices if no explicit
<em>DeviceAllow=</em> is present. This is the default.</p>
</blockquote>
</blockquote>
<p><em>Slice=</em></p>
<blockquote>
<p>The name of the slice unit to place the unit in. Defaults to
system.slice for all non-instantiated units of all unit types (except
for slice units themselves see below). Instance units are by default
placed in a subslice of system.slice that is named after the template
name.</p>
<p>This option may be used to arrange systemd units in a hierarchy of
slices each of which might have resource settings applied.</p>
<p>For units of type slice, the only accepted value for this setting is
the parent slice. Since the name of a slice unit implies the parent
slice, it is hence redundant to ever set this parameter directly for
slice units.</p>
<p>Special care should be taken when relying on the default slice
assignment in templated service units that have
<em>DefaultDependencies=no</em> set, see
<strong>systemd.service</strong>(5), section "Default Dependencies" for
details.</p>
</blockquote>
<p><em>Delegate=</em></p>
<blockquote>
<p>Turns on delegation of further resource control partitioning to
processes of the unit. Units where this is enabled may create and manage
their own private subhierarchy of control groups below the control group
of the unit itself. For unprivileged services (i.e. those using the
<em>User=</em> setting) the units control group will be made accessible
to the relevant user.</p>
<p>When enabled the service manager will refrain from manipulating
control groups or moving processes below the units control group, so
that a clear concept of ownership is established: the control group tree
at the level of the units control group and above (i.e. towards the root
control group) is owned and managed by the service manager of the host,
while the control group tree below the units control group is owned and
managed by the unit itself.</p>
<p>Takes either a boolean argument or a (possibly empty) list of control
group controller names. If true, delegation is turned on, and all
supported controllers are enabled for the unit, making them available to
the units processes for management. If false, delegation is turned off
entirely (and no additional controllers are enabled). If set to a list
of controllers, delegation is turned on, and the specified controllers
are enabled for the unit. Assigning the empty string will enable
delegation, but reset the list of controllers, and all assignments prior
to this will have no effect. Note that additional controllers other than
the ones specified might be made available as well, depending on
configuration of the containing slice unit or other units contained in
it. Defaults to false.</p>
<p>Note that controller delegation to less privileged code is only safe
on the unified control group hierarchy. Accordingly, access to the
specified controllers will not be granted to unprivileged services on
the legacy hierarchy, even when requested.</p>
<p>The following controller names may be specified:
<strong>cpu</strong>, <strong>cpuacct</strong>, <strong>cpuset</strong>,
<strong>io</strong>, <strong>blkio</strong>, <strong>memory</strong>,
<strong>devices</strong>, <strong>pids</strong>,
<strong>bpf-firewall</strong>, and <strong>bpf-devices</strong>.</p>
<p>Not all of these controllers are available on all kernels however,
and some are specific to the unified hierarchy while others are specific
to the legacy hierarchy. Also note that the kernel might support further
controllers, which arent covered here yet as delegation is either not
supported at all for them or not defined cleanly.</p>
<p>Note that because of the hierarchical nature of cgroup hierarchy, any
controllers that are delegated will be enabled for the parent and
sibling units of the unit with delegation.</p>
<p>For further details on the delegation model consult <strong>Control
Group APIs and Delegation</strong>[8].</p>
</blockquote>
<p><em>DisableControllers=</em></p>
<blockquote>
<p>Disables controllers from being enabled for a units children. If a
controller listed is already in use in its subtree, the controller will
be removed from the subtree. This can be used to avoid configuration in
child units from being able to implicitly or explicitly enable a
controller. Defaults to empty.</p>
<p>Multiple controllers may be specified, separated by spaces. You may
also pass <em>DisableControllers=</em> multiple times, in which case
each new instance adds another controller to disable. Passing
<em>DisableControllers=</em> by itself with no controller name present
resets the disabled controller list.</p>
<p>It may not be possible to disable a controller after units have been
started, if the unit or any child of the unit in question delegates
controllers to its children, as any delegated subtree of the cgroup
hierarchy is unmanaged by systemd.</p>
<p>The following controller names may be specified:
<strong>cpu</strong>, <strong>cpuacct</strong>, <strong>cpuset</strong>,
<strong>io</strong>, <strong>blkio</strong>, <strong>memory</strong>,
<strong>devices</strong>, <strong>pids</strong>,
<strong>bpf-firewall</strong>, and <strong>bpf-devices</strong>.</p>
</blockquote>
<p><em>ManagedOOMSwap=auto|kill</em>,
<em>ManagedOOMMemoryPressure=auto|kill</em></p>
<blockquote>
<p>Specifies how <strong>systemd-oomd.service</strong>(8) will act on
this units cgroups. Defaults to <strong>auto</strong>.</p>
<p>When set to <strong>kill</strong>, the unit becomes a candidate for
monitoring by <strong>systemd-oomd</strong>. If the cgroup passes the
limits set by <strong>oomd.conf</strong>(5) or the unit configuration,
<strong>systemd-oomd</strong> will select a descendant cgroup and send
<strong>SIGKILL</strong> to all of the processes under it. You can find
more details on candidates and kill behavior at
<strong>systemd-oomd.service</strong>(8) and
<strong>oomd.conf</strong>(5).</p>
<p>Setting either of these properties to <strong>kill</strong> will also
result in <em>After=</em> and <em>Wants=</em> dependencies on
systemd-oomd.service unless <em>DefaultDependencies=no</em>.</p>
<p>When set to <strong>auto</strong>, <strong>systemd-oomd</strong> will
not actively use this cgroups data for monitoring and detection.
However, if an ancestor cgroup has one of these properties set to
<strong>kill</strong>, a unit with <strong>auto</strong> can still be a
candidate for <strong>systemd-oomd</strong> to terminate.</p>
</blockquote>
<p><em>ManagedOOMMemoryPressureLimit=</em></p>
<blockquote>
<p>Overrides the default memory pressure limit set by
<strong>oomd.conf</strong>(5) for this unit (cgroup). Takes a percentage
value between 0% and 100%, inclusive. This property is ignored unless
<em>ManagedOOMMemoryPressure=</em><strong>kill</strong>. Defaults to 0%,
which means to use the default set by <strong>oomd.conf</strong>(5).</p>
</blockquote>
<p><em>ManagedOOMPreference=none|avoid|omit</em></p>
<blockquote>
<p>Allows deprioritizing or omitting this units cgroup as a candidate
when <strong>systemd-oomd</strong> needs to act. Requires support for
extended attributes (see <strong>xattr</strong>(7)) in order to use
<strong>avoid</strong> or <strong>omit</strong>.</p>
<p>When calculating candidates to relieve swap usage,
<strong>systemd-oomd</strong> will only respect these extended
attributes if the units cgroup is owned by root.</p>
<p>When calculating candidates to relieve memory pressure,
<strong>systemd-oomd</strong> will only respect these extended
attributes if the units cgroup owner, and the owner of the monitored
ancestor cgroup are the same. For example, if
<strong>systemd-oomd</strong> is calculating candidates for -.slice,
then extended attributes set on descendants of
/user.slice/user-1000.slice/user@1000.service/ will be ignored because
the descendants are owned by UID 1000, and -.slice is owned by UID 0.
But, if calculating candidates for
/user.slice/user-1000.slice/user@1000.service/, then extended attributes
set on the descendants would be respected.</p>
<p>If this property is set to <strong>avoid</strong>, the service
manager will convey this to <strong>systemd-oomd</strong>, which will
only select this cgroup if there are no other viable candidates.</p>
<p>If this property is set to <strong>omit</strong>, the service manager
will convey this to <strong>systemd-oomd</strong>, which will ignore
this cgroup as a candidate and will not perform any actions on it.</p>
<p>It is recommended to use <strong>avoid</strong> and
<strong>omit</strong> sparingly, as it can adversely affect
<strong>systemd-oomd</strong>s kill behavior. Also note that these
extended attributes are not applied recursively to cgroups under this
units cgroup.</p>
<p>Defaults to <strong>none</strong> which means
<strong>systemd-oomd</strong> will rank this units cgroup as defined in
<strong>systemd-oomd.service</strong>(8) and
<strong>oomd.conf</strong>(5).</p>
</blockquote>
<h1>HISTORY</h1>
<p>systemd 252</p>
<blockquote>
<p>Options for controlling the Legacy Control Group Hierarchy
(<strong>Control Groups version 1</strong>[9] are now fully deprecated:
<em>CPUShares=weight</em>, <em>StartupCPUShares=weight</em>,
<em>MemoryLimit=bytes</em>, <em>BlockIOAccounting=</em>,
<em>BlockIOWeight=weight</em>, <em>StartupBlockIOWeight=weight</em>,
<em>BlockIODeviceWeight=device</em> <em></em> <em>weight</em>,
<em>BlockIOReadBandwidth=device</em> <em></em> <em>bytes</em>,
<em>BlockIOWriteBandwidth=device</em> <em></em> <em>bytes</em>. Please
switch to the unified cgroup hierarchy.</p>
</blockquote>
<h1>SEE ALSO</h1>
<p><strong>systemd</strong>(1), <strong>systemd-system.conf</strong>(5),
<strong>systemd.unit</strong>(5), <strong>systemd.service</strong>(5),
<strong>systemd.slice</strong>(5), <strong>systemd.scope</strong>(5),
<strong>systemd.socket</strong>(5), <strong>systemd.mount</strong>(5),
<strong>systemd.swap</strong>(5), <strong>systemd.exec</strong>(5),
<strong>systemd.directives</strong>(7),
<strong>systemd.special</strong>(7),
<strong>systemd-oomd.service</strong>(8), The documentation for control
groups and specific controllers in the Linux kernel: <strong>Control
Groups v2</strong>[2].</p>
<h1>NOTES</h1>
<dl>
<dt> 1.</dt>
<dd>
<p>New Control Group Interfaces</p>
<p>https://www.freedesktop.org/wiki/Software/systemd/ControlGroupInterface</p>
</dd>
<dt> 2.</dt>
<dd>
<p>Control Groups v2</p>
<p>https://docs.kernel.org/admin-guide/cgroup-v2.html</p>
</dd>
<dt> 3.</dt>
<dd>
<p>CFS Scheduler</p>
<p>https://docs.kernel.org/scheduler/sched-design-CFS.html</p>
</dd>
<dt> 4.</dt>
<dd>
<p>CFS Bandwidth Control</p>
<p>https://docs.kernel.org/scheduler/sched-bwc.html</p>
</dd>
<dt> 5.</dt>
<dd>
<p>Memory Interface Files</p>
<p>https://docs.kernel.org/admin-guide/cgroup-v2.html#memory-interface-files</p>
</dd>
<dt> 6.</dt>
<dd>
<p>pids controller</p>
<p>https://www.kernel.org/doc/html/latest/admin-guide/cgroup-v2.html#pid</p>
</dd>
<dt> 7.</dt>
<dd>
<p>IO Interface Files</p>
<p>https://docs.kernel.org/admin-guide/cgroup-v2.html#io-interface-files</p>
</dd>
<dt> 8.</dt>
<dd>
<p>Control Group APIs and Delegation</p>
<p>https://systemd.io/CGROUP_DELEGATION</p>
</dd>
<dt> 9.</dt>
<dd>
<p>Control Groups version 1</p>
<p>https://docs.kernel.org/admin-guide/cgroup-v1/index.html</p>
</dd>
</dl>
