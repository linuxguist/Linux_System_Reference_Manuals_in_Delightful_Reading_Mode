<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>xz, unxz, xzcat, lzma, unlzma, lzcat - Compress or decompress .xz and
.lzma files</p>
<h1>SYNOPSIS</h1>
<p><strong>xz</strong> [<em>option...</em>] [<em>file...</em>]</p>
<h1>COMMAND ALIASES</h1>
<p><strong>unxz</strong> is equivalent to <strong>xz
--decompress</strong>.<br />
<strong>xzcat</strong> is equivalent to <strong>xz --decompress
--stdout</strong>.<br />
<strong>lzma</strong> is equivalent to <strong>xz
--format=lzma</strong>.<br />
<strong>unlzma</strong> is equivalent to <strong>xz --format=lzma
--decompress</strong>.<br />
<strong>lzcat</strong> is equivalent to <strong>xz --format=lzma
--decompress --stdout</strong>.</p>
<p>When writing scripts that need to decompress files, it is recommended
to always use the name <strong>xz</strong> with appropriate arguments
(<strong>xz -d</strong> or <strong>xz -dc</strong>) instead of the names
<strong>unxz</strong> and <strong>xzcat</strong>.</p>
<h1>DESCRIPTION</h1>
<p><strong>xz</strong> is a general-purpose data compression tool with
command line syntax similar to <strong>gzip</strong>(1) and
<strong>bzip2</strong>(1). The native file format is the
<strong>.xz</strong> format, but the legacy <strong>.lzma</strong>
format used by LZMA Utils and raw compressed streams with no container
format headers are also supported. In addition, decompression of the
<strong>.lz</strong> format used by <strong>lzip</strong> is
supported.</p>
<p><strong>xz</strong> compresses or decompresses each <em>file</em>
according to the selected operation mode. If no <em>files</em> are given
or <em>file</em> is <strong>-</strong>, <strong>xz</strong> reads from
standard input and writes the processed data to standard output.
<strong>xz</strong> will refuse (display an error and skip the
<em>file</em>) to write compressed data to standard output if it is a
terminal. Similarly, <strong>xz</strong> will refuse to read compressed
data from standard input if it is a terminal.</p>
<p>Unless <strong>--stdout</strong> is specified, <em>files</em> other
than <strong>-</strong> are written to a new file whose name is derived
from the source <em>file</em> name:</p>
<ul>
<li><p>When compressing, the suffix of the target file format
(<strong>.xz</strong> or <strong>.lzma</strong>) is appended to the
source filename to get the target filename.</p></li>
<li><p>When decompressing, the <strong>.xz</strong>,
<strong>.lzma</strong>, or <strong>.lz</strong> suffix is removed from
the filename to get the target filename. <strong>xz</strong> also
recognizes the suffixes <strong>.txz</strong> and <strong>.tlz</strong>,
and replaces them with the <strong>.tar</strong> suffix.</p></li>
</ul>
<p>If the target file already exists, an error is displayed and the
<em>file</em> is skipped.</p>
<p>Unless writing to standard output, <strong>xz</strong> will display a
warning and skip the <em>file</em> if any of the following applies:</p>
<ul>
<li><p><em>File</em> is not a regular file. Symbolic links are not
followed, and thus they are not considered to be regular files.</p></li>
<li><p><em>File</em> has more than one hard link.</p></li>
<li><p><em>File</em> has setuid, setgid, or sticky bit set.</p></li>
<li><p>The operation mode is set to compress and the <em>file</em>
already has a suffix of the target file format (<strong>.xz</strong> or
<strong>.txz</strong> when compressing to the <strong>.xz</strong>
format, and <strong>.lzma</strong> or <strong>.tlz</strong> when
compressing to the <strong>.lzma</strong> format).</p></li>
<li><p>The operation mode is set to decompress and the <em>file</em>
doesn't have a suffix of any of the supported file formats
(<strong>.xz</strong>, <strong>.txz</strong>, <strong>.lzma</strong>,
<strong>.tlz</strong>, or <strong>.lz</strong>).</p></li>
</ul>
<p>After successfully compressing or decompressing the <em>file</em>,
<strong>xz</strong> copies the owner, group, permissions, access time,
and modification time from the source <em>file</em> to the target file.
If copying the group fails, the permissions are modified so that the
target file doesn't become accessible to users who didn't have
permission to access the source <em>file</em>. <strong>xz</strong>
doesn't support copying other metadata like access control lists or
extended attributes yet.</p>
<p>Once the target file has been successfully closed, the source
<em>file</em> is removed unless <strong>--keep</strong> was specified.
The source <em>file</em> is never removed if the output is written to
standard output or if an error occurs.</p>
<p>Sending <strong>SIGINFO</strong> or <strong>SIGUSR1</strong> to the
<strong>xz</strong> process makes it print progress information to
standard error. This has only limited use since when standard error is a
terminal, using <strong>--verbose</strong> will display an automatically
updating progress indicator.</p>
<h2>Memory usage</h2>
<p>The memory usage of <strong>xz</strong> varies from a few hundred
kilobytes to several gigabytes depending on the compression settings.
The settings used when compressing a file determine the memory
requirements of the decompressor. Typically the decompressor needs 5 %
to 20 % of the amount of memory that the compressor needed when creating
the file. For example, decompressing a file created with <strong>xz
-9</strong> currently requires 65 MiB of memory. Still, it is possible
to have <strong>.xz</strong> files that require several gigabytes of
memory to decompress.</p>
<p>Especially users of older systems may find the possibility of very
large memory usage annoying. To prevent uncomfortable surprises,
<strong>xz</strong> has a built-in memory usage limiter, which is
disabled by default. While some operating systems provide ways to limit
the memory usage of processes, relying on it wasn't deemed to be
flexible enough (for example, using <strong>ulimit</strong>(1) to limit
virtual memory tends to cripple <strong>mmap</strong>(2)).</p>
<p>The memory usage limiter can be enabled with the command line option
<strong>--memlimit=</strong><em>limit</em>. Often it is more convenient
to enable the limiter by default by setting the environment variable
<strong>XZ_DEFAULTS</strong>, for example,
<strong>XZ_DEFAULTS=--memlimit=150MiB</strong>. It is possible to set
the limits separately for compression and decompression by using
<strong>--memlimit-compress=</strong><em>limit</em> and
<strong>--memlimit-decompress=</strong><em>limit</em>. Using these two
options outside <strong>XZ_DEFAULTS</strong> is rarely useful because a
single run of <strong>xz</strong> cannot do both compression and
decompression and <strong>--memlimit=</strong><em>limit</em> (or
<strong>-M</strong> <em>limit</em>) is shorter to type on the command
line.</p>
<p>If the specified memory usage limit is exceeded when decompressing,
<strong>xz</strong> will display an error and decompressing the file
will fail. If the limit is exceeded when compressing,
<strong>xz</strong> will try to scale the settings down so that the
limit is no longer exceeded (except when using
<strong>--format=raw</strong> or <strong>--no-adjust</strong>). This way
the operation won't fail unless the limit is very small. The scaling of
the settings is done in steps that don't match the compression level
presets, for example, if the limit is only slightly less than the amount
required for <strong>xz -9</strong>, the settings will be scaled down
only a little, not all the way down to <strong>xz -8</strong>.</p>
<h2>Concatenation and padding with .xz files</h2>
<p>It is possible to concatenate <strong>.xz</strong> files as is.
<strong>xz</strong> will decompress such files as if they were a single
<strong>.xz</strong> file.</p>
<p>It is possible to insert padding between the concatenated parts or
after the last part. The padding must consist of null bytes and the size
of the padding must be a multiple of four bytes. This can be useful, for
example, if the <strong>.xz</strong> file is stored on a medium that
measures file sizes in 512-byte blocks.</p>
<p>Concatenation and padding are not allowed with <strong>.lzma</strong>
files or raw streams.</p>
<h1>OPTIONS</h1>
<h2>Integer suffixes and special values</h2>
<p>In most places where an integer argument is expected, an optional
suffix is supported to easily indicate large integers. There must be no
space between the integer and the suffix.</p>
<dl>
<dt><strong>KiB</strong></dt>
<dd>
<p>Multiply the integer by 1,024 (2^10). <strong>Ki</strong>,
<strong>k</strong>, <strong>kB</strong>, <strong>K</strong>, and
<strong>KB</strong> are accepted as synonyms for
<strong>KiB</strong>.</p>
</dd>
<dt><strong>MiB</strong></dt>
<dd>
<p>Multiply the integer by 1,048,576 (2^20). <strong>Mi</strong>,
<strong>m</strong>, <strong>M</strong>, and <strong>MB</strong> are
accepted as synonyms for <strong>MiB</strong>.</p>
</dd>
<dt><strong>GiB</strong></dt>
<dd>
<p>Multiply the integer by 1,073,741,824 (2^30). <strong>Gi</strong>,
<strong>g</strong>, <strong>G</strong>, and <strong>GB</strong> are
accepted as synonyms for <strong>GiB</strong>.</p>
</dd>
</dl>
<p>The special value <strong>max</strong> can be used to indicate the
maximum integer value supported by the option.</p>
<h2>Operation mode</h2>
<p>If multiple operation mode options are given, the last one takes
effect.</p>
<dl>
<dt><strong>-z</strong>, <strong>--compress</strong></dt>
<dd>
<p>Compress. This is the default operation mode when no operation mode
option is specified and no other operation mode is implied from the
command name (for example, <strong>unxz</strong> implies
<strong>--decompress</strong>).</p>
</dd>
<dt><strong>-d</strong>, <strong>--decompress</strong>,
<strong>--uncompress</strong></dt>
<dd>
<p>Decompress.</p>
</dd>
<dt><strong>-t</strong>, <strong>--test</strong></dt>
<dd>
<p>Test the integrity of compressed <em>files</em>. This option is
equivalent to <strong>--decompress --stdout</strong> except that the
decompressed data is discarded instead of being written to standard
output. No files are created or removed.</p>
</dd>
<dt><strong>-l</strong>, <strong>--list</strong></dt>
<dd>
<p>Print information about compressed <em>files</em>. No uncompressed
output is produced, and no files are created or removed. In list mode,
the program cannot read the compressed data from standard input or from
other unseekable sources.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The default listing shows basic information about <em>files</em>, one
file per line. To get more detailed information, use also the
<strong>--verbose</strong> option. For even more information, use
<strong>--verbose</strong> twice, but note that this may be slow,
because getting all the extra information requires many seeks. The width
of verbose output exceeds 80 characters, so piping the output to, for
example, <strong>less -S</strong> may be convenient if the terminal
isn't wide enough.</p>
</dd>
<dt></dt>
<dd>
<p>The exact output may vary between <strong>xz</strong> versions and
different locales. For machine-readable output, <strong>--robot
--list</strong> should be used.</p>
</dd>
</dl>
<h2>Operation modifiers</h2>
<dl>
<dt><strong>-k</strong>, <strong>--keep</strong></dt>
<dd>
<p>Don't delete the input files.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Since <strong>xz</strong> 5.2.6, this option also makes
<strong>xz</strong> compress or decompress even if the input is a
symbolic link to a regular file, has more than one hard link, or has the
setuid, setgid, or sticky bit set. The setuid, setgid, and sticky bits
are not copied to the target file. In earlier versions this was only
done with <strong>--force</strong>.</p>
</dd>
</dl>
<dl>
<dt><strong>-f</strong>, <strong>--force</strong></dt>
<dd>
<p>This option has several effects:</p>
<ul>
<li><p>If the target file already exists, delete it before compressing
or decompressing.</p></li>
<li><p>Compress or decompress even if the input is a symbolic link to a
regular file, has more than one hard link, or has the setuid, setgid, or
sticky bit set. The setuid, setgid, and sticky bits are not copied to
the target file.</p></li>
<li><p>When used with <strong>--decompress</strong>
<strong>--stdout</strong> and <strong>xz</strong> cannot recognize the
type of the source file, copy the source file as is to standard output.
This allows <strong>xzcat</strong> <strong>--force</strong> to be used
like <strong>cat</strong>(1) for files that have not been compressed
with <strong>xz</strong>. Note that in future, <strong>xz</strong> might
support new compressed file formats, which may make <strong>xz</strong>
decompress more types of files instead of copying them as is to standard
output. <strong>--format=</strong><em>format</em> can be used to
restrict <strong>xz</strong> to decompress only a single file
format.</p></li>
</ul>
</dd>
<dt><strong>-c</strong>, <strong>--stdout</strong>,
<strong>--to-stdout</strong></dt>
<dd>
<p>Write the compressed or decompressed data to standard output instead
of a file. This implies <strong>--keep</strong>.</p>
</dd>
<dt><strong>--single-stream</strong></dt>
<dd>
<p>Decompress only the first <strong>.xz</strong> stream, and silently
ignore possible remaining input data following the stream. Normally such
trailing garbage makes <strong>xz</strong> display an error.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p><strong>xz</strong> never decompresses more than one stream from
<strong>.lzma</strong> files or raw streams, but this option still makes
<strong>xz</strong> ignore the possible trailing data after the
<strong>.lzma</strong> file or raw stream.</p>
</dd>
<dt></dt>
<dd>
<p>This option has no effect if the operation mode is not
<strong>--decompress</strong> or <strong>--test</strong>.</p>
</dd>
</dl>
<dl>
<dt><strong>--no-sparse</strong></dt>
<dd>
<p>Disable creation of sparse files. By default, if decompressing into a
regular file, <strong>xz</strong> tries to make the file sparse if the
decompressed data contains long sequences of binary zeros. It also works
when writing to standard output as long as standard output is connected
to a regular file and certain additional conditions are met to make it
safe. Creating sparse files may save disk space and speed up the
decompression by reducing the amount of disk I/O.</p>
</dd>
<dt><strong>-S</strong> <em>.suf</em>,
<strong>--suffix=</strong><em>.suf</em></dt>
<dd>
<p>When compressing, use <em>.suf</em> as the suffix for the target file
instead of <strong>.xz</strong> or <strong>.lzma</strong>. If not
writing to standard output and the source file already has the suffix
<em>.suf</em>, a warning is displayed and the file is skipped.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>When decompressing, recognize files with the suffix <em>.suf</em> in
addition to files with the <strong>.xz</strong>, <strong>.txz</strong>,
<strong>.lzma</strong>, <strong>.tlz</strong>, or <strong>.lz</strong>
suffix. If the source file has the suffix <em>.suf</em>, the suffix is
removed to get the target filename.</p>
</dd>
<dt></dt>
<dd>
<p>When compressing or decompressing raw streams
(<strong>--format=raw</strong>), the suffix must always be specified
unless writing to standard output, because there is no default suffix
for raw streams.</p>
</dd>
</dl>
<dl>
<dt><strong>--files</strong>[<strong>=</strong><em>file</em>]</dt>
<dd>
<p>Read the filenames to process from <em>file</em>; if <em>file</em> is
omitted, filenames are read from standard input. Filenames must be
terminated with the newline character. A dash (<strong>-</strong>) is
taken as a regular filename; it doesn't mean standard input. If
filenames are given also as command line arguments, they are processed
before the filenames read from <em>file</em>.</p>
</dd>
<dt><strong>--files0</strong>[<strong>=</strong><em>file</em>]</dt>
<dd>
<p>This is identical to
<strong>--files</strong>[<strong>=</strong><em>file</em>] except that
each filename must be terminated with the null character.</p>
</dd>
</dl>
<h2>Basic file format and compression options</h2>
<dl>
<dt><strong>-F</strong> <em>format</em>,
<strong>--format=</strong><em>format</em></dt>
<dd>
<p>Specify the file <em>format</em> to compress or decompress:</p>
<dl>
<dt><strong>auto</strong></dt>
<dd>
<p>This is the default. When compressing, <strong>auto</strong> is
equivalent to <strong>xz</strong>. When decompressing, the format of the
input file is automatically detected. Note that raw streams (created
with <strong>--format=raw</strong>) cannot be auto-detected.</p>
</dd>
<dt><strong>xz</strong></dt>
<dd>
<p>Compress to the <strong>.xz</strong> file format, or accept only
<strong>.xz</strong> files when decompressing.</p>
</dd>
<dt><strong>lzma</strong>, <strong>alone</strong></dt>
<dd>
<p>Compress to the legacy <strong>.lzma</strong> file format, or accept
only <strong>.lzma</strong> files when decompressing. The alternative
name <strong>alone</strong> is provided for backwards compatibility with
LZMA Utils.</p>
</dd>
<dt><strong>lzip</strong></dt>
<dd>
<p>Accept only <strong>.lz</strong> files when decompressing.
Compression is not supported.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The <strong>.lz</strong> format version 0 and the unextended version
1 are supported. Version 0 files were produced by <strong>lzip</strong>
1.3 and older. Such files aren't common but may be found from file
archives as a few source packages were released in this format. People
might have old personal files in this format too. Decompression support
for the format version 0 was removed in <strong>lzip</strong> 1.18.</p>
</dd>
<dt></dt>
<dd>
<p><strong>lzip</strong> 1.4 and later create files in the format
version 1. The sync flush marker extension to the format version 1 was
added in <strong>lzip</strong> 1.6. This extension is rarely used and
isn't supported by <strong>xz</strong> (diagnosed as corrupt input).</p>
</dd>
</dl>
<dl>
<dt><strong>raw</strong></dt>
<dd>
<p>Compress or uncompress a raw stream (no headers). This is meant for
advanced users only. To decode raw streams, you need use
<strong>--format=raw</strong> and explicitly specify the filter chain,
which normally would have been stored in the container headers.</p>
</dd>
</dl>
</dd>
<dt><strong>-C</strong> <em>check</em>,
<strong>--check=</strong><em>check</em></dt>
<dd>
<p>Specify the type of the integrity check. The check is calculated from
the uncompressed data and stored in the <strong>.xz</strong> file. This
option has an effect only when compressing into the <strong>.xz</strong>
format; the <strong>.lzma</strong> format doesn't support integrity
checks. The integrity check (if any) is verified when the
<strong>.xz</strong> file is decompressed.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Supported <em>check</em> types:</p>
<dl>
<dt><strong>none</strong></dt>
<dd>
<p>Don't calculate an integrity check at all. This is usually a bad
idea. This can be useful when integrity of the data is verified by other
means anyway.</p>
</dd>
<dt><strong>crc32</strong></dt>
<dd>
<p>Calculate CRC32 using the polynomial from IEEE-802.3 (Ethernet).</p>
</dd>
<dt><strong>crc64</strong></dt>
<dd>
<p>Calculate CRC64 using the polynomial from ECMA-182. This is the
default, since it is slightly better than CRC32 at detecting damaged
files and the speed difference is negligible.</p>
</dd>
<dt><strong>sha256</strong></dt>
<dd>
<p>Calculate SHA-256. This is somewhat slower than CRC32 and CRC64.</p>
</dd>
</dl>
</dd>
<dt></dt>
<dd>
<p>Integrity of the <strong>.xz</strong> headers is always verified with
CRC32. It is not possible to change or disable it.</p>
</dd>
</dl>
<dl>
<dt><strong>--ignore-check</strong></dt>
<dd>
<p>Don't verify the integrity check of the compressed data when
decompressing. The CRC32 values in the <strong>.xz</strong> headers will
still be verified normally.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p><strong>Do not use this option unless you know what you are
doing.</strong> Possible reasons to use this option:</p>
<ul>
<li><p>Trying to recover data from a corrupt .xz file.</p></li>
<li><p>Speeding up decompression. This matters mostly with SHA-256 or
with files that have compressed extremely well. It's recommended to not
use this option for this purpose unless the file integrity is verified
externally in some other way.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt><strong>-0</strong> ... <strong>-9</strong></dt>
<dd>
<p>Select a compression preset level. The default is
<strong>-6</strong>. If multiple preset levels are specified, the last
one takes effect. If a custom filter chain was already specified,
setting a compression preset level clears the custom filter chain.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The differences between the presets are more significant than with
<strong>gzip</strong>(1) and <strong>bzip2</strong>(1). The selected
compression settings determine the memory requirements of the
decompressor, thus using a too high preset level might make it painful
to decompress the file on an old system with little RAM. Specifically,
<strong>it's not a good idea to blindly use -9 for everything</strong>
like it often is with <strong>gzip</strong>(1) and
<strong>bzip2</strong>(1).</p>
<dl>
<dt><strong>-0</strong> ... <strong>-3</strong></dt>
<dd>
<p>These are somewhat fast presets. <strong>-0</strong> is sometimes
faster than <strong>gzip -9</strong> while compressing much better. The
higher ones often have speed comparable to <strong>bzip2</strong>(1)
with comparable or better compression ratio, although the results depend
a lot on the type of data being compressed.</p>
</dd>
<dt><strong>-4</strong> ... <strong>-6</strong></dt>
<dd>
<p>Good to very good compression while keeping decompressor memory usage
reasonable even for old systems. <strong>-6</strong> is the default,
which is usually a good choice for distributing files that need to be
decompressible even on systems with only 16 MiB RAM.
(<strong>-5e</strong> or <strong>-6e</strong> may be worth considering
too. See <strong>--extreme</strong>.)</p>
</dd>
<dt><strong>-7 ... -9</strong></dt>
<dd>
<p>These are like <strong>-6</strong> but with higher compressor and
decompressor memory requirements. These are useful only when compressing
files bigger than 8 MiB, 16 MiB, and 32 MiB, respectively.</p>
</dd>
</dl>
</dd>
<dt></dt>
<dd>
<p>On the same hardware, the decompression speed is approximately a
constant number of bytes of compressed data per second. In other words,
the better the compression, the faster the decompression will usually
be. This also means that the amount of uncompressed output produced per
second can vary a lot.</p>
</dd>
<dt></dt>
<dd>
<p>The following table summarises the features of the presets:</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Preset</td>
<td style="text-align: center;">DictSize</td>
<td style="text-align: center;">CompCPU</td>
<td style="text-align: center;">CompMem</td>
<td style="text-align: center;">DecMem</td>
</tr>
<tr class="even">
<td style="text-align: center;">-0</td>
<td style="text-align: center;">256 KiB</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">3 MiB</td>
<td style="text-align: center;">1 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-1</td>
<td style="text-align: center;">1 MiB</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">9 MiB</td>
<td style="text-align: center;">2 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-2</td>
<td style="text-align: center;">2 MiB</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">17 MiB</td>
<td style="text-align: center;">3 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-3</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">32 MiB</td>
<td style="text-align: center;">5 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-4</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">48 MiB</td>
<td style="text-align: center;">5 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">9 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">9 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-7</td>
<td style="text-align: center;">16 MiB</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">186 MiB</td>
<td style="text-align: center;">17 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-8</td>
<td style="text-align: center;">32 MiB</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">370 MiB</td>
<td style="text-align: center;">33 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-9</td>
<td style="text-align: center;">64 MiB</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">674 MiB</td>
<td style="text-align: center;">65 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
</dd>
<dt></dt>
<dd>
<p>Column descriptions:</p>
<ul>
<li><p>DictSize is the LZMA2 dictionary size. It is waste of memory to
use a dictionary bigger than the size of the uncompressed file. This is
why it is good to avoid using the presets <strong>-7</strong> ...
<strong>-9</strong> when there's no real need for them. At
<strong>-6</strong> and lower, the amount of memory wasted is usually
low enough to not matter.</p></li>
<li><p>CompCPU is a simplified representation of the LZMA2 settings that
affect compression speed. The dictionary size affects speed too, so
while CompCPU is the same for levels <strong>-6</strong> ...
<strong>-9</strong>, higher levels still tend to be a little slower. To
get even slower and thus possibly better compression, see
<strong>--extreme</strong>.</p></li>
<li><p>CompMem contains the compressor memory requirements in the
single-threaded mode. It may vary slightly between <strong>xz</strong>
versions. Memory requirements of some of the future multithreaded modes
may be dramatically higher than that of the single-threaded
mode.</p></li>
<li><p>DecMem contains the decompressor memory requirements. That is,
the compression settings determine the memory requirements of the
decompressor. The exact decompressor memory usage is slightly more than
the LZMA2 dictionary size, but the values in the table have been rounded
up to the next full MiB.</p></li>
</ul>
</dd>
</dl>
<dl>
<dt><strong>-e</strong>, <strong>--extreme</strong></dt>
<dd>
<p>Use a slower variant of the selected compression preset level
(<strong>-0</strong> ... <strong>-9</strong>) to hopefully get a little
bit better compression ratio, but with bad luck this can also make it
worse. Decompressor memory usage is not affected, but compressor memory
usage increases a little at preset levels <strong>-0</strong> ...
<strong>-3</strong>.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Since there are two presets with dictionary sizes 4 MiB and 8 MiB,
the presets <strong>-3e</strong> and <strong>-5e</strong> use slightly
faster settings (lower CompCPU) than <strong>-4e</strong> and
<strong>-6e</strong>, respectively. That way no two presets are
identical.</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Preset</td>
<td style="text-align: center;">DictSize</td>
<td style="text-align: center;">CompCPU</td>
<td style="text-align: center;">CompMem</td>
<td style="text-align: center;">DecMem</td>
</tr>
<tr class="even">
<td style="text-align: center;">-0e</td>
<td style="text-align: center;">256 KiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">1 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-1e</td>
<td style="text-align: center;">1 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">13 MiB</td>
<td style="text-align: center;">2 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-2e</td>
<td style="text-align: center;">2 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">25 MiB</td>
<td style="text-align: center;">3 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-3e</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">48 MiB</td>
<td style="text-align: center;">5 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-4e</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">48 MiB</td>
<td style="text-align: center;">5 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5e</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">9 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6e</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">9 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-7e</td>
<td style="text-align: center;">16 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">186 MiB</td>
<td style="text-align: center;">17 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-8e</td>
<td style="text-align: center;">32 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">370 MiB</td>
<td style="text-align: center;">33 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-9e</td>
<td style="text-align: center;">64 MiB</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">674 MiB</td>
<td style="text-align: center;">65 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
</dd>
<dt></dt>
<dd>
<p>For example, there are a total of four presets that use 8 MiB
dictionary, whose order from the fastest to the slowest is
<strong>-5</strong>, <strong>-6</strong>, <strong>-5e</strong>, and
<strong>-6e</strong>.</p>
</dd>
</dl>
<dl>
<dt><strong>--fast</strong></dt>
<dd>

</dd>
<dt><strong>--best</strong></dt>
<dd>

</dd>
</dl>
<p>These are somewhat misleading aliases for <strong>-0</strong> and
<strong>-9</strong>, respectively. These are provided only for backwards
compatibility with LZMA Utils. Avoid using these options.</p>
<dl>
<dt><strong>--block-size=</strong><em>size</em></dt>
<dd>
<p>When compressing to the <strong>.xz</strong> format, split the input
data into blocks of <em>size</em> bytes. The blocks are compressed
independently from each other, which helps with multi-threading and
makes limited random-access decompression possible. This option is
typically used to override the default block size in multi-threaded
mode, but this option can be used in single-threaded mode too.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>In multi-threaded mode about three times <em>size</em> bytes will be
allocated in each thread for buffering input and output. The default
<em>size</em> is three times the LZMA2 dictionary size or 1 MiB,
whichever is more. Typically a good value is 2â€“4 times the size of the
LZMA2 dictionary or at least 1 MiB. Using <em>size</em> less than the
LZMA2 dictionary size is waste of RAM because then the LZMA2 dictionary
buffer will never get fully used. The sizes of the blocks are stored in
the block headers, which a future version of <strong>xz</strong> will
use for multi-threaded decompression.</p>
</dd>
<dt></dt>
<dd>
<p>In single-threaded mode no block splitting is done by default.
Setting this option doesn't affect memory usage. No size information is
stored in block headers, thus files created in single-threaded mode
won't be identical to files created in multi-threaded mode. The lack of
size information also means that a future version of <strong>xz</strong>
won't be able decompress the files in multi-threaded mode.</p>
</dd>
</dl>
<dl>
<dt><strong>--block-list=</strong><em>sizes</em></dt>
<dd>
<p>When compressing to the <strong>.xz</strong> format, start a new
block after the given intervals of uncompressed data.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The uncompressed <em>sizes</em> of the blocks are specified as a
comma-separated list. Omitting a size (two or more consecutive commas)
is a shorthand to use the size of the previous block.</p>
</dd>
<dt></dt>
<dd>
<p>If the input file is bigger than the sum of <em>sizes</em>, the last
value in <em>sizes</em> is repeated until the end of the file. A special
value of <strong>0</strong> may be used as the last value to indicate
that the rest of the file should be encoded as a single block.</p>
</dd>
<dt></dt>
<dd>
<p>If one specifies <em>sizes</em> that exceed the encoder's block size
(either the default value in threaded mode or the value specified with
<strong>--block-size=</strong><em>size</em>), the encoder will create
additional blocks while keeping the boundaries specified in
<em>sizes</em>. For example, if one specifies
<strong>--block-size=10MiB</strong>
<strong>--block-list=5MiB,10MiB,8MiB,12MiB,24MiB</strong> and the input
file is 80 MiB, one will get 11 blocks: 5, 10, 8, 10, 2, 10, 10, 4, 10,
10, and 1 MiB.</p>
</dd>
<dt></dt>
<dd>
<p>In multi-threaded mode the sizes of the blocks are stored in the
block headers. This isn't done in single-threaded mode, so the encoded
output won't be identical to that of the multi-threaded mode.</p>
</dd>
</dl>
<dl>
<dt><strong>--flush-timeout=</strong><em>timeout</em></dt>
<dd>
<p>When compressing, if more than <em>timeout</em> milliseconds (a
positive integer) has passed since the previous flush and reading more
input would block, all the pending input data is flushed from the
encoder and made available in the output stream. This can be useful if
<strong>xz</strong> is used to compress data that is streamed over a
network. Small <em>timeout</em> values make the data available at the
receiving end with a small delay, but large <em>timeout</em> values give
better compression ratio.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>This feature is disabled by default. If this option is specified more
than once, the last one takes effect. The special <em>timeout</em> value
of <strong>0</strong> can be used to explicitly disable this
feature.</p>
</dd>
<dt></dt>
<dd>
<p>This feature is not available on non-POSIX systems.</p>
</dd>
<dt></dt>
<dd>
<p><strong>This feature is still experimental.</strong> Currently
<strong>xz</strong> is unsuitable for decompressing the stream in real
time due to how <strong>xz</strong> does buffering.</p>
</dd>
</dl>
<dl>
<dt><strong>--memlimit-compress=</strong><em>limit</em></dt>
<dd>
<p>Set a memory usage limit for compression. If this option is specified
multiple times, the last one takes effect.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>If the compression settings exceed the <em>limit</em>,
<strong>xz</strong> will attempt to adjust the settings downwards so
that the limit is no longer exceeded and display a notice that automatic
adjustment was done. The adjustments are done in this order: reducing
the number of threads, switching to single-threaded mode if even one
thread in multi-threaded mode exceeds the <em>limit</em>, and finally
reducing the LZMA2 dictionary size.</p>
</dd>
<dt></dt>
<dd>
<p>When compressing with <strong>--format=raw</strong> or if
<strong>--no-adjust</strong> has been specified, only the number of
threads may be reduced since it can be done without affecting the
compressed output.</p>
</dd>
<dt></dt>
<dd>
<p>If the <em>limit</em> cannot be met even with the adjustments
described above, an error is displayed and <strong>xz</strong> will exit
with exit status 1.</p>
</dd>
<dt></dt>
<dd>
<p>The <em>limit</em> can be specified in multiple ways:</p>
<ul>
<li><p>The <em>limit</em> can be an absolute value in bytes. Using an
integer suffix like <strong>MiB</strong> can be useful. Example:
<strong>--memlimit-compress=80MiB</strong></p></li>
<li><p>The <em>limit</em> can be specified as a percentage of total
physical memory (RAM). This can be useful especially when setting the
<strong>XZ_DEFAULTS</strong> environment variable in a shell
initialization script that is shared between different computers. That
way the limit is automatically bigger on systems with more memory.
Example: <strong>--memlimit-compress=70%</strong></p></li>
<li><p>The <em>limit</em> can be reset back to its default value by
setting it to <strong>0</strong>. This is currently equivalent to
setting the <em>limit</em> to <strong>max</strong> (no memory usage
limit).</p></li>
</ul>
</dd>
<dt></dt>
<dd>
<p>For 32-bit <strong>xz</strong> there is a special case: if the
<em>limit</em> would be over <strong>4020 MiB</strong>, the
<em>limit</em> is set to <strong>4020 MiB</strong>. On MIPS32
<strong>2000 MiB</strong> is used instead. (The values
<strong>0</strong> and <strong>max</strong> aren't affected by this. A
similar feature doesn't exist for decompression.) This can be helpful
when a 32-bit executable has access to 4 GiB address space (2 GiB on
MIPS32) while hopefully doing no harm in other situations.</p>
</dd>
<dt></dt>
<dd>
<p>See also the section <strong>Memory usage</strong>.</p>
</dd>
</dl>
<dl>
<dt><strong>--memlimit-decompress=</strong><em>limit</em></dt>
<dd>
<p>Set a memory usage limit for decompression. This also affects the
<strong>--list</strong> mode. If the operation is not possible without
exceeding the <em>limit</em>, <strong>xz</strong> will display an error
and decompressing the file will fail. See
<strong>--memlimit-compress=</strong><em>limit</em> for possible ways to
specify the <em>limit</em>.</p>
</dd>
<dt><strong>--memlimit-mt-decompress=</strong><em>limit</em></dt>
<dd>
<p>Set a memory usage limit for multi-threaded decompression. This can
only affect the number of threads; this will never make
<strong>xz</strong> refuse to decompress a file. If <em>limit</em> is
too low to allow any multi-threading, the <em>limit</em> is ignored and
<strong>xz</strong> will continue in single-threaded mode. Note that if
also <strong>--memlimit-decompress</strong> is used, it will always
apply to both single-threaded and multi-threaded modes, and so the
effective <em>limit</em> for multi-threading will never be higher than
the limit set with <strong>--memlimit-decompress</strong>.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>In contrast to the other memory usage limit options,
<strong>--memlimit-mt-decompress=</strong><em>limit</em> has a
system-specific default <em>limit</em>. <strong>xz
--info-memory</strong> can be used to see the current value.</p>
</dd>
<dt></dt>
<dd>
<p>This option and its default value exist because without any limit the
threaded decompressor could end up allocating an insane amount of memory
with some input files. If the default <em>limit</em> is too low on your
system, feel free to increase the <em>limit</em> but never set it to a
value larger than the amount of usable RAM as with appropriate input
files <strong>xz</strong> will attempt to use that amount of memory even
with a low number of threads. Running out of memory or swapping will not
improve decompression performance.</p>
</dd>
<dt></dt>
<dd>
<p>See <strong>--memlimit-compress=</strong><em>limit</em> for possible
ways to specify the <em>limit</em>. Setting <em>limit</em> to
<strong>0</strong> resets the <em>limit</em> to the default
system-specific value.</p>
</dd>
<dt></dt>
<dd>

</dd>
</dl>
<dl>
<dt><strong>-M</strong> <em>limit</em>,
<strong>--memlimit=</strong><em>limit</em>,
<strong>--memory=</strong><em>limit</em></dt>
<dd>
<p>This is equivalent to specifying
<strong>--memlimit-compress=</strong><em>limit</em>
<strong>--memlimit-decompress=</strong><em>limit</em>
<strong>--memlimit-mt-decompress=</strong><em>limit</em>.</p>
</dd>
<dt><strong>--no-adjust</strong></dt>
<dd>
<p>Display an error and exit if the memory usage limit cannot be met
without adjusting settings that affect the compressed output. That is,
this prevents <strong>xz</strong> from switching the encoder from
multi-threaded mode to single-threaded mode and from reducing the LZMA2
dictionary size. Even when this option is used the number of threads may
be reduced to meet the memory usage limit as that won't affect the
compressed output.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Automatic adjusting is always disabled when creating raw streams
(<strong>--format=raw</strong>).</p>
</dd>
</dl>
<dl>
<dt><strong>-T</strong> <em>threads</em>,
<strong>--threads=</strong><em>threads</em></dt>
<dd>
<p>Specify the number of worker threads to use. Setting <em>threads</em>
to a special value <strong>0</strong> makes <strong>xz</strong> use up
to as many threads as the processor(s) on the system support. The actual
number of threads can be fewer than <em>threads</em> if the input file
is not big enough for threading with the given settings or if using more
threads would exceed the memory usage limit.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The single-threaded and multi-threaded compressors produce different
output. Single-threaded compressor will give the smallest file size but
only the output from the multi-threaded compressor can be decompressed
using multiple threads. Setting <em>threads</em> to <strong>1</strong>
will use the single-threaded mode. Setting <em>threads</em> to any other
value, including <strong>0</strong>, will use the multi-threaded
compressor even if the system supports only one hardware thread.
(<strong>xz</strong> 5.2.x used single-threaded mode in this
situation.)</p>
</dd>
<dt></dt>
<dd>
<p>To use multi-threaded mode with only one thread, set <em>threads</em>
to <strong>+1</strong>. The <strong>+</strong> prefix has no effect with
values other than <strong>1</strong>. A memory usage limit can still
make <strong>xz</strong> switch to single-threaded mode unless
<strong>--no-adjust</strong> is used. Support for the <strong>+</strong>
prefix was added in <strong>xz</strong> 5.4.0.</p>
</dd>
<dt></dt>
<dd>
<p>If an automatic number of threads has been requested and no memory
usage limit has been specified, then a system-specific default soft
limit will be used to possibly limit the number of threads. It is a soft
limit in sense that it is ignored if the number of threads becomes one,
thus a soft limit will never stop <strong>xz</strong> from compressing
or decompressing. This default soft limit will not make
<strong>xz</strong> switch from multi-threaded mode to single-threaded
mode. The active limits can be seen with <strong>xz
--info-memory</strong>.</p>
</dd>
<dt></dt>
<dd>
<p>Currently the only threading method is to split the input into blocks
and compress them independently from each other. The default block size
depends on the compression level and can be overridden with the
<strong>--block-size=</strong><em>size</em> option.</p>
</dd>
<dt></dt>
<dd>
<p>Threaded decompression only works on files that contain multiple
blocks with size information in block headers. All large enough files
compressed in multi-threaded mode meet this condition, but files
compressed in single-threaded mode don't even if
<strong>--block-size=</strong><em>size</em> has been used.</p>
</dd>
</dl>
<h2>Custom compressor filter chains</h2>
<p>A custom filter chain allows specifying the compression settings in
detail instead of relying on the settings associated to the presets.
When a custom filter chain is specified, preset options
(<strong>-0</strong> ... <strong>-9</strong> and
<strong>--extreme</strong>) earlier on the command line are forgotten.
If a preset option is specified after one or more custom filter chain
options, the new preset takes effect and the custom filter chain options
specified earlier are forgotten.</p>
<p>A filter chain is comparable to piping on the command line. When
compressing, the uncompressed input goes to the first filter, whose
output goes to the next filter (if any). The output of the last filter
gets written to the compressed file. The maximum number of filters in
the chain is four, but typically a filter chain has only one or two
filters.</p>
<p>Many filters have limitations on where they can be in the filter
chain: some filters can work only as the last filter in the chain, some
only as a non-last filter, and some work in any position in the chain.
Depending on the filter, this limitation is either inherent to the
filter design or exists to prevent security issues.</p>
<p>A custom filter chain is specified by using one or more filter
options in the order they are wanted in the filter chain. That is, the
order of filter options is significant! When decoding raw streams
(<strong>--format=raw</strong>), the filter chain is specified in the
same order as it was specified when compressing.</p>
<p>Filters take filter-specific <em>options</em> as a comma-separated
list. Extra commas in <em>options</em> are ignored. Every option has a
default value, so you need to specify only those you want to change.</p>
<p>To see the whole filter chain and <em>options</em>, use <strong>xz
-vv</strong> (that is, use <strong>--verbose</strong> twice). This works
also for viewing the filter chain options used by presets.</p>
<dl>
<dt><strong>--lzma1</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>

</dd>
<dt><strong>--lzma2</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>

</dd>
</dl>
<p>Add LZMA1 or LZMA2 filter to the filter chain. These filters can be
used only as the last filter in the chain.</p>
<dl>
<dt></dt>
<dd>
<p>LZMA1 is a legacy filter, which is supported almost solely due to the
legacy <strong>.lzma</strong> file format, which supports only LZMA1.
LZMA2 is an updated version of LZMA1 to fix some practical issues of
LZMA1. The <strong>.xz</strong> format uses LZMA2 and doesn't support
LZMA1 at all. Compression speed and ratios of LZMA1 and LZMA2 are
practically the same.</p>
</dd>
<dt></dt>
<dd>
<p>LZMA1 and LZMA2 share the same set of <em>options</em>:</p>
<dl>
<dt><strong>preset=</strong><em>preset</em></dt>
<dd>
<p>Reset all LZMA1 or LZMA2 <em>options</em> to <em>preset</em>.
<em>Preset</em> consist of an integer, which may be followed by
single-letter preset modifiers. The integer can be from
<strong>0</strong> to <strong>9</strong>, matching the command line
options <strong>-0</strong> ... <strong>-9</strong>. The only supported
modifier is currently <strong>e</strong>, which matches
<strong>--extreme</strong>. If no <strong>preset</strong> is specified,
the default values of LZMA1 or LZMA2 <em>options</em> are taken from the
preset <strong>6</strong>.</p>
</dd>
<dt><strong>dict=</strong><em>size</em></dt>
<dd>
<p>Dictionary (history buffer) <em>size</em> indicates how many bytes of
the recently processed uncompressed data is kept in memory. The
algorithm tries to find repeating byte sequences (matches) in the
uncompressed data, and replace them with references to the data
currently in the dictionary. The bigger the dictionary, the higher is
the chance to find a match. Thus, increasing dictionary <em>size</em>
usually improves compression ratio, but a dictionary bigger than the
uncompressed file is waste of memory.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Typical dictionary <em>size</em> is from 64 KiB to 64 MiB. The
minimum is 4 KiB. The maximum for compression is currently 1.5 GiB (1536
MiB). The decompressor already supports dictionaries up to one byte less
than 4 GiB, which is the maximum for the LZMA1 and LZMA2 stream
formats.</p>
</dd>
<dt></dt>
<dd>
<p>Dictionary <em>size</em> and match finder (<em>mf</em>) together
determine the memory usage of the LZMA1 or LZMA2 encoder. The same (or
bigger) dictionary <em>size</em> is required for decompressing that was
used when compressing, thus the memory usage of the decoder is
determined by the dictionary size used when compressing. The
<strong>.xz</strong> headers store the dictionary <em>size</em> either
as 2^<em>n</em> or 2^<em>n</em> + 2^(<em>n</em>-1), so these
<em>sizes</em> are somewhat preferred for compression. Other
<em>sizes</em> will get rounded up when stored in the
<strong>.xz</strong> headers.</p>
</dd>
</dl>
<dl>
<dt><strong>lc=</strong><em>lc</em></dt>
<dd>
<p>Specify the number of literal context bits. The minimum is 0 and the
maximum is 4; the default is 3. In addition, the sum of <em>lc</em> and
<em>lp</em> must not exceed 4.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>All bytes that cannot be encoded as matches are encoded as literals.
That is, literals are simply 8-bit bytes that are encoded one at a
time.</p>
</dd>
<dt></dt>
<dd>
<p>The literal coding makes an assumption that the highest <em>lc</em>
bits of the previous uncompressed byte correlate with the next byte. For
example, in typical English text, an upper-case letter is often followed
by a lower-case letter, and a lower-case letter is usually followed by
another lower-case letter. In the US-ASCII character set, the highest
three bits are 010 for upper-case letters and 011 for lower-case
letters. When <em>lc</em> is at least 3, the literal coding can take
advantage of this property in the uncompressed data.</p>
</dd>
<dt></dt>
<dd>
<p>The default value (3) is usually good. If you want maximum
compression, test <strong>lc=4</strong>. Sometimes it helps a little,
and sometimes it makes compression worse. If it makes it worse, test
<strong>lc=2</strong> too.</p>
</dd>
</dl>
<dl>
<dt><strong>lp=</strong><em>lp</em></dt>
<dd>
<p>Specify the number of literal position bits. The minimum is 0 and the
maximum is 4; the default is 0.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p><em>Lp</em> affects what kind of alignment in the uncompressed data
is assumed when encoding literals. See <em>pb</em> below for more
information about alignment.</p>
</dd>
</dl>
<dl>
<dt><strong>pb=</strong><em>pb</em></dt>
<dd>
<p>Specify the number of position bits. The minimum is 0 and the maximum
is 4; the default is 2.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p><em>Pb</em> affects what kind of alignment in the uncompressed data
is assumed in general. The default means four-byte alignment
(2^<em>pb</em>=2^2=4), which is often a good choice when there's no
better guess.</p>
</dd>
<dt></dt>
<dd>
<p>When the alignment is known, setting <em>pb</em> accordingly may
reduce the file size a little. For example, with text files having
one-byte alignment (US-ASCII, ISO-8859-*, UTF-8), setting
<strong>pb=0</strong> can improve compression slightly. For UTF-16 text,
<strong>pb=1</strong> is a good choice. If the alignment is an odd
number like 3 bytes, <strong>pb=0</strong> might be the best choice.</p>
</dd>
<dt></dt>
<dd>
<p>Even though the assumed alignment can be adjusted with <em>pb</em>
and <em>lp</em>, LZMA1 and LZMA2 still slightly favor 16-byte alignment.
It might be worth taking into account when designing file formats that
are likely to be often compressed with LZMA1 or LZMA2.</p>
</dd>
</dl>
<dl>
<dt><strong>mf=</strong><em>mf</em></dt>
<dd>
<p>Match finder has a major effect on encoder speed, memory usage, and
compression ratio. Usually Hash Chain match finders are faster than
Binary Tree match finders. The default depends on the <em>preset</em>: 0
uses <strong>hc3</strong>, 1â€“3 use <strong>hc4</strong>, and the rest
use <strong>bt4</strong>.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The following match finders are supported. The memory usage formulas
below are rough approximations, which are closest to the reality when
<em>dict</em> is a power of two.</p>
<dl>
<dt><strong>hc3</strong></dt>
<dd>
<p>Hash Chain with 2- and 3-byte hashing<br />
Minimum value for <em>nice</em>: 3<br />
Memory usage:<br />
<em>dict</em> * 7.5 (if <em>dict</em> &lt;= 16 MiB);<br />
<em>dict</em> * 5.5 + 64 MiB (if <em>dict</em> &gt; 16 MiB)</p>
</dd>
<dt><strong>hc4</strong></dt>
<dd>
<p>Hash Chain with 2-, 3-, and 4-byte hashing<br />
Minimum value for <em>nice</em>: 4<br />
Memory usage:<br />
<em>dict</em> * 7.5 (if <em>dict</em> &lt;= 32 MiB);<br />
<em>dict</em> * 6.5 (if <em>dict</em> &gt; 32 MiB)</p>
</dd>
<dt><strong>bt2</strong></dt>
<dd>
<p>Binary Tree with 2-byte hashing<br />
Minimum value for <em>nice</em>: 2<br />
Memory usage: <em>dict</em> * 9.5</p>
</dd>
<dt><strong>bt3</strong></dt>
<dd>
<p>Binary Tree with 2- and 3-byte hashing<br />
Minimum value for <em>nice</em>: 3<br />
Memory usage:<br />
<em>dict</em> * 11.5 (if <em>dict</em> &lt;= 16 MiB);<br />
<em>dict</em> * 9.5 + 64 MiB (if <em>dict</em> &gt; 16 MiB)</p>
</dd>
<dt><strong>bt4</strong></dt>
<dd>
<p>Binary Tree with 2-, 3-, and 4-byte hashing<br />
Minimum value for <em>nice</em>: 4<br />
Memory usage:<br />
<em>dict</em> * 11.5 (if <em>dict</em> &lt;= 32 MiB);<br />
<em>dict</em> * 10.5 (if <em>dict</em> &gt; 32 MiB)</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dt><strong>mode=</strong><em>mode</em></dt>
<dd>
<p>Compression <em>mode</em> specifies the method to analyze the data
produced by the match finder. Supported <em>modes</em> are
<strong>fast</strong> and <strong>normal</strong>. The default is
<strong>fast</strong> for <em>presets</em> 0â€“3 and
<strong>normal</strong> for <em>presets</em> 4â€“9.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Usually <strong>fast</strong> is used with Hash Chain match finders
and <strong>normal</strong> with Binary Tree match finders. This is also
what the <em>presets</em> do.</p>
</dd>
</dl>
<dl>
<dt><strong>nice=</strong><em>nice</em></dt>
<dd>
<p>Specify what is considered to be a nice length for a match. Once a
match of at least <em>nice</em> bytes is found, the algorithm stops
looking for possibly better matches.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p><em>Nice</em> can be 2â€“273 bytes. Higher values tend to give better
compression ratio at the expense of speed. The default depends on the
<em>preset</em>.</p>
</dd>
</dl>
<dl>
<dt><strong>depth=</strong><em>depth</em></dt>
<dd>
<p>Specify the maximum search depth in the match finder. The default is
the special value of 0, which makes the compressor determine a
reasonable <em>depth</em> from <em>mf</em> and <em>nice</em>.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Reasonable <em>depth</em> for Hash Chains is 4â€“100 and 16â€“1000 for
Binary Trees. Using very high values for <em>depth</em> can make the
encoder extremely slow with some files. Avoid setting the <em>depth</em>
over 1000 unless you are prepared to interrupt the compression in case
it is taking far too long.</p>
</dd>
</dl>
</dd>
<dt></dt>
<dd>
<p>When decoding raw streams (<strong>--format=raw</strong>), LZMA2
needs only the dictionary <em>size</em>. LZMA1 needs also <em>lc</em>,
<em>lp</em>, and <em>pb</em>.</p>
</dd>
</dl>
<dl>
<dt><strong>--x86</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>

</dd>
<dt><strong>--arm</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<dl>
<dt><strong>--armthumb</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<dl>
<dt><strong>--arm64</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<dl>
<dt><strong>--powerpc</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<dl>
<dt><strong>--ia64</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<dl>
<dt><strong>--sparc</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>

</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>Add a branch/call/jump (BCJ) filter to the filter chain. These
filters can be used only as a non-last filter in the filter chain.</p>
<dl>
<dt></dt>
<dd>
<p>A BCJ filter converts relative addresses in the machine code to their
absolute counterparts. This doesn't change the size of the data but it
increases redundancy, which can help LZMA2 to produce 0â€“15 % smaller
<strong>.xz</strong> file. The BCJ filters are always reversible, so
using a BCJ filter for wrong type of data doesn't cause any data loss,
although it may make the compression ratio slightly worse. The BCJ
filters are very fast and use an insignificant amount of memory.</p>
</dd>
<dt></dt>
<dd>
<p>These BCJ filters have known problems related to the compression
ratio:</p>
<ul>
<li><p>Some types of files containing executable code (for example,
object files, static libraries, and Linux kernel modules) have the
addresses in the instructions filled with filler values. These BCJ
filters will still do the address conversion, which will make the
compression worse with these files.</p></li>
<li><p>If a BCJ filter is applied on an archive, it is possible that it
makes the compression ratio worse than not using a BCJ filter. For
example, if there are similar or even identical executables then
filtering will likely make the files less similar and thus compression
is worse. The contents of non-executable files in the same archive can
matter too. In practice one has to try with and without a BCJ filter to
see which is better in each situation.</p></li>
</ul>
</dd>
<dt></dt>
<dd>
<p>Different instruction sets have different alignment: the executable
file must be aligned to a multiple of this value in the input data to
make the filter work.</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: left;">Filter</td>
<td style="text-align: right;">Alignment</td>
<td style="text-align: left;">Notes</td>
</tr>
<tr class="even">
<td style="text-align: left;">x86</td>
<td style="text-align: right;">1</td>
<td style="text-align: left;">32-bit or 64-bit x86</td>
</tr>
<tr class="odd">
<td style="text-align: left;">ARM</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td style="text-align: left;">ARM-Thumb</td>
<td style="text-align: right;">2</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td style="text-align: left;">ARM64</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">4096-byte alignment is best</td>
</tr>
<tr class="even">
<td style="text-align: left;">PowerPC</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;">Big endian only</td>
</tr>
<tr class="odd">
<td style="text-align: left;">IA-64</td>
<td style="text-align: right;">16</td>
<td style="text-align: left;">Itanium</td>
</tr>
<tr class="even">
<td style="text-align: left;">SPARC</td>
<td style="text-align: right;">4</td>
<td style="text-align: left;"></td>
</tr>
</tbody>
</table>
</blockquote>
</dd>
<dt></dt>
<dd>
<p>Since the BCJ-filtered data is usually compressed with LZMA2, the
compression ratio may be improved slightly if the LZMA2 options are set
to match the alignment of the selected BCJ filter. For example, with the
IA-64 filter, it's good to set <strong>pb=4</strong> or even
<strong>pb=4,lp=4,lc=0</strong> with LZMA2 (2^4=16). The x86 filter is
an exception; it's usually good to stick to LZMA2's default four-byte
alignment when compressing x86 executables.</p>
</dd>
<dt></dt>
<dd>
<p>All BCJ filters support the same <em>options</em>:</p>
<dl>
<dt><strong>start=</strong><em>offset</em></dt>
<dd>
<p>Specify the start <em>offset</em> that is used when converting
between relative and absolute addresses. The <em>offset</em> must be a
multiple of the alignment of the filter (see the table above). The
default is zero. In practice, the default is good; specifying a custom
<em>offset</em> is almost never useful.</p>
</dd>
</dl>
</dd>
</dl>
<dl>
<dt><strong>--delta</strong>[<strong>=</strong><em>options</em>]</dt>
<dd>
<p>Add the Delta filter to the filter chain. The Delta filter can be
only used as a non-last filter in the filter chain.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Currently only simple byte-wise delta calculation is supported. It
can be useful when compressing, for example, uncompressed bitmap images
or uncompressed PCM audio. However, special purpose algorithms may give
significantly better results than Delta + LZMA2. This is true especially
with audio, which compresses faster and better, for example, with
<strong>flac</strong>(1).</p>
</dd>
<dt></dt>
<dd>
<p>Supported <em>options</em>:</p>
<dl>
<dt><strong>dist=</strong><em>distance</em></dt>
<dd>
<p>Specify the <em>distance</em> of the delta calculation in bytes.
<em>distance</em> must be 1â€“256. The default is 1.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>For example, with <strong>dist=2</strong> and eight-byte input A1 B1
A2 B3 A3 B5 A4 B7, the output will be A1 B1 01 02 01 02 01 02.</p>
</dd>
</dl>
</dd>
</dl>
<h2>Other options</h2>
<dl>
<dt><strong>-q</strong>, <strong>--quiet</strong></dt>
<dd>
<p>Suppress warnings and notices. Specify this twice to suppress errors
too. This option has no effect on the exit status. That is, even if a
warning was suppressed, the exit status to indicate a warning is still
used.</p>
</dd>
<dt><strong>-v</strong>, <strong>--verbose</strong></dt>
<dd>
<p>Be verbose. If standard error is connected to a terminal,
<strong>xz</strong> will display a progress indicator. Specifying
<strong>--verbose</strong> twice will give even more verbose output.</p>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>The progress indicator shows the following information:</p>
<ul>
<li><p>Completion percentage is shown if the size of the input file is
known. That is, the percentage cannot be shown in pipes.</p></li>
<li><p>Amount of compressed data produced (compressing) or consumed
(decompressing).</p></li>
<li><p>Amount of uncompressed data consumed (compressing) or produced
(decompressing).</p></li>
<li><p>Compression ratio, which is calculated by dividing the amount of
compressed data processed so far by the amount of uncompressed data
processed so far.</p></li>
<li><p>Compression or decompression speed. This is measured as the
amount of uncompressed data consumed (compression) or produced
(decompression) per second. It is shown after a few seconds have passed
since <strong>xz</strong> started processing the file.</p></li>
<li><p>Elapsed time in the format M:SS or H:MM:SS.</p></li>
<li><p>Estimated remaining time is shown only when the size of the input
file is known and a couple of seconds have already passed since
<strong>xz</strong> started processing the file. The time is shown in a
less precise format which never has any colons, for example, 2 min 30
s.</p></li>
</ul>
</dd>
<dt></dt>
<dd>
<p>When standard error is not a terminal, <strong>--verbose</strong>
will make <strong>xz</strong> print the filename, compressed size,
uncompressed size, compression ratio, and possibly also the speed and
elapsed time on a single line to standard error after compressing or
decompressing the file. The speed and elapsed time are included only
when the operation took at least a few seconds. If the operation didn't
finish, for example, due to user interruption, also the completion
percentage is printed if the size of the input file is known.</p>
</dd>
</dl>
<dl>
<dt><strong>-Q</strong>, <strong>--no-warn</strong></dt>
<dd>
<p>Don't set the exit status to 2 even if a condition worth a warning
was detected. This option doesn't affect the verbosity level, thus both
<strong>--quiet</strong> and <strong>--no-warn</strong> have to be used
to not display warnings and to not alter the exit status.</p>
</dd>
<dt><strong>--robot</strong></dt>
<dd>
<p>Print messages in a machine-parsable format. This is intended to ease
writing frontends that want to use <strong>xz</strong> instead of
liblzma, which may be the case with various scripts. The output with
this option enabled is meant to be stable across <strong>xz</strong>
releases. See the section <strong>ROBOT MODE</strong> for details.</p>
</dd>
<dt><strong>--info-memory</strong></dt>
<dd>
<p>Display, in human-readable format, how much physical memory (RAM) and
how many processor threads <strong>xz</strong> thinks the system has and
the memory usage limits for compression and decompression, and exit
successfully.</p>
</dd>
<dt><strong>-h</strong>, <strong>--help</strong></dt>
<dd>
<p>Display a help message describing the most commonly used options, and
exit successfully.</p>
</dd>
<dt><strong>-H</strong>, <strong>--long-help</strong></dt>
<dd>
<p>Display a help message describing all features of
<strong>xz</strong>, and exit successfully</p>
</dd>
<dt><strong>-V</strong>, <strong>--version</strong></dt>
<dd>
<p>Display the version number of <strong>xz</strong> and liblzma in
human readable format. To get machine-parsable output, specify
<strong>--robot</strong> before <strong>--version</strong>.</p>
</dd>
</dl>
<h1>ROBOT MODE</h1>
<p>The robot mode is activated with the <strong>--robot</strong> option.
It makes the output of <strong>xz</strong> easier to parse by other
programs. Currently <strong>--robot</strong> is supported only together
with <strong>--version</strong>, <strong>--info-memory</strong>, and
<strong>--list</strong>. It will be supported for compression and
decompression in the future.</p>
<h2>Version</h2>
<p><strong>xz --robot --version</strong> will print the version number
of <strong>xz</strong> and liblzma in the following format:</p>
<p><strong>XZ_VERSION=</strong><em>XYYYZZZS</em><br />
<strong>LIBLZMA_VERSION=</strong><em>XYYYZZZS</em></p>
<dl>
<dt><em>X</em></dt>
<dd>
<p>Major version.</p>
</dd>
<dt><em>YYY</em></dt>
<dd>
<p>Minor version. Even numbers are stable. Odd numbers are alpha or beta
versions.</p>
</dd>
<dt><em>ZZZ</em></dt>
<dd>
<p>Patch level for stable releases or just a counter for development
releases.</p>
</dd>
<dt><em>S</em></dt>
<dd>
<p>Stability. 0 is alpha, 1 is beta, and 2 is stable. <em>S</em> should
be always 2 when <em>YYY</em> is even.</p>
</dd>
</dl>
<p><em>XYYYZZZS</em> are the same on both lines if <strong>xz</strong>
and liblzma are from the same XZ Utils release.</p>
<p>Examples: 4.999.9beta is <strong>49990091</strong> and 5.0.0 is
<strong>50000002</strong>.</p>
<h2>Memory limit information</h2>
<p><strong>xz --robot --info-memory</strong> prints a single line with
three tab-separated columns:</p>
<ol type="1">
<li><p>Total amount of physical memory (RAM) in bytes.</p></li>
<li><p>Memory usage limit for compression in bytes
(<strong>--memlimit-compress</strong>). A special value of
<strong>0</strong> indicates the default setting which for
single-threaded mode is the same as no limit.</p></li>
<li><p>Memory usage limit for decompression in bytes
(<strong>--memlimit-decompress</strong>). A special value of
<strong>0</strong> indicates the default setting which for
single-threaded mode is the same as no limit.</p></li>
<li><p>Since <strong>xz</strong> 5.3.4alpha: Memory usage for
multi-threaded decompression in bytes
(<strong>--memlimit-mt-decompress</strong>). This is never zero because
a system-specific default value shown in the column 5 is used if no
limit has been specified explicitly. This is also never greater than the
value in the column 3 even if a larger value has been specified with
<strong>--memlimit-mt-decompress</strong>.</p></li>
<li><p>Since <strong>xz</strong> 5.3.4alpha: A system-specific default
memory usage limit that is used to limit the number of threads when
compressing with an automatic number of threads
(<strong>--threads=0</strong>) and no memory usage limit has been
specified (<strong>--memlimit-compress</strong>). This is also used as
the default value for
<strong>--memlimit-mt-decompress</strong>.</p></li>
<li><p>Since <strong>xz</strong> 5.3.4alpha: Number of available
processor threads.</p></li>
</ol>
<p>In the future, the output of <strong>xz --robot
--info-memory</strong> may have more columns, but never more than a
single line.</p>
<h2>List mode</h2>
<p><strong>xz --robot --list</strong> uses tab-separated output. The
first column of every line has a string that indicates the type of the
information found on that line:</p>
<dl>
<dt><strong>name</strong></dt>
<dd>
<p>This is always the first line when starting to list a file. The
second column on the line is the filename.</p>
</dd>
<dt><strong>file</strong></dt>
<dd>
<p>This line contains overall information about the <strong>.xz</strong>
file. This line is always printed after the <strong>name</strong>
line.</p>
</dd>
<dt><strong>stream</strong></dt>
<dd>
<p>This line type is used only when <strong>--verbose</strong> was
specified. There are as many <strong>stream</strong> lines as there are
streams in the <strong>.xz</strong> file.</p>
</dd>
<dt><strong>block</strong></dt>
<dd>
<p>This line type is used only when <strong>--verbose</strong> was
specified. There are as many <strong>block</strong> lines as there are
blocks in the <strong>.xz</strong> file. The <strong>block</strong>
lines are shown after all the <strong>stream</strong> lines; different
line types are not interleaved.</p>
</dd>
<dt><strong>summary</strong></dt>
<dd>
<p>This line type is used only when <strong>--verbose</strong> was
specified twice. This line is printed after all <strong>block</strong>
lines. Like the <strong>file</strong> line, the <strong>summary</strong>
line contains overall information about the <strong>.xz</strong>
file.</p>
</dd>
<dt><strong>totals</strong></dt>
<dd>
<p>This line is always the very last line of the list output. It shows
the total counts and sizes.</p>
</dd>
</dl>
<p>The columns of the <strong>file</strong> lines:</p>
<blockquote>
<ol start="2" type="1">
<li><p>Number of streams in the file</p></li>
<li><p>Total number of blocks in the stream(s)</p></li>
<li><p>Compressed size of the file</p></li>
<li><p>Uncompressed size of the file</p></li>
<li><p>Compression ratio, for example, <strong>0.123</strong>. If ratio
is over 9.999, three dashes (<strong>---</strong>) are displayed instead
of the ratio.</p></li>
<li><p>Comma-separated list of integrity check names. The following
strings are used for the known check types: <strong>None</strong>,
<strong>CRC32</strong>, <strong>CRC64</strong>, and
<strong>SHA-256</strong>. For unknown check types,
<strong>Unknown-</strong><em>N</em> is used, where <em>N</em> is the
Check ID as a decimal number (one or two digits).</p></li>
<li><p>Total size of stream padding in the file</p></li>
</ol>
</blockquote>
<p>The columns of the <strong>stream</strong> lines:</p>
<blockquote>
<ol start="2" type="1">
<li><p>Stream number (the first stream is 1)</p></li>
<li><p>Number of blocks in the stream</p></li>
<li><p>Compressed start offset</p></li>
<li><p>Uncompressed start offset</p></li>
<li><p>Compressed size (does not include stream padding)</p></li>
<li><p>Uncompressed size</p></li>
<li><p>Compression ratio</p></li>
<li><p>Name of the integrity check</p></li>
<li><p>Size of stream padding</p></li>
</ol>
</blockquote>
<p>The columns of the <strong>block</strong> lines:</p>
<blockquote>
<ol start="2" type="1">
<li><p>Number of the stream containing this block</p></li>
<li><p>Block number relative to the beginning of the stream (the first
block is 1)</p></li>
<li><p>Block number relative to the beginning of the file</p></li>
<li><p>Compressed start offset relative to the beginning of the
file</p></li>
<li><p>Uncompressed start offset relative to the beginning of the
file</p></li>
<li><p>Total compressed size of the block (includes headers)</p></li>
<li><p>Uncompressed size</p></li>
<li><p>Compression ratio</p></li>
<li><p>Name of the integrity check</p></li>
</ol>
</blockquote>
<p>If <strong>--verbose</strong> was specified twice, additional columns
are included on the <strong>block</strong> lines. These are not
displayed with a single <strong>--verbose</strong>, because getting this
information requires many seeks and can thus be slow:</p>
<blockquote>
<ol start="11" type="1">
<li><p>Value of the integrity check in hexadecimal</p></li>
<li><p>Block header size</p></li>
<li><p>Block flags: <strong>c</strong> indicates that compressed size is
present, and <strong>u</strong> indicates that uncompressed size is
present. If the flag is not set, a dash (<strong>-</strong>) is shown
instead to keep the string length fixed. New flags may be added to the
end of the string in the future.</p></li>
<li><p>Size of the actual compressed data in the block (this excludes
the block header, block padding, and check fields)</p></li>
<li><p>Amount of memory (in bytes) required to decompress this block
with this <strong>xz</strong> version</p></li>
<li><p>Filter chain. Note that most of the options used at compression
time cannot be known, because only the options that are needed for
decompression are stored in the <strong>.xz</strong> headers.</p></li>
</ol>
</blockquote>
<p>The columns of the <strong>summary</strong> lines:</p>
<blockquote>
<ol start="2" type="1">
<li><p>Amount of memory (in bytes) required to decompress this file with
this <strong>xz</strong> version</p></li>
<li><p><strong>yes</strong> or <strong>no</strong> indicating if all
block headers have both compressed size and uncompressed size stored in
them</p></li>
</ol>
<p><em>Since</em> <strong>xz</strong> <em>5.1.2alpha:</em></p>
<ol start="4" type="1">
<li><p>Minimum <strong>xz</strong> version required to decompress the
file</p></li>
</ol>
</blockquote>
<p>The columns of the <strong>totals</strong> line:</p>
<blockquote>
<ol start="2" type="1">
<li><p>Number of streams</p></li>
<li><p>Number of blocks</p></li>
<li><p>Compressed size</p></li>
<li><p>Uncompressed size</p></li>
<li><p>Average compression ratio</p></li>
<li><p>Comma-separated list of integrity check names that were present
in the files</p></li>
<li><p>Stream padding size</p></li>
<li><p>Number of files. This is here to keep the order of the earlier
columns the same as on <strong>file</strong> lines.</p></li>
</ol>
</blockquote>
<p>If <strong>--verbose</strong> was specified twice, additional columns
are included on the <strong>totals</strong> line:</p>
<blockquote>
<ol start="10" type="1">
<li><p>Maximum amount of memory (in bytes) required to decompress the
files with this <strong>xz</strong> version</p></li>
<li><p><strong>yes</strong> or <strong>no</strong> indicating if all
block headers have both compressed size and uncompressed size stored in
them</p></li>
</ol>
<p><em>Since</em> <strong>xz</strong> <em>5.1.2alpha:</em></p>
<ol start="12" type="1">
<li><p>Minimum <strong>xz</strong> version required to decompress the
file</p></li>
</ol>
</blockquote>
<p>Future versions may add new line types and new columns can be added
to the existing line types, but the existing columns won't be
changed.</p>
<h1>EXIT STATUS</h1>
<dl>
<dt><strong>0</strong></dt>
<dd>
<p>All is good.</p>
</dd>
<dt><strong>1</strong></dt>
<dd>
<p>An error occurred.</p>
</dd>
<dt><strong>2</strong></dt>
<dd>
<p>Something worth a warning occurred, but no actual errors
occurred.</p>
</dd>
</dl>
<p>Notices (not warnings or errors) printed on standard error don't
affect the exit status.</p>
<h1>ENVIRONMENT</h1>
<p><strong>xz</strong> parses space-separated lists of options from the
environment variables <strong>XZ_DEFAULTS</strong> and
<strong>XZ_OPT</strong>, in this order, before parsing the options from
the command line. Note that only options are parsed from the environment
variables; all non-options are silently ignored. Parsing is done with
<strong>getopt_long</strong>(3) which is used also for the command line
arguments.</p>
<dl>
<dt><strong>XZ_DEFAULTS</strong></dt>
<dd>
<p>User-specific or system-wide default options. Typically this is set
in a shell initialization script to enable <strong>xz</strong>'s memory
usage limiter by default. Excluding shell initialization scripts and
similar special cases, scripts must never set or unset
<strong>XZ_DEFAULTS</strong>.</p>
</dd>
<dt><strong>XZ_OPT</strong></dt>
<dd>
<p>This is for passing options to <strong>xz</strong> when it is not
possible to set the options directly on the <strong>xz</strong> command
line. This is the case when <strong>xz</strong> is run by a script or
tool, for example, GNU <strong>tar</strong>(1):</p>
<blockquote>
<pre><code>XZ_OPT=-2v tar caf foo.tar.xz foo</code></pre>
</blockquote>
</dd>
</dl>
<dl>
<dt></dt>
<dd>
<p>Scripts may use <strong>XZ_OPT</strong>, for example, to set
script-specific default compression options. It is still recommended to
allow users to override <strong>XZ_OPT</strong> if that is reasonable.
For example, in <strong>sh</strong>(1) scripts one may use something
like this:</p>
<blockquote>
<pre><code>XZ_OPT=${XZ_OPT-&quot;-7e&quot;}
export XZ_OPT</code></pre>
</blockquote>
</dd>
</dl>
<h1>LZMA UTILS COMPATIBILITY</h1>
<p>The command line syntax of <strong>xz</strong> is practically a
superset of <strong>lzma</strong>, <strong>unlzma</strong>, and
<strong>lzcat</strong> as found from LZMA Utils 4.32.x. In most cases,
it is possible to replace LZMA Utils with XZ Utils without breaking
existing scripts. There are some incompatibilities though, which may
sometimes cause problems.</p>
<h2>Compression preset levels</h2>
<p>The numbering of the compression level presets is not identical in
<strong>xz</strong> and LZMA Utils. The most important difference is how
dictionary sizes are mapped to different presets. Dictionary size is
roughly equal to the decompressor memory usage.</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Level</td>
<td style="text-align: center;">xz</td>
<td style="text-align: center;">LZMA Utils</td>
</tr>
<tr class="even">
<td style="text-align: center;">-0</td>
<td style="text-align: center;">256 KiB</td>
<td style="text-align: center;">N/A</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-1</td>
<td style="text-align: center;">1 MiB</td>
<td style="text-align: center;">64 KiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-2</td>
<td style="text-align: center;">2 MiB</td>
<td style="text-align: center;">1 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-3</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">512 KiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-4</td>
<td style="text-align: center;">4 MiB</td>
<td style="text-align: center;">1 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">2 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6</td>
<td style="text-align: center;">8 MiB</td>
<td style="text-align: center;">4 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-7</td>
<td style="text-align: center;">16 MiB</td>
<td style="text-align: center;">8 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-8</td>
<td style="text-align: center;">32 MiB</td>
<td style="text-align: center;">16 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-9</td>
<td style="text-align: center;">64 MiB</td>
<td style="text-align: center;">32 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The dictionary size differences affect the compressor memory usage
too, but there are some other differences between LZMA Utils and XZ
Utils, which make the difference even bigger:</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Level</td>
<td style="text-align: center;">xz</td>
<td style="text-align: center;">LZMA Utils 4.32.x</td>
</tr>
<tr class="even">
<td style="text-align: center;">-0</td>
<td style="text-align: center;">3 MiB</td>
<td style="text-align: center;">N/A</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-1</td>
<td style="text-align: center;">9 MiB</td>
<td style="text-align: center;">2 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-2</td>
<td style="text-align: center;">17 MiB</td>
<td style="text-align: center;">12 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-3</td>
<td style="text-align: center;">32 MiB</td>
<td style="text-align: center;">12 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-4</td>
<td style="text-align: center;">48 MiB</td>
<td style="text-align: center;">16 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">26 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6</td>
<td style="text-align: center;">94 MiB</td>
<td style="text-align: center;">45 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-7</td>
<td style="text-align: center;">186 MiB</td>
<td style="text-align: center;">83 MiB</td>
</tr>
<tr class="even">
<td style="text-align: center;">-8</td>
<td style="text-align: center;">370 MiB</td>
<td style="text-align: center;">159 MiB</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-9</td>
<td style="text-align: center;">674 MiB</td>
<td style="text-align: center;">311 MiB</td>
</tr>
</tbody>
</table>
</blockquote>
<p>The default preset level in LZMA Utils is <strong>-7</strong> while
in XZ Utils it is <strong>-6</strong>, so both use an 8 MiB dictionary
by default.</p>
<h2>Streamed vs. non-streamed .lzma files</h2>
<p>The uncompressed size of the file can be stored in the
<strong>.lzma</strong> header. LZMA Utils does that when compressing
regular files. The alternative is to mark that uncompressed size is
unknown and use end-of-payload marker to indicate where the decompressor
should stop. LZMA Utils uses this method when uncompressed size isn't
known, which is the case, for example, in pipes.</p>
<p><strong>xz</strong> supports decompressing <strong>.lzma</strong>
files with or without end-of-payload marker, but all
<strong>.lzma</strong> files created by <strong>xz</strong> will use
end-of-payload marker and have uncompressed size marked as unknown in
the <strong>.lzma</strong> header. This may be a problem in some
uncommon situations. For example, a <strong>.lzma</strong> decompressor
in an embedded device might work only with files that have known
uncompressed size. If you hit this problem, you need to use LZMA Utils
or LZMA SDK to create <strong>.lzma</strong> files with known
uncompressed size.</p>
<h2>Unsupported .lzma files</h2>
<p>The <strong>.lzma</strong> format allows <em>lc</em> values up to 8,
and <em>lp</em> values up to 4. LZMA Utils can decompress files with any
<em>lc</em> and <em>lp</em>, but always creates files with
<strong>lc=3</strong> and <strong>lp=0</strong>. Creating files with
other <em>lc</em> and <em>lp</em> is possible with <strong>xz</strong>
and with LZMA SDK.</p>
<p>The implementation of the LZMA1 filter in liblzma requires that the
sum of <em>lc</em> and <em>lp</em> must not exceed 4. Thus,
<strong>.lzma</strong> files, which exceed this limitation, cannot be
decompressed with <strong>xz</strong>.</p>
<p>LZMA Utils creates only <strong>.lzma</strong> files which have a
dictionary size of 2^<em>n</em> (a power of 2) but accepts files with
any dictionary size. liblzma accepts only <strong>.lzma</strong> files
which have a dictionary size of 2^<em>n</em> or 2^<em>n</em> +
2^(<em>n</em>-1). This is to decrease false positives when detecting
<strong>.lzma</strong> files.</p>
<p>These limitations shouldn't be a problem in practice, since
practically all <strong>.lzma</strong> files have been compressed with
settings that liblzma will accept.</p>
<h2>Trailing garbage</h2>
<p>When decompressing, LZMA Utils silently ignore everything after the
first <strong>.lzma</strong> stream. In most situations, this is a bug.
This also means that LZMA Utils don't support decompressing concatenated
<strong>.lzma</strong> files.</p>
<p>If there is data left after the first <strong>.lzma</strong> stream,
<strong>xz</strong> considers the file to be corrupt unless
<strong>--single-stream</strong> was used. This may break obscure
scripts which have assumed that trailing garbage is ignored.</p>
<h1>NOTES</h1>
<h2>Compressed output may vary</h2>
<p>The exact compressed output produced from the same uncompressed input
file may vary between XZ Utils versions even if compression options are
identical. This is because the encoder can be improved (faster or better
compression) without affecting the file format. The output can vary even
between different builds of the same XZ Utils version, if different
build options are used.</p>
<p>The above means that once <strong>--rsyncable</strong> has been
implemented, the resulting files won't necessarily be rsyncable unless
both old and new files have been compressed with the same xz version.
This problem can be fixed if a part of the encoder implementation is
frozen to keep rsyncable output stable across xz versions.</p>
<h2>Embedded .xz decompressors</h2>
<p>Embedded <strong>.xz</strong> decompressor implementations like XZ
Embedded don't necessarily support files created with integrity
<em>check</em> types other than <strong>none</strong> and
<strong>crc32</strong>. Since the default is
<strong>--check=crc64</strong>, you must use
<strong>--check=none</strong> or <strong>--check=crc32</strong> when
creating files for embedded systems.</p>
<p>Outside embedded systems, all <strong>.xz</strong> format
decompressors support all the <em>check</em> types, or at least are able
to decompress the file without verifying the integrity check if the
particular <em>check</em> is not supported.</p>
<p>XZ Embedded supports BCJ filters, but only with the default start
offset.</p>
<h1>EXAMPLES</h1>
<h2>Basics</h2>
<p>Compress the file <em>foo</em> into <em>foo.xz</em> using the default
compression level (<strong>-6</strong>), and remove <em>foo</em> if
compression is successful:</p>
<blockquote>
<pre><code>xz foo</code></pre>
</blockquote>
<p>Decompress <em>bar.xz</em> into <em>bar</em> and don't remove
<em>bar.xz</em> even if decompression is successful:</p>
<blockquote>
<pre><code>xz -dk bar.xz</code></pre>
</blockquote>
<p>Create <em>baz.tar.xz</em> with the preset <strong>-4e</strong>
(<strong>-4 --extreme</strong>), which is slower than the default
<strong>-6</strong>, but needs less memory for compression and
decompression (48 MiB and 5 MiB, respectively):</p>
<blockquote>
<pre><code>tar cf - baz | xz -4e &gt; baz.tar.xz</code></pre>
</blockquote>
<p>A mix of compressed and uncompressed files can be decompressed to
standard output with a single command:</p>
<blockquote>
<pre><code>xz -dcf a.txt b.txt.xz c.txt d.txt.lzma &gt; abcd.txt</code></pre>
</blockquote>
<h2>Parallel compression of many files</h2>
<p>On GNU and *BSD, <strong>find</strong>(1) and
<strong>xargs</strong>(1) can be used to parallelize compression of many
files:</p>
<blockquote>
<pre><code>find . -type f \! -name &#39;*.xz&#39; -print0 \
    | xargs -0r -P4 -n16 xz -T1</code></pre>
</blockquote>
<p>The <strong>-P</strong> option to <strong>xargs</strong>(1) sets the
number of parallel <strong>xz</strong> processes. The best value for the
<strong>-n</strong> option depends on how many files there are to be
compressed. If there are only a couple of files, the value should
probably be 1; with tens of thousands of files, 100 or even more may be
appropriate to reduce the number of <strong>xz</strong> processes that
<strong>xargs</strong>(1) will eventually create.</p>
<p>The option <strong>-T1</strong> for <strong>xz</strong> is there to
force it to single-threaded mode, because <strong>xargs</strong>(1) is
used to control the amount of parallelization.</p>
<h2>Robot mode</h2>
<p>Calculate how many bytes have been saved in total after compressing
multiple files:</p>
<blockquote>
<pre><code>xz --robot --list *.xz | awk &#39;/^totals/{print $5-$4}&#39;</code></pre>
</blockquote>
<p>A script may want to know that it is using new enough
<strong>xz</strong>. The following <strong>sh</strong>(1) script checks
that the version number of the <strong>xz</strong> tool is at least
5.0.0. This method is compatible with old beta versions, which didn't
support the <strong>--robot</strong> option:</p>
<blockquote>
<pre><code>if ! eval &quot;$(xz --robot --version 2&gt; /dev/null)&quot; ||
        [ &quot;$XZ_VERSION&quot; -lt 50000002 ]; then
    echo &quot;Your xz is too old.&quot;
fi
unset XZ_VERSION LIBLZMA_VERSION</code></pre>
</blockquote>
<p>Set a memory usage limit for decompression using
<strong>XZ_OPT</strong>, but if a limit has already been set, don't
increase it:</p>
<blockquote>
<pre><code>NEWLIM=$((123 &lt;&lt; 20))  # 123 MiB
OLDLIM=$(xz --robot --info-memory | cut -f3)
if [ $OLDLIM -eq 0 -o $OLDLIM -gt $NEWLIM ]; then
    XZ_OPT=&quot;$XZ_OPT --memlimit-decompress=$NEWLIM&quot;
    export XZ_OPT
fi</code></pre>
</blockquote>
<h2>Custom compressor filter chains</h2>
<p>The simplest use for custom filter chains is customizing a LZMA2
preset. This can be useful, because the presets cover only a subset of
the potentially useful combinations of compression settings.</p>
<p>The CompCPU columns of the tables from the descriptions of the
options <strong>-0</strong> ... <strong>-9</strong> and
<strong>--extreme</strong> are useful when customizing LZMA2 presets.
Here are the relevant parts collected from those two tables:</p>
<blockquote>
<table>
<tbody>
<tr class="odd">
<td style="text-align: center;">Preset</td>
<td style="text-align: center;">CompCPU</td>
</tr>
<tr class="even">
<td style="text-align: center;">-0</td>
<td style="text-align: center;">0</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-1</td>
<td style="text-align: center;">1</td>
</tr>
<tr class="even">
<td style="text-align: center;">-2</td>
<td style="text-align: center;">2</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-3</td>
<td style="text-align: center;">3</td>
</tr>
<tr class="even">
<td style="text-align: center;">-4</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5</td>
<td style="text-align: center;">5</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6</td>
<td style="text-align: center;">6</td>
</tr>
<tr class="odd">
<td style="text-align: center;">-5e</td>
<td style="text-align: center;">7</td>
</tr>
<tr class="even">
<td style="text-align: center;">-6e</td>
<td style="text-align: center;">8</td>
</tr>
</tbody>
</table>
</blockquote>
<p>If you know that a file requires somewhat big dictionary (for
example, 32 MiB) to compress well, but you want to compress it quicker
than <strong>xz -8</strong> would do, a preset with a low CompCPU value
(for example, 1) can be modified to use a bigger dictionary:</p>
<blockquote>
<pre><code>xz --lzma2=preset=1,dict=32MiB foo.tar</code></pre>
</blockquote>
<p>With certain files, the above command may be faster than <strong>xz
-6</strong> while compressing significantly better. However, it must be
emphasized that only some files benefit from a big dictionary while
keeping the CompCPU value low. The most obvious situation, where a big
dictionary can help a lot, is an archive containing very similar files
of at least a few megabytes each. The dictionary size has to be
significantly bigger than any individual file to allow LZMA2 to take
full advantage of the similarities between consecutive files.</p>
<p>If very high compressor and decompressor memory usage is fine, and
the file being compressed is at least several hundred megabytes, it may
be useful to use an even bigger dictionary than the 64 MiB that
<strong>xz -9</strong> would use:</p>
<blockquote>
<pre><code>xz -vv --lzma2=dict=192MiB big_foo.tar</code></pre>
</blockquote>
<p>Using <strong>-vv</strong> (<strong>--verbose --verbose</strong>)
like in the above example can be useful to see the memory requirements
of the compressor and decompressor. Remember that using a dictionary
bigger than the size of the uncompressed file is waste of memory, so the
above command isn't useful for small files.</p>
<p>Sometimes the compression time doesn't matter, but the decompressor
memory usage has to be kept low, for example, to make it possible to
decompress the file on an embedded system. The following command uses
<strong>-6e</strong> (<strong>-6 --extreme</strong>) as a base and sets
the dictionary to only 64 KiB. The resulting file can be decompressed
with XZ Embedded (that's why there is <strong>--check=crc32</strong>)
using about 100 KiB of memory.</p>
<blockquote>
<pre><code>xz --check=crc32 --lzma2=preset=6e,dict=64KiB foo</code></pre>
</blockquote>
<p>If you want to squeeze out as many bytes as possible, adjusting the
number of literal context bits (<em>lc</em>) and number of position bits
(<em>pb</em>) can sometimes help. Adjusting the number of literal
position bits (<em>lp</em>) might help too, but usually <em>lc</em> and
<em>pb</em> are more important. For example, a source code archive
contains mostly US-ASCII text, so something like the following might
give slightly (like 0.1 %) smaller file than <strong>xz -6e</strong>
(try also without <strong>lc=4</strong>):</p>
<blockquote>
<pre><code>xz --lzma2=preset=6e,pb=0,lc=4 source_code.tar</code></pre>
</blockquote>
<p>Using another filter together with LZMA2 can improve compression with
certain file types. For example, to compress a x86-32 or x86-64 shared
library using the x86 BCJ filter:</p>
<blockquote>
<pre><code>xz --x86 --lzma2 libfoo.so</code></pre>
</blockquote>
<p>Note that the order of the filter options is significant. If
<strong>--x86</strong> is specified after <strong>--lzma2</strong>,
<strong>xz</strong> will give an error, because there cannot be any
filter after LZMA2, and also because the x86 BCJ filter cannot be used
as the last filter in the chain.</p>
<p>The Delta filter together with LZMA2 can give good results with
bitmap images. It should usually beat PNG, which has a few more advanced
filters than simple delta but uses Deflate for the actual
compression.</p>
<p>The image has to be saved in uncompressed format, for example, as
uncompressed TIFF. The distance parameter of the Delta filter is set to
match the number of bytes per pixel in the image. For example, 24-bit
RGB bitmap needs <strong>dist=3</strong>, and it is also good to pass
<strong>pb=0</strong> to LZMA2 to accommodate the three-byte
alignment:</p>
<blockquote>
<pre><code>xz --delta=dist=3 --lzma2=pb=0 foo.tiff</code></pre>
</blockquote>
<p>If multiple images have been put into a single archive (for example,
<strong>.tar</strong>), the Delta filter will work on that too as long
as all images have the same number of bytes per pixel.</p>
<h1>SEE ALSO</h1>
<p><strong>xzdec</strong>(1), <strong>xzdiff</strong>(1),
<strong>xzgrep</strong>(1), <strong>xzless</strong>(1),
<strong>xzmore</strong>(1), <strong>gzip</strong>(1),
<strong>bzip2</strong>(1), <strong>7z</strong>(1)</p>
<p>XZ Utils: &lt;https://tukaani.org/xz/&gt;<br />
XZ Embedded: &lt;https://tukaani.org/xz/embedded.html&gt;<br />
LZMA SDK: &lt;http://7-zip.org/sdk.html&gt;</p>
