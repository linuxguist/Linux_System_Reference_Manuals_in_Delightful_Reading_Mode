<pre><code></code></pre>
<p><br />
</p>
<link rel='stylesheet' href='../style.css'>
<script src='../script.js'></script>
<h1>NAME</h1>
<p>h2xs - convert .h C header files to Perl extensions</p>
<h1>SYNOPSIS</h1>
<p><strong>h2xs</strong> [<strong>OPTIONS</strong> ...] [headerfile ...
[extra_libraries]]</p>
<p><strong>h2xs</strong>
<strong>-h</strong>|<strong>-?</strong>|<strong>--help</strong></p>
<h1>DESCRIPTION</h1>
<p><em>h2xs</em> builds a Perl extension from C header files. The
extension will include functions which can be used to retrieve the value
of any #define statement which was in the C header files.</p>
<p>The <em>module_name</em> will be used for the name of the extension.
If module_name is not supplied then the name of the first header file
will be used, with the first character capitalized.</p>
<p>If the extension might need extra libraries, they should be included
here. The extension Makefile.PL will take care of checking whether the
libraries actually exist and how they should be loaded. The extra
libraries should be specified in the form -lm -lposix, etc, just as on
the cc command line. By default, the Makefile.PL will search through the
library path determined by Configure. That path can be augmented by
including arguments of the form <strong>-L/another/library/path</strong>
in the extra-libraries argument.</p>
<p>In spite of its name, <em>h2xs</em> may also be used to create a
skeleton pure Perl module. See the <strong>-X</strong> option.</p>
<h1>OPTIONS</h1>
<dl>
<dt>-A, --omit-autoload</dt>
<dd>
<p>Omit all autoload facilities. This is the same as <strong>-c</strong>
but also removes the <code>use AutoLoader</code> statement from the .pm
file.</p>
</dd>
<dt>-B, --beta-version</dt>
<dd>
<p>Use an alpha/beta style version number. Causes version number to be
0.00_01 unless <strong>-v</strong> is specified.</p>
</dd>
<dt>-C, --omit-changes</dt>
<dd>
<p>Omits creation of the <em>Changes</em> file, and adds a HISTORY
section to the POD template.</p>
</dd>
<dt>-F, --cpp-flags=addflags</dt>
<dd>
<p>Additional flags to specify to C preprocessor when scanning header
for function declarations. Writes these options in the generated
<em>Makefile.PL</em> too.</p>
</dd>
<dt>-M, --func-mask=regular expression</dt>
<dd>
<p>selects functions/macros to process.</p>
</dd>
<dt>-O, --overwrite-ok</dt>
<dd>
<p>Allows a pre-existing extension directory to be overwritten.</p>
</dd>
<dt>-P, --omit-pod</dt>
<dd>
<p>Omit the autogenerated stub POD section.</p>
</dd>
<dt>-X, --omit-XS</dt>
<dd>
<p>Omit the XS portion. Used to generate a skeleton pure Perl module.
<code>-c</code> and <code>-f</code> are implicitly enabled.</p>
</dd>
<dt>-a, --gen-accessors</dt>
<dd>
<p>Generate an accessor method for each element of structs and unions.
The generated methods are named after the element name; will return the
current value of the element if called without additional arguments; and
will set the element to the supplied value (and return the new value) if
called with an additional argument. Embedded structures and unions are
returned as a pointer rather than the complete structure, to facilitate
chained calls. These methods all apply to the Ptr type for the
structure; additionally two methods are constructed for the structure
type itself, <code>_to_ptr</code> which returns a Ptr type pointing to
the same structure, and a <code>new</code> method to construct and
return a new structure, initialised to zeroes.</p>
</dd>
<dt>-b, --compat-version=version</dt>
<dd>
<p>Generates a .pm file which is backwards compatible with the specified
perl version. For versions &lt; 5.6.0, the changes are. - no use of
'our' (uses 'use vars' instead) - no 'use warnings' Specifying a
compatibility version higher than the version of perl you are using to
run h2xs will have no effect. If unspecified h2xs will default to
compatibility with the version of perl you are using to run h2xs.</p>
</dd>
<dt>-c, --omit-constant</dt>
<dd>
<p>Omit <code>constant()</code> from the .xs file and corresponding
specialised <code>AUTOLOAD</code> from the .pm file.</p>
</dd>
<dt>-d, --debugging</dt>
<dd>
<p>Turn on debugging messages.</p>
</dd>
<dt>-e, --omit-enums=[regular expression]</dt>
<dd>
<p>If <em>regular expression</em> is not given, skip all constants that
are defined in a C enumeration. Otherwise skip only those constants that
are defined in an enum whose name matches <em>regular expression</em>.
Since <em>regular expression</em> is optional, make sure that this
switch is followed by at least one other switch if you omit <em>regular
expression</em> and have some pending arguments such as header-file
names. This is ok: h2xs -e -n Module::Foo foo.h This is not ok: h2xs -n
Module::Foo -e foo.h In the latter, foo.h is taken as <em>regular
expression</em>.</p>
</dd>
<dt>-f, --force</dt>
<dd>
<p>Allows an extension to be created for a header even if that header is
not found in standard include directories.</p>
</dd>
<dt>-g, --global</dt>
<dd>
<p>Include code for safely storing static data in the .xs file.
Extensions that do no make use of static data can ignore this
option.</p>
</dd>
<dt>-h, -?, --help</dt>
<dd>
<p>Print the usage, help and version for this h2xs and exit.</p>
</dd>
<dt>-k, --omit-const-func</dt>
<dd>
<p>For function arguments declared as <code>const</code>, omit the const
attribute in the generated XS code.</p>
</dd>
<dt>-m, --gen-tied-var</dt>
<dd>
<p><strong>Experimental</strong>: for each variable declared in the
header file(s), declare a perl variable of the same name magically tied
to the C variable.</p>
</dd>
<dt>-n, --name=module_name</dt>
<dd>
<p>Specifies a name to be used for the extension, e.g., -n RPC::DCE</p>
</dd>
<dt>-o, --opaque-re=regular expression</dt>
<dd>
<p>Use opaque data type for the C types matched by the regular
expression, even if these types are <code>typedef</code>-equivalent to
types from typemaps. Should not be used without <strong>-x</strong>.
This may be useful since, say, types which are
<code>typedef</code>-equivalent to integers may represent OS-related
handles, and one may want to work with these handles in OO-way, as in
<code>$handle-&gt;do_something()</code>. Use <code>-o .</code> if you
want to handle all the <code>typedef</code>ed types as opaque types. The
type-to-match is whitewashed (except for commas, which have no
whitespace before them, and multiple <code>*</code> which have no
whitespace between them).</p>
</dd>
<dt>-p, --remove-prefix=prefix</dt>
<dd>
<p>Specify a prefix which should be removed from the Perl function
names, e.g., -p sec_rgy_ This sets up the XS <strong>PREFIX</strong>
keyword and removes the prefix from functions that are autoloaded via
the <code>constant()</code> mechanism.</p>
</dd>
<dt>-s, --const-subs=sub1,sub2</dt>
<dd>
<p>Create a perl subroutine for the specified macros rather than
autoload with the <strong>constant()</strong> subroutine. These macros
are assumed to have a return type of <strong>char *</strong>, e.g.,
-s sec_rgy_wildcard_name,sec_rgy_wildcard_sid.</p>
</dd>
<dt>-t, --default-type=type</dt>
<dd>
<p>Specify the internal type that the <strong>constant()</strong>
mechanism uses for macros. The default is IV (signed integer). Currently
all macros found during the header scanning process will be assumed to
have this type. Future versions of <code>h2xs</code> may gain the
ability to make educated guesses.</p>
</dd>
<dt>--use-new-tests</dt>
<dd>
<p>When <strong>--compat-version</strong> (<strong>-b</strong>) is
present the generated tests will use <code>Test::More</code> rather than
<code>Test</code> which is the default for versions before 5.6.2.
<code>Test::More</code> will be added to PREREQ_PM in the generated
<code>Makefile.PL</code>.</p>
</dd>
<dt>--use-old-tests</dt>
<dd>
<p>Will force the generation of test code that uses the older
<code>Test</code> module.</p>
</dd>
<dt>--skip-exporter</dt>
<dd>
<p>Do not use <code>Exporter</code> and/or export any symbol.</p>
</dd>
<dt>--skip-ppport</dt>
<dd>
<p>Do not use <code>Devel::PPPort</code>: no portability to older
version.</p>
</dd>
<dt>--skip-autoloader</dt>
<dd>
<p>Do not use the module <code>AutoLoader</code>; but keep the
<strong>constant()</strong> function and <code>sub AUTOLOAD</code> for
constants.</p>
</dd>
<dt>--skip-strict</dt>
<dd>
<p>Do not use the pragma <code>strict</code>.</p>
</dd>
<dt>--skip-warnings</dt>
<dd>
<p>Do not use the pragma <code>warnings</code>.</p>
</dd>
<dt>-v, --version=version</dt>
<dd>
<p>Specify a version number for this extension. This version number is
added to the templates. The default is 0.01, or 0.00_01 if
<code>-B</code> is specified. The version specified should be
numeric.</p>
</dd>
<dt>-x, --autogen-xsubs</dt>
<dd>
<p>Automatically generate XSUBs basing on function declarations in the
header file. The package <code>C::Scan</code> should be installed. If
this option is specified, the name of the header file may look like
<code>NAME1,NAME2</code>. In this case NAME1 is used instead of the
specified string, but XSUBs are emitted only for the declarations
included from file NAME2. Note that some types of
arguments/return-values for functions may result in
XSUB-declarations/typemap-entries which need hand-editing. Such may be
objects which cannot be converted from/to a pointer (like
<code>long long</code>), pointers to functions, or arrays. See also the
section on "LIMITATIONS of <strong>-x</strong>".</p>
</dd>
</dl>
<h1>EXAMPLES</h1>
<p># Default behavior, extension is Rusers h2xs rpcsvc/rusers # Same,
but extension is RUSERS h2xs -n RUSERS rpcsvc/rusers # Extension is
rpcsvc::rusers. Still finds &lt;rpcsvc/rusers.h&gt; h2xs rpcsvc::rusers
# Extension is ONC::RPC. Still finds &lt;rpcsvc/rusers.h&gt; h2xs -n
ONC::RPC rpcsvc/rusers # Without constant() or AUTOLOAD h2xs -c
rpcsvc/rusers # Creates templates for an extension named RPC h2xs -cfn
RPC # Extension is ONC::RPC. h2xs -cfn ONC::RPC # Extension is a pure
Perl module with no XS code. h2xs -X My::Module # Extension is Lib::Foo
which works at least with Perl5.005_03. # Constants are created for all
#defines and enums h2xs can find # in foo.h. h2xs -b 5.5.3 -n Lib::Foo
foo.h # Extension is Lib::Foo which works at least with Perl5.005_03. #
Constants are created for all #defines but only for enums # whose names
do not start with bar_. h2xs -b 5.5.3 -e ^bar_ -n Lib::Foo foo.h #
Makefile.PL will look for library -lrpc in # additional directory
/opt/net/lib h2xs rpcsvc/rusers -L/opt/net/lib -lrpc # Extension is
DCE::rgynbase # prefix "sec_rgy_" is dropped from perl function names
h2xs -n DCE::rgynbase -p sec_rgy_ dce/rgynbase # Extension is
DCE::rgynbase # prefix "sec_rgy_" is dropped from perl function names #
subroutines are created for sec_rgy_wildcard_name and #
sec_rgy_wildcard_sid h2xs -n DCE::rgynbase -p sec_rgy_ \ -s
sec_rgy_wildcard_name,sec_rgy_wildcard_sid dce/rgynbase # Make XS
without defines in perl.h, but with function declarations # visible from
perl.h. Name of the extension is perl1. # When scanning perl.h, define
-DEXT=extern -DdEXT= -DINIT(x)= # Extra backslashes below because the
string is passed to shell. # Note that a directory with perl header
files would # be added automatically to include path. h2xs -xAn perl1 -F
"-DEXT=extern -DdEXT= -DINIT\(x\)=" perl.h # Same with function
declaration in proto.h as visible from perl.h. h2xs -xAn perl2
perl.h,proto.h # Same but select only functions which match /^av_/ h2xs
-M ^av_ -xAn perl2 perl.h,proto.h # Same but treat SV* etc as "opaque"
types h2xs -o ^[S]V \*$ -M ^av_ -xAn perl2 perl.h,proto.h</p>
<h2>Extension based on <em>.h</em> and <em>.c</em> files</h2>
<p>Suppose that you have some C files implementing some functionality,
and the corresponding header files. How to create an extension which
makes this functionality accessible in Perl? The example below assumes
that the header files are <em>interface_simple.h</em> and
<em>interface_hairy.h</em>, and you want the perl module be named as
<code>Ext::Ension</code>. If you need some preprocessor directives
and/or linking with external libraries, see the flags <code>-F</code>,
<code>-L</code> and <code>-l</code> in OPTIONS.</p>
<dl>
<dt>Find the directory name</dt>
<dd>
<p>Start with a dummy run of h2xs: h2xs -Afn Ext::Ension The only
purpose of this step is to create the needed directories, and let you
know the names of these directories. From the output you can see that
the directory for the extension is <em>Ext/Ension</em>.</p>
</dd>
<dt>Copy C files</dt>
<dd>
<p>Copy your header files and C files to this directory
<em>Ext/Ension</em>.</p>
</dd>
<dt>Create the extension</dt>
<dd>
<p>Run h2xs, overwriting older autogenerated files: h2xs -Oxan
Ext::Ension interface_simple.h interface_hairy.h h2xs looks for header
files <em>after</em> changing to the extension directory, so it will
find your header files OK.</p>
</dd>
<dt>Archive and test</dt>
<dd>
<p>As usual, run cd Ext/Ension perl Makefile.PL make dist make make
test</p>
</dd>
<dt>Hints</dt>
<dd>
<p>It is important to do <code>make dist</code> as early as possible.
This way you can easily <strong>merge</strong> (1) your changes to
autogenerated files if you decide to edit your <code>.h</code> files and
rerun h2xs. Do not forget to edit the documentation in the generated
<em>.pm</em> file. Consider the autogenerated files as skeletons only,
you may invent better interfaces than what h2xs could guess. Consider
this section as a guideline only, some other options of h2xs may better
suit your needs.</p>
</dd>
</dl>
<h1>ENVIRONMENT</h1>
<p>No environment variables are used.</p>
<h1>AUTHOR</h1>
<p>Larry Wall and others</p>
<h1>SEE ALSO</h1>
<p>perl, perlxstut, ExtUtils::MakeMaker, and AutoLoader.</p>
<h1>DIAGNOSTICS</h1>
<p>The usual warnings if it cannot read or write the files involved.</p>
<h1>LIMITATIONS of <strong>-x</strong></h1>
<p><em>h2xs</em> would not distinguish whether an argument to a C
function which is of the form, say, <code>int *</code>, is an input,
output, or input/output parameter. In particular, argument declarations
of the form</p>
<p>int foo(n) int *n</p>
<p>should be better rewritten as</p>
<p>int foo(n) int &amp;n</p>
<p>if <code>n</code> is an input parameter.</p>
<p>Additionally, <em>h2xs</em> has no facilities to intuit that a
function</p>
<p>int foo(addr,l) char *addr int l</p>
<p>takes a pair of address and length of data at this address, so it is
better to rewrite this function as</p>
<p>int foo(sv) SV *addr PREINIT: STRLEN len; char *s; CODE: s =
SvPV(sv,len); RETVAL = foo(s, len); OUTPUT: RETVAL</p>
<p>or alternately</p>
<p>static int my_foo(SV *sv) { STRLEN len; char *s = SvPV(sv,len);
return foo(s, len); } MODULE = foo PACKAGE = foo PREFIX = my_ int
foo(sv) SV *sv</p>
<p>See perlxs and perlxstut for additional details.</p>
